/**
 * SimpleController - Simple controller framework
 *
 * For EmulatorJS-style controllers (SNES, Genesis, etc.):
 * - Fixed 30 inputs per frame per player
 * - Player indices 0-3
 * - Input indices 0-29
 * - Values: 0/1 for buttons, -32767 to 32767 for analog
 */

class SimpleController {
  constructor(emulatorAdapter, config = {}) {
    this.maxInputs = 30;
    this.maxPlayers = 4;
    this.emulator = emulatorAdapter;
    this.config = config;

    // Input storage: frame -> array of input data
    this.inputsData = {};
    this.currentFrame = null;
    this.frameDelay = 20; // Default frame delay for input synchronization

    // Edge-trigger optimization: track last known values to avoid sending unchanged inputs
    this.lastInputValues = {}; // key: `${playerIndex}-${inputIndex}`, value: last sent value

    // Slot change callback to clear cache when slots change
    this.onSlotChanged = config?.onSlotChanged;

    // Callback to get current player slot (consistent with UI)
    this.getCurrentSlot = config?.getCurrentSlot;
  }

  /**
   * Validate input message for simple controller.
   * @param {Object} input - Input message
   * @returns {boolean} True if valid
   */
  validateInput(input) {
    if (
      typeof input.playerIndex !== "number" ||
      input.playerIndex < 0 ||
      (input.playerIndex >= this.maxPlayers && input.playerIndex !== 8)
    ) {
      return false;
    }
    if (
      typeof input.inputIndex !== "number" ||
      input.inputIndex < 0 ||
      input.inputIndex >= this.maxInputs
    ) {
      return false;
    }
    if (typeof input.value !== "number") {
      return false;
    }
    return true;
  }

  /**
   * Set current frame for input processing.
   * @param {number} frame
   */
  setCurrentFrame(frame) {
    this.currentFrame = frame;
  }

  /**
   * Get current frame.
   * @returns {number}
   */
  getCurrentFrame() {
    return this.currentFrame;
  }

  /**
   * Initialize frame tracking.
   * @param {number} initFrame
   */
  initializeFrames(initFrame) {
    this.currentFrame = 0;
    this.inputsData = {};
  }

  /**
   * Queue local input for processing (simple controller specific logic).
   * @param {number} playerIndex
   * @param {number} inputIndex
   * @param {number} value
   * @returns {boolean}
   */
  queueLocalInput(playerIndex, inputIndex, value) {
    // Store original playerIndex for local simulation
    // Slot enforcement will happen in the send callback

    // Edge-trigger optimization (simple controller specific)
    const inputKey = `${playerIndex}-${inputIndex}`;
    const lastValue = this.lastInputValues[inputKey];
    if (lastValue === value) {
      console.log("[SimpleController] Skipping unchanged input:", {
        playerIndex: playerIndex,
        inputIndex,
        value,
      });
      return true; // Not an error, just no change
    }
    this.lastInputValues[inputKey] = value;

    if (!this.validateInput({ playerIndex: playerIndex, inputIndex, value })) {
      console.warn("[SimpleController] Invalid local input:", {
        playerIndex: playerIndex,
        inputIndex,
        value,
      });
      return false;
    }

    // Store input for current frame
    const currentFrame =
      this.currentFrame !== null && this.currentFrame !== undefined
        ? this.currentFrame
        : 0;

    if (!this.inputsData[currentFrame]) {
      this.inputsData[currentFrame] = [];
    }

    this.inputsData[currentFrame].push({
      frame: currentFrame,
      connected_input: [playerIndex, inputIndex, value],
      fromRemote: false,
    });

    console.log("[SimpleController] Queued local input:", {
      frame: currentFrame,
      playerIndex: playerIndex,
      inputIndex,
      value,
    });

    return true;
  }

  /**
   * Apply effective player index with slot enforcement (simple controller specific).
   * @param {number} requestedPlayerIndex - Requested player index
   * @returns {number} Effective player index (0-3)
   */
  getEffectivePlayerIndex(requestedPlayerIndex) {
    let playerIndex = parseInt(requestedPlayerIndex, 10);
    if (isNaN(playerIndex)) playerIndex = 0;
    if (playerIndex < 0) playerIndex = 0;
    if (playerIndex > 3) playerIndex = 3;

    // Slot enforcement: use the lobby-selected slot for all players (host and client)
    // This ensures inputs are sent with the correct player index based on assigned slot
    const globalPreferredSlot =
      typeof window.EJS_NETPLAY_PREFERRED_SLOT === "number"
        ? window.EJS_NETPLAY_PREFERRED_SLOT
        : null;

    const preferredSlot =
      globalPreferredSlot !== null
        ? globalPreferredSlot
        : (typeof window !== "undefined" && window.EJS_netplay?.localSlot) ||
          0;
    const slot = parseInt(preferredSlot, 10);
    if (!isNaN(slot) && slot >= 0 && slot <= 3) {
      if (playerIndex !== slot) {
        console.log(
          "[SimpleController] Slot enforcement: requested playerIndex",
          playerIndex,
          "-> enforced slot",
          slot,
        );
      }
      playerIndex = slot;
    }

    return playerIndex;
  }

  /**
   * Handle remote input from network.
   * @param {InputPayload} payload
   * @param {string} fromSocketId
   * @returns {boolean}
   */
  handleRemoteInput(payload, fromSocketId = null) {
    const connectedInput = payload.getConnectedInput();

    if (
      !this.validateInput({
        playerIndex: connectedInput[0],
        inputIndex: connectedInput[1],
        value: connectedInput[2],
      })
    ) {
      console.warn("[SimpleController] Invalid remote input:", connectedInput);
      return false;
    }

    // Apply remote input immediately (delay-sync mode)
    const [playerIndex, inputIndex, value] = connectedInput;

    console.log("[SimpleController] Applying remote input immediately:", {
      playerIndex,
      inputIndex,
      value,
      fromSocketId,
    });

    if (this.emulator && typeof this.emulator.simulateInput === "function") {
      this.emulator.simulateInput(playerIndex, inputIndex, value);
    } else {
      console.warn(
        "[SimpleController] No emulator available to apply remote input",
      );
    }

    return true;
  }

  /**
   * Process all inputs for the current frame and apply to emulator.
   * @returns {Array} Array of inputs processed
   */
  processFrameInputs() {
    const frame = this.currentFrame;

    console.log(`[SimpleController] Processing inputs for frame ${frame}`);

    if (!this.inputsData[frame]) {
      console.log(`[SimpleController] No inputs queued for frame ${frame}`);
      return [];
    }

    const inputsForFrame = this.inputsData[frame];
    const processedInputs = [];

    console.log(
      `[SimpleController] Applying ${inputsForFrame.length} inputs for frame ${frame}`,
    );

    // Apply each input to the emulator
    inputsForFrame.forEach((inputData, index) => {
      const [playerIndex, inputIndex, value] = inputData.connected_input;

      console.log(
        `[SimpleController] Frame ${frame} - Applying input ${index + 1}/${inputsForFrame.length}:`,
        `player ${playerIndex}, input ${inputIndex}, value ${value}, remote: ${inputData.fromRemote}`,
      );

      // Apply input to emulator (remote inputs are already applied immediately)
      if (this.emulator && typeof this.emulator.simulateInput === "function") {
        this.emulator.simulateInput(playerIndex, inputIndex, value);
      }

      processedInputs.push({
        frame: frame,
        connected_input: [playerIndex, inputIndex, value],
        fromRemote: inputData.fromRemote,
      });
    });

    // Clean up processed inputs
    delete this.inputsData[frame];

    // Memory cleanup: remove old frames
    const maxAge = 120;
    const cutoffFrame = frame - maxAge;
    for (const oldFrame of Object.keys(this.inputsData)) {
      if (parseInt(oldFrame, 10) < cutoffFrame) {
        delete this.inputsData[oldFrame];
      }
    }

    return processedInputs;
  }

  /**
   * Send input to network (for clients in delay-sync mode).
   * @param {number} playerIndex
   * @param {number} inputIndex
   * @param {number} value
   * @param {Function} sendCallback
   * @returns {boolean}
   */
  sendInput(playerIndex, inputIndex, value, sendCallback, inputSync) {
    // Apply slot enforcement (simple controller specific)
    const effectivePlayerIndex = this.getEffectivePlayerIndex(playerIndex);

    // Edge-trigger optimization (simple controller specific)
    const inputKey = `${effectivePlayerIndex}-${inputIndex}`;
    const lastValue = this.lastInputValues[inputKey];
    if (lastValue === value) {
      console.log("[SimpleController] Skipping unchanged input:", {
        playerIndex: effectivePlayerIndex,
        inputIndex,
        value,
      });
      return true; // Not an error, just no change
    }
    this.lastInputValues[inputKey] = value;

    if (
      !this.validateInput({
        playerIndex: effectivePlayerIndex,
        inputIndex,
        value,
      })
    ) {
      return false;
    }

    console.log("[SimpleController] Sending input to network:", {
      currentFrame: this.currentFrame,
      playerIndex: effectivePlayerIndex,
      inputIndex,
      value,
    });

    if (sendCallback && inputSync) {
      // Use InputSync's serialization (maintains frame delay logic)
      const inputData = inputSync.serializeInput(
        effectivePlayerIndex,
        inputIndex,
        value,
      );
      console.log("[SimpleController] Sending input via callback:", inputData);
      sendCallback(inputData.frame, inputData);
    }

    return true;
  }

  /**
   * Create empty input state array.
   * @returns {number[]} Array of 30 zeros
   */
  createInputState() {
    return new Array(this.maxInputs).fill(0);
  }

  /**
   * Get maximum inputs per player.
   * @returns {number}
   */
  getMaxInputs() {
    return this.maxInputs;
  }

  /**
   * Get maximum players.
   * @returns {number}
   */
  getMaxPlayers() {
    return this.maxPlayers;
  }

  /**
   * Handle slot change notification (clear edge-trigger cache)
   * @param {string} playerId - Player whose slot changed
   * @param {number|null} newSlot - New slot assignment
   */
  handleSlotChange(playerId, newSlot) {
    console.log(
      "[SimpleController] Slot changed, clearing edge-trigger cache for player:",
      playerId,
    );
    // Clear the entire cache when any slot changes to ensure clean state
    this.lastInputValues = {};
  }
}

window.SimpleController = SimpleController;

/**
 * ComplexController - Complex controller framework
 * 
 * For native emulator controllers (Switch, PS3, Wii, Xbox, etc.):
 * - Variable inputs per controller type
 * - Player indices 0-7
 * - Input indices variable based on controller type
 * - Values vary by controller type
 * 
 * TODO: Implement controller-specific mappings in future phases
 */

class ComplexController {
  constructor(controllerType = "standard") {
    this.controllerType = controllerType;
    this.maxPlayers = 8;
    this.inputMap = this._getInputMapForType(controllerType);
  }

  /**
   * Get input map for controller type.
   * @private
   * @param {string} type - Controller type
   * @returns {Object} Input mapping configuration
   */
  _getInputMapForType(type) {
    // TODO: Implement controller-specific mappings
    // Example: Switch Pro Controller has X, Y, A, B, triggers, sticks, etc.
    // Example: PS3 controller has DualShock 3 specific mappings
    return {
      maxInputs: 64, // Placeholder for now
      type: type,
    };
  }

  /**
   * Validate input message for complex controller.
   * @param {Object} input - Input message
   * @returns {boolean} True if valid
   */
  validateInput(input) {
    if (typeof input.playerIndex !== "number" || 
        input.playerIndex < 0 || input.playerIndex >= this.maxPlayers) {
      return false;
    }
    if (typeof input.inputIndex !== "number" || input.inputIndex < 0) {
      return false;
    }
    if (input.inputIndex >= this.inputMap.maxInputs) {
      return false;
    }
    if (typeof input.value !== "number") {
      return false;
    }
    if (input.controllerType !== this.controllerType) {
      return false;
    }
    return true;
  }

  /**
   * Create empty input state array for this controller type.
   * @returns {number[]} Array of zeros
   */
  createInputState() {
    return new Array(this.inputMap.maxInputs).fill(0);
  }

  /**
   * Get maximum inputs for this controller type.
   * @returns {number}
   */
  getMaxInputs() {
    return this.inputMap.maxInputs;
  }

  /**
   * Get maximum players.
   * @returns {number}
   */
  getMaxPlayers() {
    return this.maxPlayers;
  }

  /**
   * Get controller type.
   * @returns {string}
   */
  getControllerType() {
    return this.controllerType;
  }
}

window.ComplexController = ComplexController;

/**
 * InputQueue - Input buffering and retry logic
 *
 * Manages input queue for:
 * - Input buffering
 * - Retry logic for lost inputs
 * - Unordered retry handling
 */

class InputQueue {
  /**
   * @param {Object} config - Configuration
   * @param {number} config.unorderedRetries - Number of unordered retries (default: 0)
   */
  constructor(config = {}) {
    this.config = config;
    this.unorderedRetries = config.unorderedRetries || 0;
    this.queue = [];
    this.retryQueue = [];
  }

  /**
   * Enqueue input for sending.
   * @param {Object} input - Input data {frame, connected_input, ...}
   */
  enqueue(input) {
    this.queue.push({
      ...input,
      retryCount: 0,
      timestamp: Date.now(),
    });
  }

  /**
   * Dequeue inputs for a specific frame.
   * @param {number} frame - Target frame number
   * @returns {Array} Array of input data for the frame
   */
  dequeue(frame) {
    const inputs = this.queue.filter((item) => item.frame === frame);
    this.queue = this.queue.filter((item) => item.frame !== frame);
    return inputs;
  }

  /**
   * Get inputs for a specific frame without removing them.
   * @param {number} frame - Target frame number
   * @returns {Array} Array of input data for the frame
   */
  peek(frame) {
    return this.queue.filter((item) => item.frame === frame);
  }

  /**
   * Mark input as acknowledged (for retry logic).
   * @param {number} frame - Acknowledged frame number
   */
  acknowledge(frame) {
    // Remove acknowledged inputs from queue
    this.queue = this.queue.filter((item) => item.frame !== frame);
  }

  /**
   * Get inputs that need retry (for unordered mode).
   * @param {number} currentFrame - Current frame number
   * @param {number} maxAge - Maximum frame age for retry
   * @returns {Array} Array of inputs that should be retried
   */
  getRetryInputs(currentFrame, maxAge = 3) {
    if (this.unorderedRetries <= 0) {
      return [];
    }

    const retryInputs = [];
    this.queue.forEach((item) => {
      if (
        item.frame < currentFrame &&
        currentFrame - item.frame <= maxAge &&
        item.retryCount < this.unorderedRetries
      ) {
        item.retryCount++;
        retryInputs.push(item);
      }
    });

    return retryInputs;
  }

  /**
   * Clear all queued inputs.
   */
  clear() {
    this.queue = [];
    this.retryQueue = [];
  }

  /**
   * Get queue size.
   * @returns {number} Number of queued inputs
   */
  size() {
    return this.queue.length;
  }
}

window.InputQueue = InputQueue;

/**
 * SlotManager - Player slot assignment
 *
 * Manages:
 * - Player slot assignment (0-3 for standard, 0-7 for complex)
 * - Exclusive slot mode (one player per slot)
 * - Co-op mode (multiple players → same slot)
 * - Spectator "pass controller" requests
 * - Slot reservation system
 */

class SlotManager {
  /**
   * @param {Object} config - Configuration
   * @param {boolean} config.exclusiveSlots - True for exclusive slots (default: true)
   * @param {number} config.maxSlots - Maximum number of slots (default: 4)
   * @param {Function} config.onSlotChanged - Callback when slot assignments change
   */
  constructor(config = {}) {
    this.config = config;
    this.exclusiveSlots = config.exclusiveSlots !== false; // Default: true
    this.maxSlots = config.maxSlots || 4;
    this.onSlotChanged = config.onSlotChanged; // Callback for slot changes

    // Slot assignments: slotIndex -> playerId[]
    this.slots = new Map();

    // Player slot mappings: playerId -> slotIndex
    this.playerSlots = new Map();

    // Pending pass controller requests: requestId -> {fromPlayerId, toPlayerId, slotIndex}
    this.pendingRequests = new Map();
  }

  /**
   * Assign a slot to a player.
   * @param {string} playerId - Player ID
   * @param {number|null} preferredSlot - Preferred slot index (0-3), or null for auto-assign
   * @returns {number|null} Assigned slot index, or null if assignment failed
   */
  assignSlot(playerId, preferredSlot = null) {
    if (!playerId) {
      return null;
    }

    // Check if player already has a slot
    if (this.playerSlots.has(playerId)) {
      const existingSlot = this.playerSlots.get(playerId);
      // If requesting same slot, allow it
      if (preferredSlot === null || preferredSlot === existingSlot) {
        return existingSlot;
      }
      // Otherwise, release existing slot first
      this.releaseSlot(playerId);
    }

    let targetSlot = preferredSlot;

    // Auto-assign slot if not specified
    if (targetSlot === null) {
      targetSlot = this.findAvailableSlot();
      if (targetSlot === null) {
        return null; // No available slots
      }
    }

    // Validate slot index
    if (targetSlot < 0 || targetSlot >= this.maxSlots) {
      return null;
    }

    // Check if slot is available (exclusive mode) or if co-op is allowed
    if (this.exclusiveSlots) {
      const existingPlayers = this.slots.get(targetSlot) || [];
      if (existingPlayers.length > 0) {
        return null; // Slot occupied in exclusive mode
      }
    }

    // Assign slot
    if (!this.slots.has(targetSlot)) {
      this.slots.set(targetSlot, []);
    }
    this.slots.get(targetSlot).push(playerId);
    this.playerSlots.set(playerId, targetSlot);

    // Notify of slot change
    if (this.onSlotChanged) {
      this.onSlotChanged(playerId, targetSlot);
    }

    return targetSlot;
  }

  /**
   * Release a player's slot.
   * @param {string} playerId - Player ID
   */
  releaseSlot(playerId) {
    if (!this.playerSlots.has(playerId)) {
      return;
    }

    const slotIndex = this.playerSlots.get(playerId);
    const playersInSlot = this.slots.get(slotIndex) || [];

    // Remove player from slot
    const index = playersInSlot.indexOf(playerId);
    if (index !== -1) {
      playersInSlot.splice(index, 1);
    }

    if (playersInSlot.length === 0) {
      this.slots.delete(slotIndex);
    }

    this.playerSlots.delete(playerId);

    // Notify of slot release (null means released)
    if (this.onSlotChanged) {
      this.onSlotChanged(playerId, null);
    }
  }

  /**
   * Get slot index for a player.
   * @param {string} playerId - Player ID
   * @returns {number|null} Slot index, or null if player has no slot
   */
  getSlotForPlayer(playerId) {
    return this.playerSlots.get(playerId) ?? null;
  }

  /**
   * Get all players in a slot.
   * @param {number} slotIndex - Slot index (0-3)
   * @returns {Array<string>} Array of player IDs
   */
  getPlayersInSlot(slotIndex) {
    return this.slots.get(slotIndex) || [];
  }

  /**
   * Find an available slot (for auto-assignment).
   * @returns {number|null} Available slot index, or null if no slots available
   */
  findAvailableSlot() {
    for (let i = 0; i < this.maxSlots; i++) {
      const playersInSlot = this.slots.get(i) || [];
      if (playersInSlot.length === 0 || !this.exclusiveSlots) {
        return i;
      }
    }
    return null; // No available slots
  }

  /**
   * Request to pass controller (spectator → player).
   * @param {string} fromPlayerId - Spectator requesting controller
   * @param {string} toPlayerId - Player currently holding controller
   * @param {number} slotIndex - Slot index to swap
   * @returns {string} Request ID
   */
  requestPassController(fromPlayerId, toPlayerId, slotIndex) {
    const requestId = `pass-${Date.now()}-${Math.random()}`;
    this.pendingRequests.set(requestId, {
      fromPlayerId,
      toPlayerId,
      slotIndex,
      timestamp: Date.now(),
    });
    return requestId;
  }

  /**
   * Accept pass controller request (swap slots).
   * @param {string} requestId - Request ID
   * @returns {boolean} True if swap was successful
   */
  acceptPassController(requestId) {
    const request = this.pendingRequests.get(requestId);
    if (!request) {
      return false;
    }

    const { fromPlayerId, toPlayerId, slotIndex } = request;

    // Get current slot for the player holding the controller
    const currentSlot = this.getSlotForPlayer(toPlayerId);

    // Release current slot
    if (currentSlot !== null) {
      this.releaseSlot(toPlayerId);
    }

    // Assign slot to spectator
    this.assignSlot(fromPlayerId, slotIndex);

    // Optionally assign spectator's old slot (or any available slot) to player
    if (currentSlot !== null) {
      this.assignSlot(toPlayerId, currentSlot);
    }

    // Remove request
    this.pendingRequests.delete(requestId);

    return true;
  }

  /**
   * Reject pass controller request.
   * @param {string} requestId - Request ID
   */
  rejectPassController(requestId) {
    this.pendingRequests.delete(requestId);
  }

  /**
   * Get all pending pass controller requests.
   * @returns {Map<string, Object>} Map of request ID → request data
   */
  getPendingRequests() {
    return new Map(this.pendingRequests);
  }

  /**
   * Clear all slot assignments.
   */
  clear() {
    this.slots.clear();
    this.playerSlots.clear();
    this.pendingRequests.clear();
  }
}

window.SlotManager = SlotManager;

/**
 * InputSync - Frame-based input synchronization
 *
 * Handles:
 * - Frame-based input synchronization
 * - Input ordering (ordered vs unordered modes)
 * - Retry logic for lost inputs
 * - Slot assignment (exclusive vs co-op mode)
 * - Rollback netcode support (for Sync/Rollback mode)
 */

// Dependencies are expected in global scope after concatenation:
// InputQueue, SlotManager, SimpleController

class InputSync {
  /**
   * @param {IEmulator} emulatorAdapter - Emulator adapter
   * @param {Object} config - Configuration
   * @param {Object} sessionState - Session state manager
   * @param {Function} sendInputCallback - Callback to send input over network (frame, inputData)
   * @param {Function} onSlotChanged - Callback when slot assignments change (playerId, slot)
   */
  constructor(emulatorAdapter, config, sessionState, sendInputCallback, onSlotChanged) {
    console.log('[InputSync] Constructor called with:', {
      hasEmulatorAdapter: !!emulatorAdapter,
      config: config,
      hasSessionState: !!sessionState,
      hasSendInputCallback: !!sendInputCallback,
      hasOnSlotChanged: !!onSlotChanged
    });

    this.emulator = emulatorAdapter;
    this.config = config || {};
    this.sessionState = sessionState;
    this.sendInputCallback = sendInputCallback;

    // Input queue and slot management
    this.inputQueue = new InputQueue(config);

    // Create combined slot change callback
    const combinedOnSlotChanged = (playerId, slot) => {
      // Notify controller of slot change
      if (this.controller && typeof this.controller.handleSlotChange === 'function') {
        this.controller.handleSlotChange(playerId, slot);
      }
      // Call main slot change callback
      if (onSlotChanged) {
        onSlotChanged(playerId, slot);
      }
    };

    this.slotManager = new SlotManager({
      ...config,
      onSlotChanged: combinedOnSlotChanged
    });

    // Controller framework (simple for EmulatorJS)
    const framework = emulatorAdapter.getInputFramework();
    if (framework === "simple") {
      this.controller = new SimpleController(emulatorAdapter, config);
    } else {
      // Complex controller framework (for future native emulators)
      throw new Error("Complex controller framework not yet implemented");
    }

    // Set InputPayload class if available (will be set by loader)
    if (typeof InputPayload !== 'undefined') {
      this.setInputPayloadClass(InputPayload);
    }

    // Frame delay is now handled by the controller
    this.frameDelay = this.controller.frameDelay;


    // Input serialization/deserialization
    this.InputPayload = null; // Will be set when available
  }

  /**
   * Get current frame number.
   * @returns {number}
   */
  getCurrentFrame() {
    return this.controller.getCurrentFrame();
  }

  /**
   * Set current frame number.
   * @param {number} frame - Frame number
   */
  setCurrentFrame(frame) {
    this.controller.setCurrentFrame(frame);
  }

  /**
   * Initialize frame tracking (called when game starts).
   * @param {number} initFrame - Initial frame number from emulator
   */
  initializeFrames(initFrame) {
    this.controller.initializeFrames(initFrame);
  }

  /**
   * Update current frame from emulator (called each frame).
   * @param {number} emulatorFrame - Current frame from emulator
   */
  updateCurrentFrame(emulatorFrame) {
    this.currentFrame = parseInt(emulatorFrame, 10) - (this.initFrame || 0);
  }

  /**
   * Send input (from local player).
   * @param {number} playerIndex - Player index (0-3)
   * @param {number} inputIndex - Input index (0-29 for simple controllers)
   * @param {number} value - Input value (0/1 for buttons, -32767 to 32767 for analog)
   * @returns {boolean} True if input was sent/queued successfully
   */
  sendInput(playerIndex, inputIndex, value) {
    const isHost = this.sessionState?.isHostRole() || false;

    console.log("[InputSync] sendInput called:", {
      playerIndex,
      inputIndex,
      value,
      isHost
    });

    if (isHost) {
      // Host: Queue local input for processing
      return this.controller.queueLocalInput(playerIndex, inputIndex, value);
    } else {
      // Client: Send input to network
      return this.controller.sendInput(playerIndex, inputIndex, value, this.sendInputCallback, this);
    }
  }

  /**
   * Set the InputPayload class for serialization
   * @param {Function} InputPayloadClass - The InputPayload constructor
   */
  setInputPayloadClass(InputPayloadClass) {
    this.InputPayload = InputPayloadClass;
  }

  /**
   * Serialize input data for network transmission
   * @param {number} playerIndex
   * @param {number} inputIndex
   * @param {number} value
   * @returns {string} Serialized input data
   */
  serializeInput(playerIndex, inputIndex, value) {
    if (!this.InputPayload) {
      console.warn("[InputSync] InputPayload class not set, cannot serialize");
      return null;
    }

    const targetFrame = this.controller.getCurrentFrame() + this.frameDelay;
    const payload = new this.InputPayload(targetFrame, 0, playerIndex, inputIndex, value);
    return payload.serialize();
  }

  /**
   * Deserialize input data from network
   * @param {string|Object} data - Serialized input data
   * @returns {Object|null} Deserialized input payload
   */
  deserializeInput(data) {
    if (!this.InputPayload) {
      console.warn("[InputSync] InputPayload class not set, cannot deserialize");
      return null;
    }

    return this.InputPayload.deserialize(data);
  }

  /**
   * Handle remote input data (deserialize if needed and apply)
   * @param {string|Object|InputPayload} inputData - Serialized input data from network or InputPayload object
   * @param {string} fromSocketId - Source socket ID
   * @returns {boolean}
   */
  handleRemoteInput(inputData, fromSocketId = null) {
    let payload;

    // Check if inputData is already an InputPayload object
    if (inputData && typeof inputData.getFrame === 'function' && inputData.t === 'i') {
      // Already deserialized InputPayload object
      payload = inputData;
      console.log("[InputSync] Received pre-deserialized InputPayload:", payload);
    } else {
      // Need to deserialize
      payload = this.deserializeInput(inputData);
      if (!payload) {
        console.warn("[InputSync] Failed to deserialize remote input:", inputData);
        return false;
      }
    }

    console.log("[InputSync] Processing remote input:",
      `frame:${payload.getFrame()}, player:${payload.p}, input:${payload.k}, value:${payload.v}`);

    return this.controller.handleRemoteInput(payload, fromSocketId);
  }

  /**
   * Create a callback function for sending inputs over the network
   * This replaces the NetplayEngine's sendInputCallback logic
   * @param {Object} dataChannelManager - Reference to DataChannelManager
   * @param {Object} configManager - Reference to ConfigManager
   * @param {Object} emulator - Reference to emulator for slot info
   * @param {Object} socketTransport - Reference to SocketTransport for fallback
   * @param {Function} getPlayerSlot - Function to get current player's slot from playerTable
   * @returns {Function} Callback function for sending inputs
   */
  createSendInputCallback(dataChannelManager, configManager, emulator, socketTransport, getPlayerSlot) {
    return (frame, inputData) => {
      console.log("[InputSync] Send callback called:", { frame, inputData });

      if (!dataChannelManager) {
        console.warn("[InputSync] No DataChannelManager available");
        return;
      }

      // Use centralized slot getter if provided, otherwise fallback to old method
      const slot = getPlayerSlot ? getPlayerSlot() : (emulator?.netplay?.localSlot || 0);
      let allSent = true;

      if (Array.isArray(inputData)) {
        // Multiple inputs to send
        inputData.forEach((data) => {
          if (data.connected_input && data.connected_input.length === 3) {
            let [playerIndex, inputIndex, value] = data.connected_input;
            // Apply slot enforcement for network transmission
            playerIndex = this.controller.getEffectivePlayerIndex(playerIndex);
            const inputPayload = {
              frame: data.frame || frame || 0,
              slot: slot,
              playerIndex: playerIndex,
              inputIndex: inputIndex,
              value: value
            };
            const sent = dataChannelManager.sendInput(inputPayload);
            if (!sent) allSent = false;
          }
        });
      } else if (inputData.connected_input && inputData.connected_input.length === 3) {
        // Single input
        let [playerIndex, inputIndex, value] = inputData.connected_input;
        // Apply slot enforcement for network transmission
        playerIndex = this.controller.getEffectivePlayerIndex(playerIndex);
        const inputPayload = {
          frame: frame || inputData.frame || 0,
          slot: slot,
          playerIndex: playerIndex,
          inputIndex: inputIndex,
          value: value
        };
        console.log("[InputSync] Calling dataChannelManager.sendInput with:", inputPayload);
        const sent = dataChannelManager.sendInput(inputPayload);
        if (!sent) allSent = false;
      }

      // Handle P2P mode buffering
      if (dataChannelManager.mode === "unorderedP2P" || dataChannelManager.mode === "orderedP2P") {
        // In P2P modes, inputs are buffered if channels aren't ready
        // No fallback to Socket.IO for P2P modes
        return;
      }

      // For relay modes, fall back to Socket.IO if DataChannelManager failed
      if (!allSent && socketTransport && socketTransport.isConnected()) {
        console.log("[InputSync] Falling back to Socket.IO for input transmission");
        // Fallback to Socket.IO "sync-control" message
        if (Array.isArray(inputData)) {
          socketTransport.sendDataMessage({
            "sync-control": inputData,
          });
        } else {
          socketTransport.sendDataMessage({
            "sync-control": [inputData],
          });
        }
      }
    };
  }

  /**
   * Receive input from network (called when input arrives over network).
   * @param {number} frame - Target frame number
   * @param {Array<number>} connectedInput - [playerIndex, inputIndex, value]
   * @param {string} fromPlayerId - Source player ID (for logging)
   * @returns {boolean} True if input was queued successfully
   */
  receiveInput(frame, connectedInput, fromPlayerId = null) {
    // For backward compatibility, convert old format to new format
    // Create a mock InputPayload for the controller
    const mockPayload = {
      getFrame: () => frame,
      getConnectedInput: () => connectedInput
    };

    return this.controller.handleRemoteInput(mockPayload, fromPlayerId);
  }

  /**
   * Process inputs for current frame (called each frame on host).
   * Applies all inputs queued for the current frame and sends them to clients.
   * @returns {Array} Array of input data to send to clients
   */
  processFrameInputs() {
    const isHost = this.sessionState?.isHostRole() || false;

    if (!isHost) {
      return [];
    }

    // Delegate to controller
    const processedInputs = this.controller.processFrameInputs();

    // Send processed inputs to clients (for sync-control messages)
    // Note: In data channel mode, individual inputs are sent in sendInput(), not batched here
    if (processedInputs.length > 0 && this.sendInputCallback) {
      console.log("[InputSync] Host sending processed inputs to clients:", processedInputs);
      this.sendInputCallback(this.controller.getCurrentFrame(), processedInputs);
    }

    return processedInputs;
  }

  /**
   * Serialize input for network transmission (controller-agnostic).
   * @param {number} playerIndex
   * @param {number} inputIndex
   * @param {number} value
   * @returns {Object} Serialized input data
   */
  serializeInput(playerIndex, inputIndex, value) {
    const targetFrame = this.currentFrame + this.frameDelay;
    return {
      frame: targetFrame,
      connected_input: [playerIndex, inputIndex, value]
    };
  }

  /**
   * Reset input sync state.
   */
  reset() {
    this.controller.initializeFrames(0);
    this.inputQueue.clear();
  }

  /**
   * Cleanup resources.
   */
  cleanup() {
    this.reset();
    this.inputQueue = null;
    this.slotManager = null;
    this.controller = null;
  }
}

// Expose as global for concatenated builds
window.InputSync = InputSync;

/**
 * FrameCounter - Frame counting logic for netplay
 * 
 * Manages frame counting and synchronization between emulator and netplay core.
 */

class FrameCounter {
  /**
   * @param {IEmulator} emulatorAdapter - Emulator adapter
   */
  constructor(emulatorAdapter) {
    this.emulator = emulatorAdapter;
    this.frameOffset = 0;
    this.frameDelay = 0;
  }

  /**
   * Get current frame (emulator frame + offset).
   * @returns {number}
   */
  getCurrentFrame() {
    const emulatorFrame = this.emulator.getCurrentFrame();
    return emulatorFrame + this.frameOffset;
  }

  /**
   * Set current frame in emulator (adjusting for offset).
   * @param {number} frame - Target frame number
   */
  setCurrentFrame(frame) {
    const targetEmulatorFrame = frame - this.frameOffset;
    this.emulator.setCurrentFrame(targetEmulatorFrame);
  }

  /**
   * Get frame offset.
   * @returns {number}
   */
  getFrameOffset() {
    return this.frameOffset;
  }

  /**
   * Set frame offset.
   * @param {number} offset - Frame offset
   */
  setFrameOffset(offset) {
    this.frameOffset = offset;
  }

  /**
   * Get frame delay.
   * @returns {number}
   */
  getFrameDelay() {
    return this.frameDelay;
  }

  /**
   * Set frame delay.
   * @param {number} delay - Frame delay
   */
  setFrameDelay(delay) {
    this.frameDelay = delay;
  }

  /**
   * Reset frame counter to initial state.
   */
  reset() {
    this.frameOffset = 0;
    this.frameDelay = 0;
  }
}

window.FrameCounter = FrameCounter;

/**
 * SessionState - Session state management
 *
 * Tracks:
 * - Current session state (connected, disconnected, joining, etc.)
 * - Player list with netplay usernames
 * - Host/client role tracking
 * - Game mode state
 * - Spectator management
 */

class SessionState {
  constructor() {
    // Session state
    this.state = "disconnected"; // disconnected, connecting, connected, joining, joined

    // Role
    this.isHost = false;
    this.isSpectator = false;

    // Players and spectators
    this.players = new Map(); // playerId -> { netplayUsername, playerIndex, ... }
    this.spectators = new Map(); // playerId -> { netplayUsername, ... }

    // Current room info
    this.roomName = null;
    this.roomPassword = null;
    this.gameMode = null;

    // Local player info
    this.localPlayerId = null;
    this.localNetplayUsername = null;
    this.localUserId = null;
  }

  /**
   * Set session state.
   * @param {string} state - New state
   */
  setState(state) {
    this.state = state;
  }

  /**
   * Get current session state.
   * @returns {string}
   */
  getState() {
    return this.state;
  }

  /**
   * Set host/client role.
   * @param {boolean} isHost - True if host
   */
  setHost(isHost) {
    this.isHost = isHost;
  }

  /**
   * Check if current user is host.
   * @returns {boolean}
   */
  isHostRole() {
    return this.isHost;
  }

  /**
   * Set spectator mode.
   * @param {boolean} isSpectator - True if spectator
   */
  setSpectator(isSpectator) {
    this.isSpectator = isSpectator;
  }

  /**
   * Check if current user is spectator.
   * @returns {boolean}
   */
  isSpectatorRole() {
    return this.isSpectator;
  }

  /**
   * Add a player to the session.
   * @param {string} playerId - Player ID (netplay username)
   * @param {Object} playerInfo - Player information
   */
  addPlayer(playerId, playerInfo) {
    this.players.set(playerId, playerInfo);
  }

  /**
   * Remove a player from the session.
   * @param {string} playerId - Player ID
   */
  removePlayer(playerId) {
    this.players.delete(playerId);
  }

  /**
   * Get all players.
   * @returns {Map<string, Object>} Player map
   */
  getPlayers() {
    return new Map(this.players);
  }

  /**
   * Get players as an object (for backward compatibility).
   * @returns {Object} Object mapping playerId -> playerInfo
   */
  getPlayersObject() {
    const obj = {};
    this.players.forEach((info, playerId) => {
      obj[playerId] = info;
    });
    return obj;
  }

  /**
   * Add a spectator to the session.
   * @param {string} spectatorId - Spectator ID
   * @param {Object} spectatorInfo - Spectator information
   */
  addSpectator(spectatorId, spectatorInfo) {
    this.spectators.set(spectatorId, spectatorInfo);
  }

  /**
   * Remove a spectator from the session.
   * @param {string} spectatorId - Spectator ID
   */
  removeSpectator(spectatorId) {
    this.spectators.delete(spectatorId);
  }

  /**
   * Get all spectators.
   * @returns {Map<string, Object>} Spectator map
   */
  getSpectators() {
    return new Map(this.spectators);
  }

  /**
   * Get the local player's current slot.
   * @returns {number|null} Local player's slot, or null if not found
   */
  getLocalPlayerSlot() {
    if (!this.localPlayerId) {
      return null;
    }

    const localPlayer = this.players.get(this.localPlayerId);
    return localPlayer && localPlayer.player_slot !== undefined ? localPlayer.player_slot : null;
  }

  /**
   * Set current room information.
   * @param {string} roomName - Room name
   * @param {string|null} roomPassword - Room password (if any)
   * @param {string|null} gameMode - Game mode ID
   */
  setRoom(roomName, roomPassword = null, gameMode = null) {
    this.roomName = roomName;
    this.roomPassword = roomPassword;
    this.gameMode = gameMode;
  }

  /**
   * Clear current room information.
   */
  clearRoom() {
    this.roomName = null;
    this.roomPassword = null;
    this.gameMode = null;
    this.players.clear();
    this.spectators.clear();
  }

  /**
   * Set local player information.
   * @param {string} playerId - Local player ID
   * @param {string} netplayUsername - Netplay username
   * @param {string} userId - RoMM user ID
   */
  setLocalPlayer(playerId, netplayUsername, userId) {
    this.localPlayerId = playerId; // playerID (NetplayID)
    this.localNetplayUsername = netplayUsername; // netplayUsername (Display purposes)
    this.localUserId = userId; // userId (RoMM user ID)
  }

  /**
   * Reset session state to initial state.
   */
  reset() {
    this.state = "disconnected";
    this.isHost = false;
    this.isSpectator = false;
    this.clearRoom();
    this.localPlayerId = null;
    this.localNetplayUsername = null;
    this.localUserId = null;
  }
}

window.SessionState = SessionState;

/**
 * ConfigManager - Configuration management for netplay
 * 
 * Handles:
 * - Netplay settings persistence (localStorage)
 * - Default value management
 * - Configuration validation
 */

class ConfigManager {
  /**
   * @param {IEmulator} emulatorAdapter - Emulator adapter
   * @param {Object} defaultConfig - Default configuration values
   */
  constructor(emulatorAdapter, defaultConfig = {}) {
    this.emulator = emulatorAdapter;
    this.defaults = {
      netplaySimulcastEnabled: false,
      netplayVP9SVCMode: null,
      netplayHostCodec: "auto",
      netplayClientSimulcastQuality: "medium",
      netplayRetryConnectionTimerSeconds: 5,
      netplayUnorderedRetries: 0,
      netplayInputMode: "orderedRelay",
      netplayIceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ],
      netplayPreferredSlot: 0,
      netplayChatEnabled: false, // Chat disabled by default
      ...defaultConfig,
    };
  }

  /**
   * Load configuration from localStorage/emulator settings.
   * @returns {Object} Configuration object
   */
  loadConfig() {
    // TODO: Implement settings loading in future phases
    return { ...this.defaults };
  }

  /**
   * Get a specific setting value.
   * @param {string} key - Setting key
   * @returns {*} Setting value or default
   */
  getSetting(key) {
    const config = this.loadConfig();
    return config[key] ?? this.defaults[key];
  }

  /**
   * Set a setting value (persists to localStorage).
   * @param {string} key - Setting key
   * @param {*} value - Setting value
   */
  setSetting(key, value) {
    // TODO: Implement settings persistence in future phases
    console.log(`[ConfigManager] Setting ${key} = ${value}`);
  }

  /**
   * Get all default values.
   * @returns {Object} Default configuration
   */
  getDefaults() {
    return { ...this.defaults };
  }

  /**
   * Validate configuration object.
   * @param {Object} config - Configuration to validate
   * @returns {{valid: boolean, errors: string[]}} Validation result
   */
  validateConfig(config) {
    const errors = [];
    
    // TODO: Add validation rules in future phases
    // Example: Validate netplayPreferredSlot is 0-3
    // Example: Validate retry timer is positive
    
    return {
      valid: errors.length === 0,
      errors,
    };
  }
}

window.ConfigManager = ConfigManager;

/**
 * GameModeManager - Game mode rules and validation
 *
 * Manages:
 * - Game mode definitions
 * - Mode-specific validation rules
 * - Enforces mode rules on room join (for players)
 * - Handles spectator mode prompts
 */

class GameModeManager {
  constructor() {
    this.modes = new Map();
    this._registerDefaultModes();
  }

  /**
   * Register default game modes.
   * @private
   */
  _registerDefaultModes() {
    // Live Stream - Host streams, players send inputs
    this.registerMode({
      modeId: "live-stream",
      name: "Live Stream",
      requiresEmulatorMatch: true, // Enforce emulator matching for players
      requiresROMMatch: false, // Not ROM matching (inputs must match emulator)
      allowsPassController: true, // Spectators can request controller
      hostStreamsOnly: true, // Only host streams video/audio
      maxPlayers: 4,
      supportsRollback: false,
      description: "Host streams video, players send inputs to host",
    });

    // Stream Party - All users stream video/audio
    this.registerMode({
      modeId: "stream-party",
      name: "Stream Party",
      requiresEmulatorMatch: false, // No enforcement for players
      requiresROMMatch: false, // No enforcement
      allowsPassController: true, // Spectators can request controller
      hostStreamsOnly: false, // All users stream
      maxPlayers: 4,
      supportsRollback: false,
      description: "All users stream video/audio, casual social mode",
    });

    // Sync/Rollback - Rollback netcode for action games
    this.registerMode({
      modeId: "sync-rollback",
      name: "Sync/Rollback",
      requiresEmulatorMatch: true, // Enforce emulator matching
      requiresROMMatch: true, // Enforce ROM matching (deterministic state sync)
      allowsPassController: false, // Competitive mode, no pass controller
      hostStreamsOnly: true, // Host streams
      maxPlayers: 4,
      supportsRollback: true, // Supports rollback netcode
      description: "Rollback netcode for competitive play, requires exact ROM match",
    });

    // Link Cable Room - Special for Game Boy emulation
    this.registerMode({
      modeId: "link-cable",
      name: "Link Cable Room",
      requiresEmulatorMatch: true, // Enforce emulator matching
      requiresROMMatch: true, // Enforce ROM matching for link cable compatibility
      allowsPassController: false, // No pass controller for link cable
      hostStreamsOnly: true, // Host streams
      maxPlayers: 2, // Link cable typically 2 players
      supportsRollback: false, // Link cable uses different sync mechanism
      description: "Optimized for Game Boy link cable emulation",
    });
  }

  /**
   * Register a game mode.
   * @param {Object} mode - Game mode definition
   */
  registerMode(mode) {
    // Validate mode structure
    if (!mode.modeId || !mode.name) {
      throw new Error("Game mode must have modeId and name");
    }

    this.modes.set(mode.modeId, {
      ...mode,
      // Ensure all fields have defaults
      requiresEmulatorMatch: mode.requiresEmulatorMatch ?? false,
      requiresROMMatch: mode.requiresROMMatch ?? false,
      allowsPassController: mode.allowsPassController ?? false,
      hostStreamsOnly: mode.hostStreamsOnly ?? true,
      maxPlayers: mode.maxPlayers ?? 4,
      supportsRollback: mode.supportsRollback ?? false,
    });
  }

  /**
   * Get a game mode by ID.
   * @param {string} modeId - Mode ID
   * @returns {Object|null} Mode definition or null
   */
  getMode(modeId) {
    return this.modes.get(modeId) ?? null;
  }

  /**
   * Get all registered modes.
   * @returns {Map<string, Object>} Mode map
   */
  getAllModes() {
    return new Map(this.modes);
  }

  /**
   * Get all mode IDs.
   * @returns {Array<string>} Array of mode IDs
   */
  getModeIds() {
    return Array.from(this.modes.keys());
  }

  /**
   * Validate player join requirements for a game mode.
   * @param {string} modeId - Game mode ID
   * @param {Object} localEmulator - Local emulator info {core, version}
   * @param {Object} localROM - Local ROM info {hash, size, name}
   * @param {Object} remoteEmulator - Remote emulator info {core, version}
   * @param {Object} remoteROM - Remote ROM info {hash, size, name}
   * @returns {{valid: boolean, reason?: string, canSpectate?: boolean}} Validation result
   */
  validateJoinRequirements(
    modeId,
    localEmulator,
    localROM,
    remoteEmulator,
    remoteROM
  ) {
    const mode = this.getMode(modeId);
    if (!mode) {
      return {
        valid: false,
        reason: `Unknown game mode: ${modeId}`,
        canSpectate: true, // Can spectate even if mode is unknown
      };
    }

    // Note: Spectators always allowed (can spectate regardless of validation)
    // This validation is only for players

    // Check emulator match requirement
    if (mode.requiresEmulatorMatch) {
      if (!localEmulator || !remoteEmulator) {
        return {
          valid: false,
          reason: "Emulator information missing",
          canSpectate: true,
        };
      }
      if (
        localEmulator.core !== remoteEmulator.core ||
        localEmulator.version !== remoteEmulator.version
      ) {
        return {
          valid: false,
          reason: `Emulator mismatch: local=${localEmulator.core}@${localEmulator.version}, remote=${remoteEmulator.core}@${remoteEmulator.version}`,
          canSpectate: true, // Can spectate even with emulator mismatch
        };
      }
    }

    // Check ROM match requirement
    if (mode.requiresROMMatch) {
      if (!localROM || !remoteROM) {
        return {
          valid: false,
          reason: "ROM information missing",
          canSpectate: true,
        };
      }
      if (
        localROM.hash !== remoteROM.hash ||
        localROM.size !== remoteROM.size
      ) {
        return {
          valid: false,
          reason: `ROM mismatch: local hash=${localROM.hash?.substring(0, 8)}..., remote hash=${remoteROM.hash?.substring(0, 8)}...`,
          canSpectate: true, // Can spectate even with ROM mismatch
        };
      }
    }

    // All requirements met
    return {
      valid: true,
      canSpectate: true, // Can always spectate
    };
  }

  /**
   * Check if mode supports spectators (all modes support spectators by default).
   * @param {string} modeId - Mode ID
   * @returns {boolean} Always true (all modes support spectators)
   */
  supportsSpectators(modeId) {
    // All game modes support spectators
    return true;
  }

  /**
   * Check if mode allows pass controller requests.
   * @param {string} modeId - Mode ID
   * @returns {boolean}
   */
  allowsPassController(modeId) {
    const mode = this.getMode(modeId);
    return mode ? mode.allowsPassController : false;
  }
}

window.GameModeManager = GameModeManager;

/**
 * UsernameManager - Netplay username enforcement
 * 
 * Manages:
 * - Netplay username validation and enforcement
 * - Binds netplayUsername to userId from RoMM token
 * - Prevents duplicate room joins for same account
 * - Enforces unique netplay username in lobbies
 * 
 * TODO: Implement in Phase 4
 */

class UsernameManager {
  constructor() {
    this.usernameToUserId = new Map(); // netplayUsername -> userId
    this.userIdToUsername = new Map(); // userId -> netplayUsername
  }

  /**
   * Bind netplay username to user ID.
   * @param {string} netplayUsername - Netplay username (from RoMM)
   * @param {string} userId - User ID (sub from JWT)
   * @returns {boolean} True if binding successful
   */
  bindUsername(netplayUsername, userId) {
    // Prevent duplicate usernames from different users
    const existingUserId = this.usernameToUserId.get(netplayUsername);
    if (existingUserId && existingUserId !== userId) {
      return false; // Username already taken by different user
    }

    this.usernameToUserId.set(netplayUsername, userId);
    this.userIdToUsername.set(userId, netplayUsername);
    return true;
  }

  /**
   * Get user ID for a netplay username.
   * @param {string} netplayUsername - Netplay username
   * @returns {string|null} User ID or null
   */
  getUserIdForUsername(netplayUsername) {
    return this.usernameToUserId.get(netplayUsername) ?? null;
  }

  /**
   * Get netplay username for a user ID.
   * @param {string} userId - User ID
   * @returns {string|null} Netplay username or null
   */
  getUsernameForUserId(userId) {
    return this.userIdToUsername.get(userId) ?? null;
  }

  /**
   * Check if username is available (not in use by another user).
   * @param {string} netplayUsername - Netplay username to check
   * @param {string} userId - Current user ID (excluded from check)
   * @returns {boolean} True if available
   */
  isUsernameAvailable(netplayUsername, userId) {
    const existingUserId = this.usernameToUserId.get(netplayUsername);
    return !existingUserId || existingUserId === userId;
  }

  /**
   * Remove username binding (on disconnect).
   * @param {string} userId - User ID
   */
  unbindUsername(userId) {
    const username = this.userIdToUsername.get(userId);
    if (username) {
      this.usernameToUserId.delete(username);
      this.userIdToUsername.delete(userId);
    }
  }
}

window.UsernameManager = UsernameManager;

/**
 * MetadataValidator - ROM/emulator hash checking
 *
 * Validates:
 * - Emulator core/version matching
 * - ROM hash matching (based on game mode)
 * - ROM size validation
 * - Game mode-specific requirements
 */

class MetadataValidator {
  /**
   * @param {GameModeManager} gameModeManager - Game mode manager instance
   */
  constructor(gameModeManager) {
    this.gameModeManager = gameModeManager;
  }

  /**
   * Validate emulator match.
   * @param {Object} localInfo - Local emulator info {core: string, version: string}
   * @param {Object} remoteInfo - Remote emulator info {core: string, version: string}
   * @returns {boolean} True if match
   */
  validateEmulatorMatch(localInfo, remoteInfo) {
    if (!localInfo || !remoteInfo) {
      return false;
    }

    return (
      localInfo.core === remoteInfo.core &&
      localInfo.version === remoteInfo.version
    );
  }

  /**
   * Validate ROM match.
   * @param {Object} localROM - Local ROM info {hash: string, size: number, name: string}
   * @param {Object} remoteROM - Remote ROM info {hash: string, size: number, name: string}
   * @returns {boolean} True if match
   */
  validateROMMatch(localROM, remoteROM) {
    if (!localROM || !remoteROM) {
      return false;
    }

    // Check hash (primary validation)
    if (localROM.hash && remoteROM.hash) {
      if (localROM.hash !== remoteROM.hash) {
        return false;
      }
    }

    // Check size (secondary validation)
    if (localROM.size && remoteROM.size) {
      if (localROM.size !== remoteROM.size) {
        return false;
      }
    }

    // If both have hash and they match, consider it valid
    if (localROM.hash && remoteROM.hash) {
      return localROM.hash === remoteROM.hash;
    }

    // If no hash but sizes match, consider it valid (fallback)
    if (localROM.size && remoteROM.size) {
      return localROM.size === remoteROM.size;
    }

    return false;
  }

  /**
   * Validate player join requirements based on game mode.
   * @param {string} gameMode - Game mode ID
   * @param {Object} localEmulator - Local emulator info {core, version}
   * @param {Object} localROM - Local ROM info {hash, size, name}
   * @param {Object} remoteEmulator - Remote emulator info {core, version}
   * @param {Object} remoteROM - Remote ROM info {hash, size, name}
   * @returns {{valid: boolean, reason?: string, canSpectate?: boolean}} Validation result
   */
  validateJoinRequirements(
    gameMode,
    localEmulator,
    localROM,
    remoteEmulator,
    remoteROM
  ) {
    if (!this.gameModeManager) {
      return {
        valid: false,
        reason: "Game mode manager not initialized",
        canSpectate: true,
      };
    }

    // Delegate to game mode manager for mode-specific validation
    return this.gameModeManager.validateJoinRequirements(
      gameMode,
      localEmulator,
      localROM,
      remoteEmulator,
      remoteROM
    );
  }

  /**
   * Validate emulator info structure.
   * @param {Object} emulatorInfo - Emulator info to validate
   * @returns {boolean} True if valid structure
   */
  validateEmulatorInfo(emulatorInfo) {
    return (
      emulatorInfo &&
      typeof emulatorInfo.core === "string" &&
      typeof emulatorInfo.version === "string" &&
      emulatorInfo.core.length > 0 &&
      emulatorInfo.version.length > 0
    );
  }

  /**
   * Validate ROM info structure.
   * @param {Object} romInfo - ROM info to validate
   * @returns {boolean} True if valid structure
   */
  validateROMInfo(romInfo) {
    if (!romInfo) {
      return false;
    }

    // ROM info should have at least hash or size
    const hasHash = typeof romInfo.hash === "string" && romInfo.hash.length > 0;
    const hasSize = typeof romInfo.size === "number" && romInfo.size > 0;

    return hasHash || hasSize;
  }
}

window.MetadataValidator = MetadataValidator;

/**
 * SpectatorManager - Spectator management and chat
 *
 * Manages:
 * - Spectator connections and permissions
 * - Spectator video/audio stream delivery
 * - Chat integration for spectators (room-level chat)
 * - Spectator mode toggle (host-controlled)
 * - Spectator prompt when player join fails validation
 */

class SpectatorManager {
  /**
   * @param {Object} config - Configuration
   * @param {Object} socketTransport - SocketTransport instance (optional, for chat)
   */
  constructor(config = {}, socketTransport = null) {
    this.config = config;
    this.socket = socketTransport;
    this.spectators = new Map(); // spectatorId -> spectatorInfo
    this.allowsSpectators = true; // Default enabled, host can toggle
    this.chatMessages = []; // Chat history (room-level)
    this.maxChatHistory = config.maxChatHistory || 100; // Limit chat history size
  }

  /**
   * Set spectator mode enabled/disabled (host-controlled).
   * @param {boolean} enabled - True to allow spectators
   */
  setAllowsSpectators(enabled) {
    this.allowsSpectators = enabled;

    // If disabling, notify spectators (via socket if available)
    if (!enabled && this.socket && this.socket.isConnected()) {
      // TODO: Emit socket event to notify spectators
      // this.socket.emit("spectators-disabled");
    }
  }

  /**
   * Check if spectators are allowed.
   * @returns {boolean}
   */
  allowsSpectatorsMode() {
    return this.allowsSpectators;
  }

  /**
   * Add a spectator.
   * @param {string} spectatorId - Spectator ID
   * @param {Object} spectatorInfo - Spectator information
   * @returns {boolean} True if spectator was added (false if spectators disabled)
   */
  addSpectator(spectatorId, spectatorInfo) {
    if (!this.allowsSpectators) {
      return false;
    }

    this.spectators.set(spectatorId, {
      ...spectatorInfo,
      spectatorId: spectatorId,
      joinedAt: Date.now(),
    });

    return true;
  }

  /**
   * Remove a spectator.
   * @param {string} spectatorId - Spectator ID
   */
  removeSpectator(spectatorId) {
    this.spectators.delete(spectatorId);
  }

  /**
   * Get all spectators.
   * @returns {Map<string, Object>} Spectator map
   */
  getSpectators() {
    return new Map(this.spectators);
  }

  /**
   * Get spectator count.
   * @returns {number}
   */
  getSpectatorCount() {
    return this.spectators.size;
  }

  /**
   * Check if user is a spectator.
   * @param {string} userId - User ID
   * @returns {boolean}
   */
  isSpectator(userId) {
    return this.spectators.has(userId);
  }

  /**
   * Send chat message (players and spectators).
   * @param {string} senderId - Sender player/spectator ID
   * @param {string} message - Chat message
   * @param {string} senderName - Sender display name (optional)
   */
  sendChatMessage(senderId, message, senderName = null) {
    if (!message || typeof message !== "string" || message.trim().length === 0) {
      return;
    }

    const chatEntry = {
      senderId,
      senderName: senderName || senderId,
      message: message.trim(),
      timestamp: Date.now(),
    };

    this.chatMessages.push(chatEntry);

    // Limit chat history size
    if (this.chatMessages.length > this.maxChatHistory) {
      this.chatMessages.shift();
    }

    // Send chat message via socket if available
    if (this.socket && this.socket.isConnected()) {
      this.socket.emit("chat-message", chatEntry);
    }
  }

  /**
   * Get chat history.
   * @param {number} limit - Maximum number of messages to return (optional)
   * @returns {Array} Chat messages
   */
  getChatHistory(limit = null) {
    if (limit && limit > 0) {
      return this.chatMessages.slice(-limit);
    }
    return [...this.chatMessages];
  }

  /**
   * Clear chat history.
   */
  clearChat() {
    this.chatMessages = [];
  }

  /**
   * Setup socket event listeners for chat.
   */
  setupChatListeners() {
    if (!this.socket) {
      return;
    }

    // Listen for incoming chat messages
    this.socket.on("chat-message", (chatEntry) => {
      // Add to local chat history
      this.chatMessages.push({
        ...chatEntry,
        timestamp: chatEntry.timestamp || Date.now(),
      });

      // Limit chat history size
      if (this.chatMessages.length > this.maxChatHistory) {
        this.chatMessages.shift();
      }
    });
  }

  /**
   * Remove socket event listeners for chat.
   */
  removeChatListeners() {
    if (!this.socket) {
      return;
    }

    this.socket.off("chat-message");
  }

  /**
   * Clear all spectators and chat.
   */
  clear() {
    this.spectators.clear();
    this.clearChat();
  }
}

window.SpectatorManager = SpectatorManager;

/**
 * PlayerManager - Player list and metadata
 *
 * Manages:
 * - Player list management
 * - Player metadata
 * - Player join/leave events
 * - Player slot assignments
 */

class PlayerManager {
  /**
   * @param {SlotManager} slotManager - Slot manager instance
   */
  constructor(slotManager) {
    this.slotManager = slotManager;
    this.players = new Map(); // playerId -> playerInfo
  }

  /**
   * Add a player to the session.
   * @param {string} playerId - Player ID
   * @param {Object} playerInfo - Player information
   * @returns {boolean} True if player was added
   */
  addPlayer(playerId, playerInfo) {
    if (!playerId || !playerInfo) {
      return false;
    }

    this.players.set(playerId, {
      ...playerInfo,
      playerId: playerId,
      joinedAt: Date.now(),
    });

    // Auto-assign slot if not specified
    if (this.slotManager && playerInfo.player_slot !== undefined) {
      this.slotManager.assignSlot(playerId, playerInfo.player_slot);
    }

    return true;
  }

  /**
   * Remove a player from the session.
   * @param {string} playerId - Player ID
   */
  removePlayer(playerId) {
    if (this.slotManager) {
      this.slotManager.releaseSlot(playerId);
    }
    this.players.delete(playerId);
  }

  /**
   * Get player information.
   * @param {string} playerId - Player ID
   * @returns {Object|null} Player info or null
   */
  getPlayer(playerId) {
    return this.players.get(playerId) || null;
  }

  /**
   * Get all players.
   * @returns {Map<string, Object>} Map of playerId -> playerInfo
   */
  getAllPlayers() {
    return new Map(this.players);
  }

  /**
   * Get players as an object (for backward compatibility).
   * @returns {Object} Object mapping playerId -> playerInfo
   */
  getPlayersObject() {
    const obj = {};
    this.players.forEach((info, playerId) => {
      obj[playerId] = info;
    });
    return obj;
  }

  /**
   * Update player information.
   * @param {string} playerId - Player ID
   * @param {Object} updates - Partial player info to update
   */
  updatePlayer(playerId, updates) {
    const player = this.players.get(playerId);
    if (player) {
      this.players.set(playerId, {
        ...player,
        ...updates,
      });

      // Update slot if changed
      if (updates.player_slot !== undefined && this.slotManager) {
        this.slotManager.releaseSlot(playerId);
        this.slotManager.assignSlot(playerId, updates.player_slot);
      }
    }
  }

  /**
   * Get player count.
   * @returns {number}
   */
  getPlayerCount() {
    return this.players.size;
  }

  /**
   * Check if player exists.
   * @param {string} playerId - Player ID
   * @returns {boolean}
   */
  hasPlayer(playerId) {
    return this.players.has(playerId);
  }

  /**
   * Clear all players.
   */
  clear() {
    if (this.slotManager) {
      this.players.forEach((info, playerId) => {
        this.slotManager.releaseSlot(playerId);
      });
    }
    this.players.clear();
  }
}

window.PlayerManager = PlayerManager;

/**
 * RoomManager - Room operations (join/create/leave)
 *
 * Handles:
 * - Room operations via Socket.IO
 * - Room discovery (list rooms)
 * - Room creation and management
 * - Player join/leave handling
 */

class RoomManager {
  /**
   * @param {Object} socketTransport - SocketTransport instance
   * @param {Object} config - Configuration
   * @param {Object} sessionState - SessionState instance
   */
  constructor(socketTransport, config = {}, sessionState) {
    this.socket = socketTransport;
    this.config = config;
    this.sessionState = sessionState;
  }

  /**
   * List available rooms.
   * @returns {Promise<Array>} Array of room objects {id, name, current, max, hasPassword}
   */
  async listRooms() {
    if (!this.socket.isConnected()) {
      throw new Error("Socket not connected");
    }

    return new Promise((resolve, reject) => {
      this.socket.emit("get-open-rooms", {}, (error, rooms) => {
        if (error) {
          reject(new Error(error));
          return;
        }
        resolve(rooms || []);
      });
    });
  }

  /**
   * Create a new room (host).
   * @param {string} roomName - Room name
   * @param {number} maxPlayers - Maximum players
   * @param {string|null} password - Room password (optional)
   * @param {Object} playerInfo - Player information (netplayUsername, userId, etc.)
   * @returns {Promise<string>} Room ID (sessionid)
   */
  async createRoom(roomName, maxPlayers, password = null, playerInfo = {}) {
    if (!this.socket.isConnected()) {
      throw new Error("Socket not connected");
    }

    // Generate session ID
    const sessionid = this.generateSessionId();

    // Prepare player extra data
    const extra = {
      domain: window.location.host,
      game_id: this.config.gameId || null,
      room_name: roomName,
      player_name: playerInfo.netplayUsername || playerInfo.name || "Player",
      player_slot: playerInfo.preferredSlot || 0,
      userid: playerInfo.userId || this.generatePlayerId(),
      sessionid: sessionid,
      input_mode:
        this.config.inputMode ||
        (typeof window.EJS_NETPLAY_INPUT_MODE === "string"
          ? window.EJS_NETPLAY_INPUT_MODE
          : null) ||
        "unorderedRelay",
      // Include netplay_mode and room_phase if provided
      netplay_mode:
        playerInfo.netplay_mode !== undefined ? playerInfo.netplay_mode : 0,
      room_phase:
        playerInfo.room_phase !== undefined ? playerInfo.room_phase : "running",
      sync_config: playerInfo.sync_config || null,
      spectator_mode:
        playerInfo.spectator_mode !== undefined ? playerInfo.spectator_mode : 1,
      // Include ROM and emulator metadata for room creation
      romHash: playerInfo.romHash || null,
      rom_hash: playerInfo.romHash || null, // Backward compatibility
      rom_name: playerInfo.romName || playerInfo.romFilename || null,
      romFilename: playerInfo.romFilename || null,
      system: playerInfo.system || null,
      platform: playerInfo.platform || null,
      coreId: playerInfo.coreId || playerInfo.system || null,
      core_type: playerInfo.coreId || playerInfo.system || null, // Backward compatibility
      coreVersion: playerInfo.coreVersion || null,
      systemType: playerInfo.systemType || playerInfo.system || null,
      metadata: playerInfo.metadata || null,
    };

    // Update session state
    this.sessionState.setHost(true);
    this.sessionState.setLocalPlayer(
      extra.userid,
      extra.player_name,
      extra.userid,
    );

    return new Promise((resolve, reject) => {
      this.socket.emit(
        "open-room",
        {
          extra: extra,
          maxPlayers: maxPlayers,
          password: password,
        },
        (error, result) => {
          if (error) {
            reject(new Error(error));
            return;
          }

          // Room created successfully
          this.sessionState.setRoom(
            roomName,
            password,
            this.config.gameMode || null,
          );
          resolve(sessionid);
        },
      );
    });
  }

  /**
   * Join an existing room (client).
   * @param {string} sessionId - Room session ID
   * @param {string} roomName - Room name
   * @param {number} maxPlayers - Maximum players
   * @param {string|null} password - Room password (if required)
   * @param {Object} playerInfo - Player information
   * @returns {Promise<void>}
   */
  async joinRoom(
    sessionId,
    roomName,
    maxPlayers,
    password = null,
    playerInfo = {},
  ) {
    if (!this.socket.isConnected()) {
      throw new Error("Socket not connected");
    }

    // Prepare player extra data
    const playerId = playerInfo.userId || this.generatePlayerId();
    const preferredSlot =
      playerInfo.preferredSlot ||
      this.config.preferredSlot ||
      (typeof window.EJS_NETPLAY_PREFERRED_SLOT === "number"
        ? window.EJS_NETPLAY_PREFERRED_SLOT
        : null) ||
      0;

    const extra = {
      domain: window.location.host,
      game_id: this.config.gameId || null,
      room_name: roomName,
      player_name: playerInfo.netplayUsername || playerInfo.name || "Player",
      player_slot: preferredSlot,
      userid: playerId,
      sessionid: sessionId,
      netplay_mode: this.config.netplayMode || 0,
      input_mode: this.config.inputMode || "unorderedRelay",

      // ✅ ADD ROM METADATA FOR COMPATIBILITY VALIDATION
      rom_hash: playerInfo.romHash || null,
      rom_name: playerInfo.romName || playerInfo.romFilename || null,
      core_type: playerInfo.core || playerInfo.system || null,
      system: playerInfo.system || null,
      platform: playerInfo.platform || null,
      coreId: playerInfo.coreId || playerInfo.core || null,
      coreVersion: playerInfo.coreVersion || null,
      romHash: playerInfo.romHash || null,
      systemType: playerInfo.systemType || playerInfo.system || null,
    };

    // Update session state (host status will be determined from server response)
    // Don't set host status yet - wait for server response
    this.sessionState.setLocalPlayer(playerId, extra.player_name, playerId);
    this.sessionState.setRoom(roomName, password, this.config.gameMode || null);

    console.log(
      `[RoomManager] joinRoom called: roomName=${roomName}, playerId=${playerId}`,
    );
    console.log(`[RoomManager] Socket connected: ${this.socket.isConnected()}`);

    return new Promise((resolve, reject) => {
      // Ensure socket is connected
      if (!this.socket.isConnected()) {
        console.warn(
          "[RoomManager] Socket not connected, waiting for connection...",
        );
        // Wait for connection (if callback is provided)
        if (this.config.callbacks?.onSocketReady) {
          this.config.callbacks.onSocketReady(() => {
            console.log("[RoomManager] Socket ready, proceeding with join");
            this.emitJoinRoom(extra, password, resolve, reject);
          });
          return;
        }
        console.error(
          "[RoomManager] Socket not connected and no onSocketReady callback",
        );
        reject(new Error("Socket not connected"));
        return;
      }

      console.log("[RoomManager] Socket connected, proceeding with join");
      this.emitJoinRoom(extra, password, resolve, reject);
    });
  }

  /**
   * Emit join-room event.
   * @private
   * @param {Object} extra - Player extra data
   * @param {string|null} password - Room password
   * @param {Function} resolve - Promise resolve
   * @param {Function} reject - Promise reject
   */
  emitJoinRoom(extra, password, resolve, reject) {
    console.log("[RoomManager] Emitting join-room event:", {
      roomName: extra.room_name,
      playerName: extra.player_name,
      playerId: extra.userid,
    });

    this.socket.emit(
      "join-room",
      {
        extra: extra,
        password: password,
      },
      (error, response) => {
        console.log("[RoomManager] join-room callback received:", {
          error,
          responseKeys: response ? Object.keys(response) : null,
        });
        if (error) {
          // Handle auth errors specially
          if (
            typeof error === "string" &&
            (error.includes("unauthorized") ||
              error.includes("token") ||
              error.includes("auth"))
          ) {
            if (window.handleSfuAuthError) {
              window.handleSfuAuthError();
              // Don't resolve/reject - auth handler will manage retry
              return;
            }
          }

          // For structured errors (like compatibility issues), preserve the object
          if (typeof error === "object" && error.error) {
            const structuredError = new Error(error.message || error.error);
            structuredError.details = error; // Preserve the full error object
            reject(structuredError);
          } else {
            // For string errors, convert to Error object
            reject(
              new Error(
                typeof error === "string" ? error : JSON.stringify(error),
              ),
            );
          }
          return;
        }

        // Update players list
        if (this.sessionState && response && response.users) {
          Object.entries(response.users || {}).forEach(
            ([playerId, playerData]) => {
              this.sessionState.addPlayer(playerId, playerData);
            },
          );
        }

        // Check if current player is the host based on server response
        // CRITICAL: Match local player by name since player ID might not match
        // (the server may return a different player ID than the one sent in extra.userid)
        const localPlayerName = extra.player_name || extra.netplay_username;
        let localPlayerId = extra.userid;
        let localPlayerData = response?.users?.[localPlayerId];

        // If not found by ID, try to find by name
        if (!localPlayerData && localPlayerName && response?.users) {
          const foundEntry = Object.entries(response.users).find(
            ([id, data]) =>
              data.player_name === localPlayerName ||
              data.netplay_username === localPlayerName,
          );
          if (foundEntry) {
            localPlayerId = foundEntry[0];
            localPlayerData = foundEntry[1];
            console.log(
              `[RoomManager] Matched local player by name: ${localPlayerName} -> ${localPlayerId}`,
            );
          }
        }

        if (localPlayerData && localPlayerData.is_host === true) {
          console.log(
            `[RoomManager] Player ${localPlayerId} (${localPlayerName}) is the room host (from server response)`,
          );
          this.sessionState.setHost(true);
        } else {
          console.log(
            `[RoomManager] Player ${localPlayerId} (${localPlayerName}) is not the room host`,
          );
          this.sessionState.setHost(false);
        }

        // Room joined successfully - return the response with room info
        resolve(response);
      },
    );
  }

  /**
   * Leave current room.
   * @param {string|null} reason - Leave reason (optional)
   * @returns {Promise<void>}
   */
  async leaveRoom(reason = null) {
    if (!this.socket.isConnected()) {
      // Socket already disconnected, just cleanup
      this.sessionState.clearRoom();
      this.sessionState.reset();
      return;
    }

    return new Promise((resolve) => {
      this.socket.emit(
        "leave-room",
        {
          roomName: this.sessionState.roomName,
          reason: reason,
        },
        () => {
          // Always cleanup, even if server doesn't respond
          this.sessionState.clearRoom();
          this.sessionState.reset();
          resolve();
        },
      );

      // Timeout after 2 seconds
      setTimeout(() => {
        this.sessionState.clearRoom();
        this.sessionState.reset();
        resolve();
      }, 2000);
    });
  }

  /**
   * DELAY_SYNC: Toggle ready state
   * @param {string} roomName - Room name
   * @returns {Promise}
   */
  async toggleReady(roomName) {
    console.log("[RoomManager] toggleReady called for room:", roomName);

    if (!this.socket.isConnected()) {
      console.error("[RoomManager] Socket not connected for ready toggle");
      throw new Error("Socket not connected");
    }

    return new Promise((resolve, reject) => {
      this.socket.emit(
        "toggle-ready",
        {
          roomName: roomName,
        },
        (error) => {
          if (error) {
            reject(new Error(error));
            return;
          }
          resolve();
        },
      );
    });
  }

  /**
   * DELAY_SYNC: Start game (host only)
   * @param {string} roomName - Room name
   * @returns {Promise}
   */
  async startGame(roomName) {
    console.log("[RoomManager] startGame called for room:", roomName);

    if (!this.socket.isConnected()) {
      console.error("[RoomManager] Socket not connected for game start");
      throw new Error("Socket not connected");
    }

    return new Promise((resolve, reject) => {
      this.socket.emit(
        "start-game",
        {
          roomName: roomName,
        },
        (error) => {
          if (error) {
            reject(new Error(error));
            return;
          }
          resolve();
        },
      );
    });
  }

  /**
   * DELAY_SYNC: Send ready at frame 1
   * @param {string} roomName - Room name
   * @param {number} frame - Frame number
   * @returns {Promise}
   */
  async sendReadyAtFrame1(roomName, frame) {
    console.log("[RoomManager] sendReadyAtFrame1 called:", { roomName, frame });

    if (!this.socket.isConnected()) {
      console.error("[RoomManager] Socket not connected for ready-at-frame-1");
      throw new Error("Socket not connected");
    }

    return new Promise((resolve, reject) => {
      this.socket.emit(
        "ready-at-frame-1",
        {
          roomName: roomName,
          frame: frame,
        },
        (error) => {
          if (error) {
            reject(new Error(error));
            return;
          }
          resolve();
        },
      );
    });
  }

  /**
   * Update room metadata
   * @param {string} roomName - Room name
   * @param {Object} metadata - Metadata to update
   * @returns {Promise}
   */
  async updateRoomMetadata(roomName, metadata) {
    console.log("[RoomManager] updateRoomMetadata called:", {
      roomName,
      metadata,
    });

    if (!this.socket.isConnected()) {
      console.error("[RoomManager] Socket not connected for metadata update");
      throw new Error("Socket not connected");
    }

    return new Promise((resolve, reject) => {
      this.socket.emit(
        "update-room-metadata",
        {
          roomName: roomName,
          metadata: metadata,
        },
        (error) => {
          if (error) {
            reject(new Error(error));
            return;
          }
          resolve();
        },
      );
    });
  }

  /**
   * Update player metadata
   * @param {string} roomName - Room name
   * @param {Object} metadata - Metadata to update
   * @returns {Promise}
   */
  async updatePlayerMetadata(roomName, metadata) {
    console.log("[RoomManager] updatePlayerMetadata called:", {
      roomName,
      metadata,
    });

    if (!this.socket.isConnected()) {
      console.error(
        "[RoomManager] Socket not connected for player metadata update",
      );
      throw new Error("Socket not connected");
    }

    return new Promise((resolve, reject) => {
      this.socket.emit(
        "update-player-metadata",
        {
          roomName: roomName,
          metadata: metadata,
        },
        (error) => {
          if (error) {
            reject(new Error(error));
            return;
          }
          resolve();
        },
      );
    });
  }

  /**
   * Send JOIN_INFO with validation data (DELAY_SYNC only)
   * @param {string} roomName - Room name
   * @param {Object} joinInfo - Join validation info
   * @returns {Promise}
   */
  async sendJoinInfo(roomName, joinInfo) {
    console.log("[RoomManager] sendJoinInfo called:", { roomName, joinInfo });

    if (!this.socket.isConnected()) {
      console.error("[RoomManager] Socket not connected for join info");
      throw new Error("Socket not connected");
    }

    return new Promise((resolve, reject) => {
      this.socket.emit(
        "join-info",
        {
          roomName: roomName,
          ...joinInfo,
        },
        (error) => {
          if (error) {
            reject(new Error(error));
            return;
          }
          resolve();
        },
      );
    });
  }

  /**
   * Generate a session ID (GUID).
   * @private
   * @returns {string}
   */
  generateSessionId() {
    return this.generateGuid();
  }

  /**
   * Generate a player ID (GUID).
   * @private
   * @returns {string}
   */
  generatePlayerId() {
    return this.generateGuid();
  }

  /**
   * Update player slot.
   * @param {number} slot - New slot number (0-3)
   * @returns {Promise<void>}
   */
  async updatePlayerSlot(slot) {
    console.log("[RoomManager] updatePlayerSlot called with slot:", slot);

    if (!this.socket.isConnected()) {
      console.error("[RoomManager] Socket not connected for slot update");
      throw new Error("Socket not connected");
    }

    const roomName = this.sessionState?.roomName;
    if (!roomName) {
      console.error("[RoomManager] Not in a room for slot update");
      throw new Error("Not in a room");
    }

    console.log("[RoomManager] Sending update-player-slot message:", {
      roomName,
      playerSlot: slot,
    });

    return new Promise((resolve, reject) => {
      this.socket.emit(
        "update-player-slot",
        {
          roomName: roomName,
          playerSlot: slot,
        },
        (error) => {
          if (error) {
            reject(new Error(error));
            return;
          }
          resolve();
        },
      );
    });
  }

  /**
   * Generate a GUID.
   * @private
   * @returns {string}
   */
  generateGuid() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === "x" ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }

  /**
   * Setup Socket.IO event listeners for room events.
   */
  setupEventListeners() {
    console.log(
      `[RoomManager] Setting up event listeners, isRoomListing=${this.config.isRoomListing}`,
    );

    // Listen for player join/leave events
    this.socket.on("users-updated", (users) => {
      console.log(
        "[RoomManager] 🔔 RECEIVED users-updated event:",
        Object.keys(users || {}),
      );

      if (this.sessionState) {
        // Clear existing players
        const currentPlayers = this.sessionState.getPlayers();
        console.log(
          "[RoomManager] Current players before update:",
          Array.from(currentPlayers.keys()),
        );

        // Remove players that are no longer in the room
        for (const [playerId, playerData] of currentPlayers) {
          if (!users[playerId]) {
            console.log(`[RoomManager] Removing player: ${playerId}`);
            this.sessionState.removePlayer(playerId);
          }
        }

        // Add/update players
        Object.entries(users || {}).forEach(([playerId, playerData]) => {
          console.log(
            `[RoomManager] Adding/updating player: ${playerId}`,
            playerData,
          );
          this.sessionState.addPlayer(playerId, playerData);
        });

        console.log(
          "[RoomManager] Players after update:",
          Array.from(this.sessionState.getPlayers().keys()),
        );
      }

      if (this.config.callbacks?.onUsersUpdated) {
        console.log("[RoomManager] Calling onUsersUpdated callback");
        this.config.callbacks.onUsersUpdated(users);
      } else {
        console.log(
          "[RoomManager] No onUsersUpdated callback available, skipping UI update",
        );
      }
    });

    // Listen for player slot updates
    this.socket.on("player-slot-updated", (data) => {
      console.log("[RoomManager] Received player-slot-updated:", data);
      console.log(
        "[RoomManager] Current session state players:",
        Array.from(this.sessionState?.getPlayers()?.keys() || []),
      );
      if (data && data.playerId && data.playerSlot !== undefined) {
        // Update session state
        if (this.sessionState) {
          const players = this.sessionState.getPlayers();

          // Find player by name since server sends player name but session state uses UUIDs as keys
          let playerId = data.playerId;
          let player = players.get(playerId);

          // If direct lookup fails, search by player name
          if (!player) {
            for (const [id, playerData] of players) {
              if (
                playerData.name === data.playerId ||
                playerData.player_name === data.playerId
              ) {
                playerId = id;
                player = playerData;
                break;
              }
            }
          }

          if (player) {
            player.player_slot = data.playerSlot;
            player.slot = data.playerSlot;
            // Update the player in the session state
            this.sessionState.addPlayer(playerId, player);
            console.log(
              "[RoomManager] Updated session state for player:",
              playerId,
              "slot:",
              data.playerSlot,
            );
          } else {
            console.warn(
              "[RoomManager] Could not find player in session state:",
              data.playerId,
            );
          }
        }

        // Trigger targeted slot update
        if (this.config.callbacks?.onPlayerSlotUpdated) {
          this.config.callbacks.onPlayerSlotUpdated(
            data.playerId,
            data.playerSlot,
          );
        } else if (this.config.callbacks?.onUsersUpdated) {
          // Fallback to full update if targeted update not available
          const currentUsers = this.sessionState?.getPlayersObject() || {};
          this.config.callbacks.onUsersUpdated(currentUsers);
        }
      }
    });

    // Listen for room close event
    this.socket.on("room-closed", (data) => {
      if (this.config.callbacks?.onRoomClosed) {
        this.config.callbacks.onRoomClosed(data);
      }
    });

    // DELAY_SYNC: Listen for ready state updates
    this.socket.on("player-ready-updated", (data) => {
      console.log("[RoomManager] Received player-ready-updated:", data);
      if (data && data.playerId && data.ready !== undefined) {
        // Update session state
        if (this.sessionState) {
          const players = this.sessionState.getPlayers();
          const player = players.get(data.playerId);
          if (player) {
            player.ready = data.ready;
            console.log(
              `[RoomManager] Updated ready state for ${data.playerId}: ${data.ready}`,
            );
          }
        }

        // Trigger callback
        if (this.config.callbacks?.onPlayerReadyUpdated) {
          this.config.callbacks.onPlayerReadyUpdated(data.playerId, data.ready);
        }
      }
    });

    // DELAY_SYNC: Listen for prepare start
    this.socket.on("prepare-start", (data) => {
      console.log("[RoomManager] Received prepare-start:", data);
      if (this.config.callbacks?.onPrepareStart) {
        this.config.callbacks.onPrepareStart(data);
      }
    });

    // DELAY_SYNC: Listen for validation status updates
    this.socket.on("player-validation-updated", (data) => {
      console.log("[RoomManager] Received player-validation-updated:", data);
      if (data && data.playerId && data.validationStatus !== undefined) {
        // Update session state
        if (this.sessionState) {
          const players = this.sessionState.getPlayers();
          const player = players.get(data.playerId);
          if (player) {
            player.validationStatus = data.validationStatus;
            player.validationReason = data.validationReason;
            console.log(
              `[RoomManager] Updated validation for ${data.playerId}: ${data.validationStatus}`,
            );
          }
        }

        // Trigger callback
        if (this.config.callbacks?.onPlayerValidationUpdated) {
          this.config.callbacks.onPlayerValidationUpdated(
            data.playerId,
            data.validationStatus,
            data.validationReason,
          );
        }
      }
    });

    // DELAY_SYNC: Listen for synchronized game start
    this.socket.on("start-game", (data) => {
      console.log("[RoomManager] Received start-game:", data);
      if (this.config.callbacks?.onGameStart) {
        this.config.callbacks.onGameStart(data);
      }
    });
  }
}

window.RoomManager = RoomManager;

/**
 * SocketTransport - Socket.IO room management
 *
 * Handles:
 * - Socket.IO client connection
 * - Room operations (join/create/leave)
 * - Player events (join/leave)
 * - Room discovery
 * - Data message sending
 */

class SocketTransport {
  /**
   * @param {Object} config - Configuration
   * @param {string} config.url - SFU server URL
   * @param {Object} config.callbacks - Event callbacks
   */
  constructor(config = {}) {
    this.config = config;
    this.socket = null;
    this.connected = false;
    this.callbacks = config.callbacks || {};
    this.pendingListeners = []; // Queue listeners registered before socket connection
    this.serverUrl = null; // Store the server URL for later access
    this.authToken = null; // Store the auth token for later access
  }

  /**
   * Connect to Socket.IO server.
   * @param {string} url - Server URL
   * @param {string|null} token - Authentication token (optional)
   * @returns {Promise<void>}
   */
  async connect(url, token = null) {
    if (typeof io === "undefined") {
      throw new Error(
        "Socket.IO client library not loaded. Please include <script src='https://cdn.socket.io/4.5.0/socket.io.min.js'></script>"
      );
    }

    if (this.socket && this.socket.connected) {
      console.log("[SocketTransport] Already connected, reusing:", this.socket.id);
      return;
    }

    if (!url) {
      throw new Error("Cannot initialize Socket.IO: URL is undefined");
    }

    // Clean up URL (remove trailing slashes)
    while (url.endsWith("/")) {
      url = url.substring(0, url.length - 1);
    }

    // Store the server URL and auth token for later access by other transports
    this.serverUrl = url;
    this.authToken = token;

    console.log("[SocketTransport] Initializing Socket.IO connection to:", url);

    // Create socket connection
    const socketOptions = {};
    if (token) {
      socketOptions.auth = { token };
    }

    this.socket = io(url, socketOptions);

    // Setup connection event handlers
    this.socket.on("connect", () => {
      console.log("[SocketTransport] Socket.IO connected:", this.socket.id);
      this.connected = true;

      // Register any pending listeners
      if (this.pendingListeners.length > 0) {
        console.log("[SocketTransport] Registering", this.pendingListeners.length, "pending listeners");
        this.pendingListeners.forEach(({ event, callback }) => {
          this.socket.on(event, callback);
        });
        this.pendingListeners = []; // Clear queue
      }

      if (this.callbacks.onConnect) {
        this.callbacks.onConnect(this.socket.id);
      }
    });

    this.socket.on("connect_error", (error) => {
      console.error("[SocketTransport] Connection error:", error.message);
      this.connected = false;
      if (this.callbacks.onConnectError) {
        this.callbacks.onConnectError(error);
      }
    });

    this.socket.on("disconnect", (reason) => {
      console.log("[SocketTransport] Disconnected:", reason);
      this.connected = false;
      if (this.callbacks.onDisconnect) {
        this.callbacks.onDisconnect(reason);
      }
    });

    // Wait for connection
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error("Socket.IO connection timeout"));
      }, 10000);

      this.socket.once("connect", () => {
        clearTimeout(timeout);
        resolve();
      });

      this.socket.once("connect_error", (error) => {
        clearTimeout(timeout);
        reject(error);
      });
    });
  }

  /**
   * Disconnect from server.
   */
  async disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
      this.connected = false;
    }
  }

  /**
   * Check if connected.
   * @returns {boolean}
   */
  isConnected() {
    return this.connected && this.socket && this.socket.connected;
  }

  /**
   * Emit an event to the server.
   * @param {string} event - Event name
   * @param {*} data - Event data
   * @param {Function} callback - Optional callback
   */
  emit(event, data = {}, callback = null) {
    if (!this.isConnected()) {
      console.error("[SocketTransport] Cannot emit: Socket not connected");
      return;
    }
    if (callback) {
      this.socket.emit(event, data, callback);
    } else {
      this.socket.emit(event, data);
    }
  }

  /**
   * Send a data message (for input synchronization).
   * @param {Object} data - Message data (e.g., { "sync-control": [...] })
   */
  sendDataMessage(data) {
    this.emit("data-message", data);
    console.log("[SocketTransport] Sent data message:", data);
  }

  /**
   * Register event listener.
   * @param {string} event - Event name
   * @param {Function} callback - Event callback
   */
  on(event, callback) {
    if (!this.socket) {
      // Queue listener for when socket connects
      console.log("[SocketTransport] Queueing listener for", event, "(socket not yet connected)");
      this.pendingListeners.push({ event, callback });
      return;
    }
    this.socket.on(event, callback);
  }

  /**
   * Remove event listener.
   * @param {string} event - Event name
   * @param {Function} callback - Event callback (optional, removes all if not provided)
   */
  off(event, callback = null) {
    if (!this.socket) {
      return;
    }
    if (callback) {
      this.socket.off(event, callback);
    } else {
      this.socket.off(event);
    }
  }

  /**
   * Get socket ID.
   * @returns {string|null}
   */
  getSocketId() {
    return this.socket?.id || null;
  }

  /**
   * Send frame acknowledgment.
   * @param {number} frame - Frame number
   */
  sendFrameAck(frame) {
    this.sendDataMessage({
      frameAck: frame,
    });
  }

  /**
   * Set up chat message event forwarding.
   * @param {Object} chatComponent - ChatComponent instance to forward messages to
   */
  setupChatForwarding(chatComponent) {
    console.log("[SocketTransport] Setting up chat message forwarding");
    this.on("chat-message", (message) => {
      if (chatComponent && typeof chatComponent.handleMessage === 'function') {
        chatComponent.handleMessage(message);
      } else {
        console.warn("[SocketTransport] Chat message received but no chat component available:", message);
      }
    });
  }
}

window.SocketTransport = SocketTransport;

/**
 * DataChannelManager - Input data channel handling
 *
 * Manages data channels for input synchronization:
 * - Binary input data channels
 * - Ordered vs unordered modes
 * - Retry logic for lost inputs
 * - Multiple transport modes (SFU relay, P2P)
 */

class DataChannelManager {
  /**
   * @param {Object} config - Configuration
   * @param {string} config.mode - Input mode: "orderedRelay", "unorderedRelay", "unorderedP2P", "orderedP2P"
   */
  constructor(config = {}) {
    this.config = config;
    this.mode = config.mode || "orderedRelay";
    
    // SFU data producer (for relay modes)
    this.dataProducer = null;
    
    // P2P data channels
    this.p2pChannels = new Map(); // socketId -> {ordered, unordered}
    
    // Event emitter for input messages
    this.eventEmitter = {
      listeners: {},
      on: function(event, callback) {
        if (!this.listeners[event]) {
          this.listeners[event] = [];
        }
        this.listeners[event].push(callback);
      },
      emit: function(event, data) {
        if (this.listeners[event]) {
          this.listeners[event].forEach(callback => callback(data));
        }
      }
    };

    // Ping test
    this.pingInterval = null;
    this.pingCount = 0;

    // Input buffering for P2P modes until channels are ready
    this.pendingInputs = [];
    // Note: maxPendingInputs will be set dynamically by NetplayMenu when settings change
    this.maxPendingInputs = 100; // Default fallback
  }

  /**
   * Set SFU data producer (for relay modes).
   * @param {Object} dataProducer - mediasoup DataProducer
   */
  setDataProducer(dataProducer) {
    this.dataProducer = dataProducer;
    
    if (dataProducer && typeof dataProducer.on === "function") {
      // Listen for messages from SFU data producer
      dataProducer.on("message", (message) => {
        this.handleIncomingMessage(message);
      });
    }
  }

  /**
   * Add P2P data channel.
   * @param {string} socketId - Peer socket ID
   * @param {Object} channelData - {ordered, unordered} RTCDataChannel objects
   */
  addP2PChannel(socketId, channelData) {
    const { ordered, unordered } = channelData || {};

    if (ordered) {
      ordered.onmessage = (event) => {
        this.handleIncomingMessage(event.data, socketId);
      };

      ordered.onopen = () => {
        console.log(`[DataChannelManager] 📡 Ordered P2P channel to ${socketId} opened, flushing pending inputs`);
        this.flushPendingInputs();
      };

      ordered.onclose = () => {
        console.log(`[DataChannelManager] 📡 Ordered P2P channel to ${socketId} closed`);
      };

      ordered.onerror = (error) => {
        console.warn(`[DataChannelManager] 📡 Ordered P2P channel to ${socketId} error:`, error);
      };

      // Check current state
      console.log(`[DataChannelManager] 📡 Ordered P2P channel to ${socketId} added, current state: ${ordered.readyState}`);

      // Flush pending inputs when ordered channel opens
      if (ordered.readyState === "open") {
        console.log(`[DataChannelManager] 📡 Ordered P2P channel to ${socketId} already open, flushing pending inputs`);
        this.flushPendingInputs();
      }
    }

    if (unordered) {
      unordered.onmessage = (event) => {
        this.handleIncomingMessage(event.data, socketId);
      };

      unordered.onopen = () => {
        console.log(`[DataChannelManager] 📡 Unordered P2P channel to ${socketId} opened, flushing pending inputs`);
        this.flushPendingInputs();
      };

      unordered.onclose = () => {
        console.log(`[DataChannelManager] 📡 Unordered P2P channel to ${socketId} closed`);
      };

      unordered.onerror = (error) => {
        console.warn(`[DataChannelManager] 📡 Unordered P2P channel to ${socketId} error:`, error);
      };

      // Check current state
      console.log(`[DataChannelManager] 📡 Unordered P2P channel to ${socketId} added, current state: ${unordered.readyState}`);

      // Flush pending inputs when unordered channel opens
      if (unordered.readyState === "open") {
        console.log(`[DataChannelManager] 📡 Unordered P2P channel to ${socketId} already open, flushing pending inputs`);
        this.flushPendingInputs();
      }
    }

    this.p2pChannels.set(socketId, {
      ordered: ordered,
      unordered: unordered,
    });
  }

  /**
   * Remove P2P data channel.
   * @param {string} socketId - Peer socket ID
   */
  removeP2PChannel(socketId) {
    this.p2pChannels.delete(socketId);
  }

  /**
   * Send input data over appropriate channel.
   * @param {Object} inputData - Input data object with frame, slot, playerIndex, inputIndex, value
   * @returns {boolean} True if sent successfully
   */
  sendInput(inputData) {
    console.log("[DataChannelManager] sendInput received inputData:", inputData);

    // Handle both formats: new format with individual properties, or old format with connected_input array
    let frame, slot, playerIndex, inputIndex, value;

    if (inputData.connected_input) {
      // Old format from NetplayEngine
      [playerIndex, inputIndex, value] = inputData.connected_input;
      frame = inputData.frame;
      slot = 0; // Default slot for old format
      console.log("[DataChannelManager] Using old format - extracted:", { frame, slot, playerIndex, inputIndex, value });
    } else {
      // New format with individual properties
      ({ frame, slot, playerIndex, inputIndex, value } = inputData);
      console.log("[DataChannelManager] Using new format - destructured:", { frame, slot, playerIndex, inputIndex, value });
    }

    // Ensure all values are defined
    frame = frame || 0;
    slot = slot !== undefined ? slot : 0;
    playerIndex = playerIndex !== undefined ? playerIndex : 0;
    inputIndex = inputIndex !== undefined ? inputIndex : 0;
    value = value !== undefined ? value : 0;

    console.log("[DataChannelManager] Final values for InputPayload:", { frame, slot, playerIndex, inputIndex, value });

    console.log("[DataChannelManager] 🚀 sendInput called:", {
      frame,
      slot,
      playerIndex,
      inputIndex,
      value,
      mode: this.mode,
      p2pChannelsCount: this.p2pChannels.size,
      hasDataProducer: !!this.dataProducer,
      dataProducerClosed: this.dataProducer?.closed
    });

    // Create canonical input payload
    const payload = new InputPayload(frame, slot, playerIndex, inputIndex, value);
    const payloadString = payload.serialize();

    // Convert to ArrayBuffer to avoid SFU server JSON parsing corruption
    const payloadBuffer = new TextEncoder().encode(payloadString);

    console.log("[DataChannelManager] 📤 Sending input payload as ArrayBuffer:", payloadString, "buffer size:", payloadBuffer.byteLength);
    console.log("[DataChannelManager] 📤 ArrayBuffer contents (first 50 bytes):", new Uint8Array(payloadBuffer.slice(0, 50)));

    try {
      // Relay modes: use SFU data producer
      if (this.mode === "orderedRelay" || this.mode === "unorderedRelay") {
        if (this.dataProducer && !this.dataProducer.closed && typeof this.dataProducer.send === "function") {
          this.dataProducer.send(payloadBuffer);
          console.log("[DataChannelManager] ✅ Sent input via SFU data producer");
          return true;
        } else {
          console.warn("[DataChannelManager] ❌ SFU data producer not available:", {
            hasProducer: !!this.dataProducer,
            closed: this.dataProducer?.closed,
            hasSend: typeof this.dataProducer?.send === "function"
          });
          return false;
        }
      }

      // Unordered P2P: try unordered channels first
      if (this.mode === "unorderedP2P") {
        console.log("[DataChannelManager] 🔍 Checking P2P channels for unordered mode:", Array.from(this.p2pChannels.keys()));
        let sent = false;
        this.p2pChannels.forEach((channels, socketId) => {
          console.log(`[DataChannelManager] 📡 Checking channel for ${socketId}:`, {
            hasUnordered: !!channels.unordered,
            unorderedState: channels.unordered?.readyState,
            hasOrdered: !!channels.ordered,
            orderedState: channels.ordered?.readyState
          });
          if (channels.unordered && channels.unordered.readyState === "open") {
            channels.unordered.send(payloadBuffer);
            console.log(`[DataChannelManager] ✅ Sent input via unordered P2P channel to ${socketId}`);
            sent = true;
          }
        });
        if (sent) {
          console.log("[DataChannelManager] ✅ Sent input via unordered P2P channels");
          this.flushPendingInputs(); // Send any buffered inputs now that we have channels
          return true;
        } else {
          console.log("[DataChannelManager] 📦 No ready unordered P2P channels yet - buffering input");
          // Buffer input until P2P channels are ready
          this.bufferInput(payloadBuffer);
          return true; // Don't fall back to relay for P2P modes
        }
      }

      // Ordered P2P: fallback or primary mode
      if (this.mode === "orderedP2P") {
        console.log("[DataChannelManager] 🔍 Checking P2P channels for ordered mode:", Array.from(this.p2pChannels.keys()));
        let sent = false;
        this.p2pChannels.forEach((channels, socketId) => {
          console.log(`[DataChannelManager] 📡 Checking ordered channel for ${socketId}:`, {
            orderedState: channels.ordered?.readyState
          });
          if (channels.ordered && channels.ordered.readyState === "open") {
            channels.ordered.send(payloadBuffer);
            console.log(`[DataChannelManager] ✅ Sent input via ordered P2P channel to ${socketId}`);
            sent = true;
          }
        });
        if (sent) {
          console.log("[DataChannelManager] ✅ Sent input via ordered P2P channels");
          this.flushPendingInputs(); // Send any buffered inputs now that we have channels
          return true;
        } else {
          console.log("[DataChannelManager] 📦 No open ordered P2P channels yet - buffering input");
          // Buffer input until P2P channels are ready
          this.bufferInput(payloadBuffer);
          return true; // Don't fall back to relay for P2P modes
        }
      }

      // Fallback for any remaining cases
      console.warn("[DataChannelManager] ⚠️ No transport available for input, mode:", this.mode);
      return false;
    } catch (error) {
      console.error("[DataChannelManager] Failed to send input:", error);
      return false;
    }
  }

  /**
   * Handle incoming message from data channel.
   * @private
   * @param {string|ArrayBuffer} message - Message data
   * @param {string|null} fromSocketId - Source socket ID (for P2P)
   */
  handleIncomingMessage(message, fromSocketId = null) {
    console.log("[DataChannelManager] 🔄 handleIncomingMessage called with:", {
      messageType: typeof message,
      messageLength: message?.length || message?.byteLength,
      fromSocketId
    });

    try {
      let data;
      console.log("[DataChannelManager] Raw message received:", {
        type: typeof message,
        value: message,
        stringValue: String(message),
        isObject: typeof message === "object",
        constructor: message?.constructor?.name
      });

      // Try to handle the message intelligently
      if (message instanceof ArrayBuffer || (typeof message === "object" && message && message.byteLength !== undefined)) {
        // Message is an ArrayBuffer (check byteLength as fallback for instanceof issues)
        const text = new TextDecoder().decode(message);
        console.log("[DataChannelManager] Decoded ArrayBuffer text:", text, "length:", text.length);
        try {
          data = JSON.parse(text);
          console.log("[DataChannelManager] Parsed JSON data:", data);
        } catch (parseError) {
          console.warn("[DataChannelManager] Failed to parse ArrayBuffer text:", text, "error:", parseError);
          return; // Silently ignore malformed ArrayBuffer data
        }
      } else if (typeof message === "object" && message !== null) {
        // Message is already parsed (from SFU transport)
        data = message;
      } else if (typeof message === "string") {
        // Handle case where string is "[object Object]" (object.toString() result)
        if (message === "[object Object]") {
          return; // Silently ignore
        }
        // Check if it's a valid JSON string
        try {
          data = JSON.parse(message);
        } catch (parseError) {
          return; // Silently ignore malformed JSON
        }
      } else {
        console.warn("[DataChannelManager] Unknown message type:", typeof message, "value:", message);
        return;
      }

      console.log("[DataChannelManager] 📥 Received message:", { data, fromSocketId });

      // Handle ping messages
      if (data.type === "ping") {
        console.log("[DataChannelManager] 🏓 Received ping:", {
          count: data.count,
          timestamp: data.timestamp,
          latency: Date.now() - data.timestamp
        });
        return;
      }

      // Parse input data using canonical InputPayload format
      if (data.t === "i") {
        const payload = InputPayload.deserialize(data);
        if (payload) {
          console.log("[DataChannelManager] 📨 Received input packet:", {
            frame: payload.getFrame(),
            slot: payload.getSlot(),
            player: payload.p,
            input: payload.k,
            value: payload.v,
            fromSocketId
          });
          // Emit input event with the payload
          this.eventEmitter.emit("input", { payload, fromSocketId });
        } else {
          console.warn("[DataChannelManager] Failed to deserialize input payload:", data);
        }
      } else {
        console.warn("[DataChannelManager] Unknown message type received:", data);
      }
    } catch (error) {
      console.error("[DataChannelManager] Failed to parse incoming message:", error);
    }
  }

  /**
   * Register callback for received inputs.
   * @param {Function} callback - Callback({payload, fromSocketId})
   */
  onInput(callback) {
    this.eventEmitter.on("input", callback);
  }

  /**
   * Buffer input for later sending when P2P channels become available.
   * @private
   * @param {ArrayBuffer} payload - Encoded payload buffer to buffer
   */
  bufferInput(payload) {
    this.pendingInputs.push({
      payload,
      timestamp: Date.now()
    });

    // Prevent unbounded growth
    if (this.pendingInputs.length > this.maxPendingInputs) {
      console.warn(`[DataChannelManager] ⚠️ Pending inputs buffer full (${this.maxPendingInputs}), dropping oldest. This suggests P2P channels are not opening properly.`);
      this.pendingInputs.shift();
    }

    // Warn when buffer is getting full
    if (this.pendingInputs.length > this.maxPendingInputs * 0.8) {
      console.warn(`[DataChannelManager] ⚠️ Pending inputs buffer at ${this.pendingInputs.length}/${this.maxPendingInputs} - P2P channels may not be opening`);
    }

    console.log(`[DataChannelManager] 📦 Buffered input, ${this.pendingInputs.length} pending`);
  }

  /**
   * Flush pending inputs through available P2P channels.
   */
  flushPendingInputs() {
    if (this.pendingInputs.length === 0) {
      return;
    }

    console.log(`[DataChannelManager] 🚀 Flushing ${this.pendingInputs.length} pending inputs`);

    const inputsToSend = [...this.pendingInputs];
    this.pendingInputs = []; // Clear buffer

    inputsToSend.forEach(({ payload, timestamp }) => {
      try {
        let sent = false;

        // Payload is already an ArrayBuffer

        // Try unordered channels first (for unorderedP2P mode)
        if (this.mode === "unorderedP2P") {
          this.p2pChannels.forEach((channels, socketId) => {
            if (channels.unordered && channels.unordered.readyState === "open") {
              channels.unordered.send(payload);
              console.log(`[DataChannelManager] ✅ Flushed buffered input via unordered P2P to ${socketId}`);
              sent = true;
            }
          });
        }

        // Try ordered channels (for orderedP2P mode or as fallback)
        if (!sent) {
          this.p2pChannels.forEach((channels, socketId) => {
            if (channels.ordered && channels.ordered.readyState === "open") {
              channels.ordered.send(payload);
              console.log(`[DataChannelManager] ✅ Flushed buffered input via ordered P2P to ${socketId}`);
              sent = true;
            }
          });
        }

        if (!sent) {
          console.warn("[DataChannelManager] ❌ Could not flush buffered input - no channels ready");
          // Put it back in the buffer
          this.pendingInputs.unshift({ payload, timestamp });
        }
      } catch (error) {
        console.error("[DataChannelManager] ❌ Error flushing buffered input:", error);
      }
    });
  }

  /**
   * Check if data channels are ready.
   * @returns {boolean}
   */
  isReady() {
    let ready = false;

    if (this.mode === "orderedRelay" || this.mode === "unorderedRelay") {
      ready = this.dataProducer && !this.dataProducer.closed;
      console.log("[DataChannelManager] isReady check for relay mode:", {
        mode: this.mode,
        hasDataProducer: !!this.dataProducer,
        dataProducerClosed: this.dataProducer?.closed,
        ready
      });
    } else {
      // P2P modes: check if at least one channel is open
      for (const [socketId, channels] of this.p2pChannels.entries()) {
        if (channels.ordered?.readyState === "open" || channels.unordered?.readyState === "open") {
          console.log("[DataChannelManager] isReady check for P2P mode:", {
            mode: this.mode,
            socketId,
            orderedState: channels.ordered?.readyState,
            unorderedState: channels.unordered?.readyState,
            ready: true
          });
          ready = true;
          break;
        }
      }

      if (!ready) {
        console.log("[DataChannelManager] isReady check for P2P mode - no open channels:", {
          mode: this.mode,
          channelCount: this.p2pChannels.size,
          ready: false
        });
      }
    }

    return ready;
  }

  /**
   * Start ping test to verify channel connectivity.
   */
  startPingTest() {
    if (this.pingInterval) {
      console.log("[DataChannelManager] Ping test already running");
      return;
    }

    console.log("[DataChannelManager] Starting ping test every 1 second");
    this.pingInterval = setInterval(() => {
      this.pingCount++;
      const pingPayload = JSON.stringify({
        type: "ping",
        count: this.pingCount,
        timestamp: Date.now()
      });

      // Convert ping payload to ArrayBuffer
    const pingBuffer = new TextEncoder().encode(pingPayload);

    console.log("[DataChannelManager] 📡 Sending ping:", pingPayload);

      try {
        // Relay modes: use SFU data producer
        if (this.mode === "orderedRelay" || this.mode === "unorderedRelay") {
          if (this.dataProducer && !this.dataProducer.closed && typeof this.dataProducer.send === "function") {
            this.dataProducer.send(pingBuffer);
          }
        }

        // P2P modes: send to all channels
        this.p2pChannels.forEach((channels, socketId) => {
          if (channels.unordered && channels.unordered.readyState === "open") {
            channels.unordered.send(pingBuffer);
          } else if (channels.ordered && channels.ordered.readyState === "open") {
            channels.ordered.send(pingBuffer);
          }
        });
      } catch (error) {
        console.error("[DataChannelManager] Failed to send ping:", error);
      }
    }, 1000);
  }

  /**
   * Stop ping test.
   */
  stopPingTest() {
    if (this.pingInterval) {
      console.log("[DataChannelManager] Stopping ping test");
      clearInterval(this.pingInterval);
      this.pingInterval = null;
      this.pingCount = 0;
    }
  }

  /**
   * Cleanup all data channels.
   */
  cleanup() {
    this.stopPingTest();
    this.dataProducer = null;
    this.p2pChannels.clear();
    this.eventEmitter.listeners = {};
  }
}

window.DataChannelManager = DataChannelManager;

/**
 * SFUTransport - SFU WebRTC client (mediasoup)
 *
 * Handles:
 * - mediasoup-client integration
 * - WebRTC transport management
 * - Producer/consumer lifecycle
 * - Codec negotiation (VP9 SVC, H264, VP8)
 * - ICE restart on connection failures
 */

class SFUTransport {
  /**
   * @param {Object} config - Configuration
   * @param {Object} socketTransport - SocketTransport instance
   * @param {Object} dataChannelManager - DataChannelManager instance
   */
  constructor(config = {}, socketTransport, dataChannelManager = null) {
    this.config = config;
    this.socket = socketTransport;
    this.dataChannelManager = dataChannelManager;
    this.device = null;
    this.mediasoupClient = null;
    this.routerRtpCapabilities = null;
    this.useSFU = false;

    // SFU state - undefined means not initialized yet
    this.useSFU = undefined;

    // Transports - separate for each media type
    this.videoSendTransport = null;
    this.audioSendTransport = null;
    this.dataSendTransport = null;
    this.recvTransport = null; // Single receive transport for all consumers

    // Producers (host only)
    this.videoProducer = null;
    this.audioProducer = null;
    this.dataProducer = null;

    // Consumers (clients only) - Map: producerId -> Consumer
    this.consumers = new Map();

    // ICE restart tracking
    this.iceRestartTimers = new Map();

    // Drift monitoring (optional, soft monitoring only - no restarts)
    this.driftMonitoringEnabled = config.enableDriftMonitoring !== false; // Default enabled
    this.driftMonitoringInterval = null;
    this.driftThresholds = {
      audioJitterMs: 100, // Warn if audio jitter buffer exceeds 100ms
      packetLossPercent: 5, // Warn if packet loss exceeds 5%
      rttDriftMs: 200, // Warn if RTT drift exceeds 200ms
    };
  }

  /**
   * Set the DataChannelManager instance.
   * @param {Object} dataChannelManager - DataChannelManager instance
   */
  setDataChannelManager(dataChannelManager) {
    this.dataChannelManager = dataChannelManager;
  }

  /**
   * Initialize SFU connection (check availability, load device).
   * @returns {Promise<boolean>} True if SFU is available and initialized
   */
  async initialize() {
    console.log("[SFUTransport] initialize() called, useSFU:", this.useSFU);
    console.log("[SFUTransport] Checking socket connection...");
    if (!this.socket || !this.socket.isConnected()) {
      console.warn("[SFUTransport] Cannot initialize: Socket not connected");
      this.useSFU = false;
      return false;
    }
    console.log(
      "[SFUTransport] Socket is connected, proceeding with SFU initialization",
    );

    try {
      // Check if SFU is available
      console.log("[SFUTransport] Checking SFU availability...");
      const available = await new Promise((resolve) => {
        const timeout = setTimeout(() => {
          console.warn("[SFUTransport] SFU availability check timed out");
          resolve(false);
        }, 5000); // 5 second timeout

        this.socket.emit("sfu-available", {}, (resp) => {
          clearTimeout(timeout);
          console.log("[SFUTransport] SFU availability response:", resp);
          resolve(resp && resp.available);
        });
      });

      if (!available) {
        console.warn("[SFUTransport] SFU server reports not available");
        this.useSFU = false;
        return false;
      }
      console.log("[SFUTransport] SFU server reports available");

      // Get mediasoup client from window or global scope (must be loaded separately)
      console.log("[SFUTransport] Checking for mediasoup-client...");
      console.log(
        "[SFUTransport] window.mediasoupClient:",
        typeof window.mediasoupClient,
      );
      console.log("[SFUTransport] window.mediasoup:", typeof window.mediasoup);
      console.log(
        "[SFUTransport] global mediasoupClient:",
        typeof mediasoupClient,
      );

      this.mediasoupClient =
        window.mediasoupClient ||
        window.mediasoup ||
        (typeof mediasoupClient !== "undefined" ? mediasoupClient : null);

      if (!this.mediasoupClient) {
        console.warn(
          "[SFUTransport] mediasoup-client not available in browser; SFU disabled.",
        );
        this.useSFU = false;
        return false;
      }
      console.log(
        "[SFUTransport] Found mediasoup-client:",
        typeof this.mediasoupClient,
      );

      // Create device
      this.device = new this.mediasoupClient.Device();

      // Request router RTP capabilities
      this.routerRtpCapabilities = await new Promise((resolve, reject) => {
        this.socket.emit("sfu-get-router-rtp-capabilities", {}, (err, data) => {
          if (err) return reject(err);
          resolve(data);
        });
      });

      // Load device with router capabilities
      await this.device.load({
        routerRtpCapabilities: this.routerRtpCapabilities,
      });

      this.useSFU = true;
      console.log(
        "[SFUTransport] SFU available and mediasoup-client initialized",
      );
      return true;
    } catch (err) {
      console.error("[SFUTransport] SFU initialization failed:", err);
      console.error("[SFUTransport] Error stack:", err.stack);
      this.useSFU = false;
      return false;
    }
  }

  /**
   * Fetch ICE servers from the SFU server.
   * @returns {Promise<Array>} Array of ICE server configurations
   */
  async getIceServers() {
    console.log("[SFUTransport] Fetching ICE servers from SFU...");

    if (!this.socket || !this.socket.isConnected()) {
      console.warn(
        "[SFUTransport] Cannot fetch ICE servers: Socket not connected",
      );
      return [];
    }

    try {
      // Get the SFU base URL from the socket
      const sfuUrl = this.socket?.serverUrl;
      if (!sfuUrl) {
        console.warn(
          "[SFUTransport] Cannot fetch ICE servers: No SFU URL available",
        );
        return [];
      }

      // Extract the base URL (remove /socket.io/...)
      const baseUrl = sfuUrl.replace(/\/socket\.io.*$/, "");

      // Get auth token for the request
      const token = this.socket?.authToken;
      if (!token) {
        console.warn(
          "[SFUTransport] Cannot fetch ICE servers: No auth token available",
        );
        return [];
      }

      const iceEndpoint = `${baseUrl}/ice`;

      console.log(`[SFUTransport] Fetching ICE servers from: ${iceEndpoint}`);

      const response = await fetch(iceEndpoint, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
      });

      if (!response.ok) {
        console.warn(
          `[SFUTransport] ICE server fetch failed: ${response.status} ${response.statusText}`,
        );
        return [];
      }

      const data = await response.json();
      console.log("[SFUTransport] Received ICE servers from SFU:", data);

      // Store announced IP for future use if provided
      if (data.announcedIp) {
        console.log(
          `[SFUTransport] SFU provided announced IP: ${data.announcedIp}`,
        );
        this.announcedIp = data.announcedIp;
      }

      if (data && Array.isArray(data.iceServers)) {
        console.log(
          `[SFUTransport] Successfully retrieved ${data.iceServers.length} ICE servers from SFU`,
        );
        return data.iceServers;
      } else {
        console.warn(
          "[SFUTransport] Invalid ICE server response format:",
          data,
        );
        return [];
      }
    } catch (error) {
      console.error(
        "[SFUTransport] Error fetching ICE servers from SFU:",
        error,
      );
      return [];
    }
  }

  /**
   * Pick video codec based on configuration and router capabilities.
   * @returns {Object|null} Selected codec or null
   */
  pickVideoCodec() {
    try {
      const normalizeHostCodec = (v) => {
        const s = typeof v === "string" ? v.trim().toLowerCase() : "";
        if (s === "vp9" || s === "h264" || s === "vp8" || s === "auto")
          return s;
        return "auto";
      };

      const mode = normalizeHostCodec(
        this.config.hostCodec ||
          (typeof window.EJS_NETPLAY_HOST_CODEC === "string"
            ? window.EJS_NETPLAY_HOST_CODEC
            : null) ||
          "auto",
      );

      const routerCaps = this.routerRtpCapabilities || null;
      const routerCodecs =
        routerCaps && Array.isArray(routerCaps.codecs) ? routerCaps.codecs : [];

      // Filter video codecs (excluding RTX)
      const candidates = routerCodecs.filter((c) => {
        const mt = c && typeof c.mimeType === "string" ? c.mimeType : "";
        const mtl = mt.toLowerCase();
        if (!mtl.startsWith("video/")) return false;
        if (mtl === "video/rtx") return false;
        return (
          mtl === "video/vp9" || mtl === "video/h264" || mtl === "video/vp8"
        );
      });

      // Check browser support
      const caps =
        typeof RTCRtpSender !== "undefined" &&
        RTCRtpSender.getCapabilities &&
        RTCRtpSender.getCapabilities("video")
          ? RTCRtpSender.getCapabilities("video").codecs || []
          : [];
      const supports = (mimeLower) =>
        caps.some(
          (cc) =>
            cc &&
            typeof cc.mimeType === "string" &&
            cc.mimeType.toLowerCase() === mimeLower,
        );

      // If mode is forced, try that first
      const wantMime =
        mode === "vp9"
          ? "video/vp9"
          : mode === "h264"
            ? "video/h264"
            : mode === "vp8"
              ? "video/vp8"
              : null;

      if (wantMime) {
        const forced = candidates.find(
          (c) => c && c.mimeType && c.mimeType.toLowerCase() === wantMime,
        );
        if (forced && supports(wantMime)) return forced;
      }

      // Otherwise, pick first supported codec in router order
      for (const c of candidates) {
        const mt = c && typeof c.mimeType === "string" ? c.mimeType : "";
        const mtl = mt.toLowerCase();
        if (supports(mtl)) return c;
      }
    } catch (e) {
      console.error("[SFUTransport] Error picking video codec:", e);
    }
    return null;
  }

  /**
   * Create SFU transports (send for host, recv for clients).
   * @param {boolean} isHost - True if host role
   * @returns {Promise<void>}
   */
  async createTransports(isHost) {
    // Check if we need to re-initialize SFU
    if (!this.useSFU || !this.device || !this.socket.isConnected()) {
      console.log(
        "[SFUTransport] Not ready, attempting to re-initialize SFU...",
      );

      // Try to re-initialize if socket is connected
      if (this.socket && this.socket.isConnected()) {
        const reInitSuccess = await this.initialize();
        if (!reInitSuccess) {
          console.warn("[SFUTransport] SFU re-initialization failed");
          return;
        }
        console.log("[SFUTransport] SFU re-initialized successfully");
      } else {
        console.warn(
          "[SFUTransport] Cannot create transports: Socket not connected",
        );
        return;
      }
    }

    const role = isHost ? "send" : "recv";

    // Wait for readiness (with re-init capability)
    const ready = await this.waitFor(
      () => {
        // If we become unready during wait, try to re-init
        if (!this.useSFU || !this.device || !this.socket.isConnected()) {
          console.log(
            "[SFUTransport] Lost readiness during wait, re-initializing...",
          );
          this.initialize().catch((err) =>
            console.warn("[SFUTransport] Re-init during wait failed:", err),
          );
          return false;
        }
        return true;
      },
      5000,
      200,
    );

    if (!ready) {
      console.warn(
        "[SFUTransport] Not ready for transport creation after wait",
      );
      return;
    }

    try {
      const transportInfo = await new Promise((resolve, reject) => {
        this.socket.emit(
          "sfu-create-transport",
          { direction: role },
          (err, info) => {
            if (err) return reject(err);
            resolve(info);
          },
        );
      });

      if (isHost) {
        // Create send transport (host)
        this.sendTransport = this.device.createSendTransport(transportInfo);

        // Setup connection state handlers (ICE restart on failure)
        this.setupTransportEventHandlers(
          this.sendTransport,
          transportInfo.id,
          "send",
        );

        // Listen for connect event and handle DTLS connection
        this.sendTransport.on(
          "connect",
          async ({ dtlsParameters }, callback, errback) => {
            try {
              console.log(
                `[SFUTransport] Transport ${transportInfo.id} connect event received`,
              );
              // Send DTLS parameters to server
              const result = await new Promise((resolve, reject) => {
                this.socket.emit(
                  "sfu-connect-transport",
                  {
                    transportId: transportInfo.id,
                    dtlsParameters,
                  },
                  (err, data) => {
                    if (err) return reject(err);
                    resolve(data);
                  },
                );
              });
              console.log(
                `[SFUTransport] Transport ${transportInfo.id} DTLS connection completed`,
              );
              callback();
            } catch (error) {
              console.error(
                `[SFUTransport] Transport ${transportInfo.id} DTLS connection failed:`,
                error,
              );
              errback(error);
            }
          },
        );

        // Listen for produce event and handle producer creation
        this.sendTransport.on(
          "produce",
          async ({ kind, rtpParameters, appData }, callback, errback) => {
            try {
              console.log(
                `[SFUTransport] Transport ${transportInfo.id} produce event received for ${kind}`,
              );
              // Send produce request to server
              const result = await new Promise((resolve, reject) => {
                this.socket.emit(
                  "sfu-produce",
                  {
                    transportId: transportInfo.id,
                    kind,
                    rtpParameters,
                    appData,
                  },
                  (err, data) => {
                    if (err) return reject(err);
                    resolve(data);
                  },
                );
              });
              console.log(
                `[SFUTransport] Transport ${transportInfo.id} producer created:`,
                result,
              );
              callback({ id: result.id });
            } catch (error) {
              console.error(
                `[SFUTransport] Transport ${transportInfo.id} producer creation failed:`,
                error,
              );
              errback(error);
            }
          },
        );

        console.log("[SFUTransport] Created sendTransport with handlers:", {
          id: transportInfo.id,
        });

        console.log("[SFUTransport] Created sendTransport:", {
          id: transportInfo.id,
        });

        // HOSTS ALSO NEED RECEIVE TRANSPORT TO GET DATA FROM CLIENTS
        try {
          const recvTransportInfo = await new Promise((resolve, reject) => {
            this.socket.emit(
              "sfu-create-transport",
              { direction: "recv" },
              (err, info) => {
                if (err) return reject(err);
                resolve(info);
              },
            );
          });

          this.recvTransport =
            this.device.createRecvTransport(recvTransportInfo);

          this.setupTransportEventHandlers(
            this.recvTransport,
            recvTransportInfo.id,
            "recv",
          );

          // Listen for connect event and handle DTLS connection
          this.recvTransport.on(
            "connect",
            async ({ dtlsParameters }, callback, errback) => {
              try {
                console.log(
                  `[SFUTransport] Transport ${recvTransportInfo.id} connect event received`,
                );
                // Send DTLS parameters to server
                const result = await new Promise((resolve, reject) => {
                  this.socket.emit(
                    "sfu-connect-transport",
                    {
                      transportId: recvTransportInfo.id,
                      dtlsParameters,
                    },
                    (err, data) => {
                      if (err) return reject(err);
                      resolve(data);
                    },
                  );
                });
                console.log(
                  `[SFUTransport] Transport ${recvTransportInfo.id} DTLS connection completed`,
                );
                callback();
              } catch (error) {
                console.error(
                  `[SFUTransport] Transport ${recvTransportInfo.id} DTLS connection failed:`,
                  error,
                );
                errback(error);
              }
            },
          );

          console.log(
            "[SFUTransport] Created recvTransport for host with connect handler:",
            {
              id: recvTransportInfo.id,
            },
          );

          console.log("[SFUTransport] Created recvTransport for host:", {
            id: recvTransportInfo.id,
          });
        } catch (error) {
          console.warn(
            "[SFUTransport] Failed to create receive transport for host:",
            error,
          );
        }
      } else {
        // Create recv transport (client)
        this.recvTransport = this.device.createRecvTransport(transportInfo);

        this.setupTransportEventHandlers(
          this.recvTransport,
          transportInfo.id,
          "recv",
        );

        // Listen for connect event and handle DTLS connection
        this.recvTransport.on(
          "connect",
          async ({ dtlsParameters }, callback, errback) => {
            try {
              console.log(
                `[SFUTransport] Transport ${transportInfo.id} connect event received`,
              );
              // Send DTLS parameters to server
              const result = await new Promise((resolve, reject) => {
                this.socket.emit(
                  "sfu-connect-transport",
                  {
                    transportId: transportInfo.id,
                    dtlsParameters,
                  },
                  (err, data) => {
                    if (err) return reject(err);
                    resolve(data);
                  },
                );
              });
              console.log(
                `[SFUTransport] Transport ${transportInfo.id} DTLS connection completed`,
              );
              callback();
            } catch (error) {
              console.error(
                `[SFUTransport] Transport ${transportInfo.id} DTLS connection failed:`,
                error,
              );
              errback(error);
            }
          },
        );

        console.log(
          "[SFUTransport] Created recvTransport with connect handler:",
          {
            id: transportInfo.id,
          },
        );

        console.log("[SFUTransport] Created recvTransport:", {
          id: transportInfo.id,
        });
      }
    } catch (error) {
      console.error("[SFUTransport] Failed to create transport:", error);
      throw error;
    }
  }

  /**
   * Create a send transport for a specific media type
   * @param {string} mediaType - 'video', 'audio', or 'data' (defaults to 'data')
   * @returns {Promise<Object>} Created transport
   */
  async createSendTransport(mediaType = "data") {
    // Check if we need to re-initialize SFU
    if (!this.useSFU || !this.device || !this.socket.isConnected()) {
      console.log(
        "[SFUTransport] Not ready, attempting to re-initialize SFU...",
      );

      // Try to re-initialize if socket is connected
      if (this.socket && this.socket.isConnected()) {
        const reInitSuccess = await this.initialize();
        if (!reInitSuccess) {
          console.warn("[SFUTransport] SFU re-initialization failed");
          return;
        }
        console.log("[SFUTransport] SFU re-initialized successfully");
      } else {
        console.warn(
          "[SFUTransport] Cannot create send transport: Socket not connected",
        );
        return;
      }
    }

    // Get the appropriate transport property based on media type
    const transportProperty =
      mediaType === "video"
        ? "videoSendTransport"
        : mediaType === "audio"
          ? "audioSendTransport"
          : "dataSendTransport";

    // Check if transport already exists and is usable
    if (this[transportProperty]) {
      try {
        if (
          !this[transportProperty].closed &&
          this[transportProperty].connectionState !== "closed" &&
          this[transportProperty].connectionState !== "failed"
        ) {
          console.log(
            `[SFUTransport] ${mediaType} send transport already exists and is usable`,
          );
          return this[transportProperty];
        }
      } catch (e) {
        console.log(
          `[SFUTransport] ${mediaType} send transport exists but appears invalid, clearing it`,
        );
        this[transportProperty] = null;
      }
    }

    // If transport exists but is closed, clear it
    if (
      this[transportProperty] &&
      (this[transportProperty].closed ||
        this[transportProperty].connectionState === "closed" ||
        this[transportProperty].connectionState === "failed")
    ) {
      console.log(
        `[SFUTransport] ${mediaType} send transport exists but is closed/failed, clearing and creating new one`,
      );
      this[transportProperty] = null;
    }

    // Wait for readiness
    const ready = await this.waitFor(
      () => {
        if (!this.useSFU || !this.device || !this.socket.isConnected()) {
          console.log(
            "[SFUTransport] Lost readiness during wait, re-initializing...",
          );
          this.initialize().catch((err) =>
            console.warn("[SFUTransport] Re-init during wait failed:", err),
          );
          return false;
        }
        return true;
      },
      5000,
      200,
    );

    if (!ready) {
      console.warn(
        `[SFUTransport] Not ready for ${mediaType} send transport creation after wait`,
      );
      return;
    }

    try {
      const transportInfo = await new Promise((resolve, reject) => {
        this.socket.emit(
          "sfu-create-transport",
          { direction: "send" },
          (err, info) => {
            if (err) return reject(err);
            resolve(info);
          },
        );
      });

      // Create send transport
      const transport = this.device.createSendTransport(transportInfo);
      this[transportProperty] = transport;

      // Also set as the main send transport for producers to use
      if (mediaType === "video") {
        this.sendTransport = transport;
      }

      if (!transport) {
        throw new Error(`Failed to create ${mediaType} send transport`);
      }

      // Setup connection state handlers (ICE restart on failure)
      this.setupTransportEventHandlers(
        transport,
        transportInfo.id,
        `send-${mediaType}`,
      );

      // Listen for connect event and handle DTLS connection
      transport.on("connect", async ({ dtlsParameters }, callback, errback) => {
        try {
          console.log(
            `[SFUTransport] Transport ${transportInfo.id} connect event received`,
          );
          // Send DTLS parameters to server
          const result = await new Promise((resolve, reject) => {
            this.socket.emit(
              "sfu-connect-transport",
              {
                transportId: transportInfo.id,
                dtlsParameters,
              },
              (err, data) => {
                if (err) return reject(err);
                resolve(data);
              },
            );
          });
          console.log(
            `[SFUTransport] Transport ${transportInfo.id} DTLS connection completed`,
          );
          callback();
        } catch (error) {
          console.error(
            `[SFUTransport] Transport ${transportInfo.id} DTLS connection failed:`,
            error,
          );
          errback(error);
        }
      });

      // Listen for produce event and handle producer creation
      transport.on(
        "produce",
        async ({ kind, rtpParameters, appData }, callback, errback) => {
          try {
            console.log(
              `[SFUTransport] Transport ${transportInfo.id} produce event received for ${kind}`,
            );
            // Send produce request to server
            const result = await new Promise((resolve, reject) => {
              this.socket.emit(
                "sfu-produce",
                {
                  transportId: transportInfo.id,
                  kind,
                  rtpParameters,
                  appData,
                },
                (err, data) => {
                  if (err) return reject(err);
                  resolve(data);
                },
              );
            });
            console.log(
              `[SFUTransport] Transport ${transportInfo.id} producer created:`,
              result,
            );
            callback({ id: result.id });
          } catch (error) {
            console.error(
              `[SFUTransport] Transport ${transportInfo.id} producer creation failed:`,
              error,
            );
            errback(error);
          }
        },
      );

      // Listen for producedata event and handle data producer creation
      transport.on(
        "producedata",
        async (
          { sctpStreamParameters, label, protocol, appData },
          callback,
          errback,
        ) => {
          try {
            console.log(
              `[SFUTransport] Transport ${transportInfo.id} producedata event received for ${label || "data"}`,
            );
            // Send produce data request to server
            const result = await new Promise((resolve, reject) => {
              this.socket.emit(
                "producedata",
                {
                  transportId: transportInfo.id,
                  sctpStreamParameters,
                  label,
                  protocol,
                  appData,
                },
                (err, data) => {
                  if (err) return reject(err);
                  resolve(data);
                },
              );
            });
            console.log(
              `[SFUTransport] Transport ${transportInfo.id} data producer created:`,
              result,
            );
            callback({ id: result.id });
          } catch (error) {
            console.error(
              `[SFUTransport] Transport ${transportInfo.id} data producer creation failed:`,
              error,
            );
            errback(error);
          }
        },
      );

      console.log(
        `[SFUTransport] Created ${mediaType} sendTransport with handlers:`,
        {
          id: transportInfo.id,
        },
      );

      console.log(`[SFUTransport] Created ${mediaType} sendTransport:`, {
        id: transportInfo.id,
      });

      return transport;
    } catch (error) {
      console.error(
        `[SFUTransport] Failed to create ${mediaType} send transport:`,
        error,
      );
      throw error;
    }
  }

  /**
   * Create a receive transport for consuming media/data from other peers
   * @returns {Promise<Object>} Created receive transport
   */

  async createRecvTransport() {
    // Check if we need to re-initialize SFU
    if (!this.useSFU || !this.device || !this.socket.isConnected()) {
      console.log(
        "[SFUTransport] Not ready, attempting to re-initialize SFU...",
      );

      // Try to re-initialize if socket is connected
      if (this.socket && this.socket.isConnected()) {
        const reInitSuccess = await this.initialize();
        if (!reInitSuccess) {
          console.warn("[SFUTransport] SFU re-initialization failed");
          return;
        }
        console.log("[SFUTransport] SFU re-initialized successfully");
      } else {
        console.warn(
          "[SFUTransport] Cannot create receive transport: Socket not connected",
        );
        return;
      }
    }

    // Check if receive transport already exists and is usable
    if (this.recvTransport) {
      try {
        if (
          !this.recvTransport.closed &&
          this.recvTransport.connectionState !== "closed" &&
          this.recvTransport.connectionState !== "failed"
        ) {
          console.log(
            "[SFUTransport] Receive transport already exists and is usable",
          );
          return this.recvTransport;
        }
      } catch (e) {
        console.log(
          "[SFUTransport] Receive transport exists but appears invalid, clearing it",
        );
        this.recvTransport = null;
      }
    }

    // If transport exists but is closed, clear it
    if (
      this.recvTransport &&
      (this.recvTransport.closed ||
        this.recvTransport.connectionState === "closed" ||
        this.recvTransport.connectionState === "failed")
    ) {
      console.log(
        "[SFUTransport] Receive transport exists but is closed/failed, clearing and creating new one",
      );
      this.recvTransport = null;
    }

    // Wait for readiness
    const ready = await this.waitFor(
      () => {
        if (!this.useSFU || !this.device || !this.socket.isConnected()) {
          console.log(
            "[SFUTransport] Lost readiness during wait, re-initializing...",
          );
          this.initialize().catch((err) =>
            console.warn("[SFUTransport] Re-init during wait failed:", err),
          );
          return false;
        }
        return true;
      },
      5000,
      200,
    );

    if (!ready) {
      console.warn(
        "[SFUTransport] Not ready for receive transport creation after wait",
      );
      return;
    }

    try {
      const transportInfo = await new Promise((resolve, reject) => {
        this.socket.emit(
          "sfu-create-transport",
          { direction: "recv" },
          (err, info) => {
            if (err) return reject(err);
            resolve(info);
          },
        );
      });

      // Create receive transport
      const transport = this.device.createRecvTransport(transportInfo);
      this.recvTransport = transport;

      console.log(
        `[SFUTransport] Created recv transport, DTLS params available:`,
        !!transport.dtlsParameters,
      );

      // Setup connection state handlers
      this.setupTransportEventHandlers(transport, transportInfo.id, "recv");
      {
      }

      // Listen for connect event and handle DTLS connection
      transport.on("connect", async ({ dtlsParameters }, callback, errback) => {
        try {
          console.log(
            `[SFUTransport] Transport ${transportInfo.id} connect event received`,
          );
          // Send DTLS parameters to server
          const result = await new Promise((resolve, reject) => {
            this.socket.emit(
              "sfu-connect-transport",
              {
                transportId: transportInfo.id,
                dtlsParameters,
              },
              (err, data) => {
                if (err) return reject(err);
                resolve(data);
              },
            );
          });
          console.log(
            `[SFUTransport] Transport ${transportInfo.id} DTLS connection completed`,
          );
          callback();
        } catch (error) {
          console.error(
            `[SFUTransport] Transport ${transportInfo.id} DTLS connection failed:`,
            error,
          );
          errback(error);
        }
      });

      return transport;
    } catch (error) {
      console.error(
        "[SFUTransport] Failed to create receive transport:",
        error,
      );
      throw error;
    }
  }
  /**
   * Request ICE restart from SFU server.
   * @private
   * @param {Object} transport - Transport object
   * @param {string} transportId - Transport ID
   * @returns {Promise<boolean>} True if restart succeeded
   */
  async requestIceRestart(transport, transportId) {
    if (!transport || !transportId || transport.closed) return false;
    if (!this.socket.isConnected()) return false;

    // Prevent duplicate restarts
    const now = Date.now();
    if (transport._ejsIceRestartInProgress) return false;
    if (
      transport._ejsLastIceRestartAt &&
      now - transport._ejsLastIceRestartAt < 3000
    ) {
      return false;
    }

    transport._ejsIceRestartInProgress = true;
    transport._ejsLastIceRestartAt = now;

    console.warn("[SFUTransport] Requesting ICE restart", {
      transportId,
      direction: transport.direction,
      connectionState: transport.connectionState,
    });

    const resp = await new Promise((resolve, reject) => {
      this.socket.emit("sfu-restart-ice", { transportId }, (err, data) => {
        if (err) return reject(err);
        resolve(data);
      });
    });

    const iceParameters = resp && resp.iceParameters;
    if (!iceParameters) throw new Error("missing iceParameters");
    if (typeof transport.restartIce !== "function") {
      throw new Error("transport.restartIce not available");
    }

    await transport.restartIce({ iceParameters });
    console.warn("[SFUTransport] ICE restart completed", { transportId });

    return true;
  }

  /**
   * Schedule ICE restart for disconnected transport.
   * @private
   * @param {Object} transport - Transport object
   * @param {string} transportId - Transport ID
   */
  scheduleIceRestart(transport, transportId) {
    const retrySeconds = this.getRetryTimerSeconds();
    if (!retrySeconds) return;

    transport._ejsDisconnectedRetryTimerSeconds = retrySeconds;
    transport._ejsDisconnectedRetryTimerId = setTimeout(() => {
      try {
        transport._ejsDisconnectedRetryTimerId = null;
        if (transport.closed) return;
        if (transport.connectionState !== "disconnected") return;
        this.requestIceRestart(transport, transportId);
      } catch (e) {}
    }, retrySeconds * 1000);
  }

  /**
   * Setup event handlers for transport connection state changes.
   * Handles ICE restart on connection failures.
   * @private
   * @param {Object} transport - Transport object
   * @param {string} transportId - Transport ID
   * @param {string} direction - Transport direction ('send', 'recv', 'send-video', etc.)
   */
  setupTransportEventHandlers(transport, transportId, direction) {
    transport.on("connectionstatechange", (state) => {
      console.log(`[SFUTransport] ${direction} transport state:`, state);

      if (state === "failed" || state === "closed") {
        console.warn(`[SFUTransport] ${direction} transport failed`);
      }
    });
  }

  /**
   * Clear ICE restart timer.
   * @private
   * @param {Object} transport - Transport object
   */
  clearIceRestartTimer(transport) {
    try {
      if (transport && transport._ejsDisconnectedRetryTimerId) {
        clearTimeout(transport._ejsDisconnectedRetryTimerId);
        transport._ejsDisconnectedRetryTimerId = null;
      }
    } catch (e) {}
  }

  /**
   * Wait for condition with timeout.
   * @private
   * @param {Function} condFn - Condition function
   * @param {number} timeout - Timeout in ms
   * @param {number} interval - Poll interval in ms
   * @returns {Promise<boolean>}
   */
  async waitFor(condFn, timeout = 5000, interval = 200) {
    const t0 = Date.now();
    while (!condFn() && Date.now() - t0 < timeout) {
      await new Promise((r) => setTimeout(r, interval));
    }
    return condFn();
  }

  /**
   * Create video producer (host only).
   * @param {MediaStreamTrack} videoTrack - Video track from canvas/screen capture
   * @returns {Promise<Object>} Video producer
   */
  async createVideoProducer(videoTrack) {
    if (!this.useSFU || !this.device) {
      throw new Error("SFU not available or device not initialized");
    }

    // Ensure video send transport exists
    if (!this.videoSendTransport) {
      await this.createSendTransport("video");
    }

    if (!this.videoSendTransport) {
      throw new Error("Video send transport not available");
    }

    try {
      // Pick codec
      const codec = this.pickVideoCodec();
      if (!codec) {
        throw new Error("No supported video codec available");
      }

      // Create producer on video transport
      this.videoProducer = await this.videoSendTransport.produce({
        track: videoTrack,
        codec: codec,
      });

      console.log("[SFUTransport] Created video producer:", {
        id: this.videoProducer.id,
        codec: codec.mimeType,
        transportId: this.videoSendTransport.id,
      });

      return this.videoProducer;
    } catch (error) {
      console.error("[SFUTransport] Failed to create video producer:", error);
      throw error;
    }
  }

  /**
   * Create audio producer (host only).
   * @param {MediaStreamTrack} audioTrack - Audio track
   * @returns {Promise<Object>} Audio producer
   */
  async createAudioProducer(audioTrack) {
    if (!this.useSFU || !this.device) {
      throw new Error("SFU not available or device not initialized");
    }

    // Ensure audio send transport exists (separate from video transport)
    if (!this.audioSendTransport) {
      await this.createSendTransport("audio");
    }

    if (!this.audioSendTransport) {
      throw new Error("Audio send transport not available");
    }

    try {
      // Create producer on dedicated audio transport
      // Configure Opus codec for optimal game audio streaming
      this.audioProducer = await this.audioSendTransport.produce({
        track: audioTrack,
        codecOptions: {
          opusStereo: true, // Enable stereo for game audio
          opusFec: true, // Forward Error Correction for reliability
          opusDtx: false, // Disable DTX to prevent sync drift
          opusPtime: 20, // 20ms packet time for optimal latency/bandwidth
        },
      });

      console.log("[SFUTransport] Created audio producer:", {
        id: this.audioProducer.id,
        transportId: this.audioSendTransport.id,
      });

      return this.audioProducer;
    } catch (error) {
      console.error("[SFUTransport] Failed to create audio producer:", error);
      throw error;
    }
  }

  /**
   * Create mic audio producer (voice chat).
   * @param {MediaStreamTrack} micTrack - Microphone audio track
   * @returns {Promise<Object>} Mic audio producer
   */
  async createMicAudioProducer(micTrack) {
    if (!this.useSFU || !this.device) {
      throw new Error("SFU not available or device not initialized");
    }

    // Ensure audio send transport exists (separate from video transport)
    if (!this.audioSendTransport) {
      await this.createSendTransport("audio");
    }

    if (!this.audioSendTransport) {
      throw new Error("Audio send transport not available");
    }

    try {
      // Create mic producer on dedicated audio transport
      // Configure Opus codec for voice chat (mono)
      this.micAudioProducer = await this.audioSendTransport.produce({
        track: micTrack,
        codecOptions: {
          opusStereo: false, // Mono for voice chat
          opusFec: true, // Forward Error Correction for reliability
          opusDtx: false, // Keep voice continuous
          opusPtime: 20, // 20ms packet time for voice latency
        },
      });

      console.log("[SFUTransport] Created mic audio producer:", {
        id: this.micAudioProducer.id,
        transportId: this.audioSendTransport.id,
      });

      return this.micAudioProducer;
    } catch (error) {
      console.error(
        "[SFUTransport] Failed to create mic audio producer:",
        error,
      );
      throw error;
    }
  }

  /**
   * Create data producer for input relay (host only).
   * @returns {Promise<Object>} Data producer
   */
  async createDataProducer() {
    if (!this.useSFU || !this.device) {
      throw new Error("SFU not available or device not initialized");
    }

    // Ensure data send transport exists (separate from video/audio transports)
    if (!this.dataSendTransport) {
      await this.createSendTransport("data");
    }

    if (!this.dataSendTransport) {
      throw new Error("Data send transport not available");
    }

    // Check if transport supports data channels
    if (typeof this.dataSendTransport.produceData !== "function") {
      console.warn("[SFUTransport] Transport does not support data channels");
      return null;
    }

    try {
      // Create data producer on dedicated data transport
      this.dataProducer = await this.dataSendTransport.produceData({
        ordered: false, // Unordered for better performance
        maxPacketLifeTime: 3000, // 3 second TTL for reliability
        label: "netplay-input", // Explicitly label for filtering
      });

      console.log("[SFUTransport] Created data producer:", {
        id: this.dataProducer.id,
        label: this.dataProducer.label,
        readyState: this.dataProducer.readyState,
        transportId: this.dataSendTransport.id,
      });

      // Set up data producer in DataChannelManager
      if (this.dataChannelManager) {
        this.dataChannelManager.setDataProducer(this.dataProducer);
      }

      return this.dataProducer;
    } catch (error) {
      console.error("[SFUTransport] Failed to create data producer:", error);
      throw error;
    }
  }

  /**
   * Create consumers for remote video/audio (clients only).
   * @param {string} producerId - Producer ID to consume
   * @param {string} kind - "video" or "audio"
   * @returns {Promise<Object>} Consumer
   */
  async createConsumer(producerId, kind) {
    if (!this.useSFU || !this.recvTransport || !this.device) {
      throw new Error("SFU not available or recv transport not created");
    }

    try {
      console.log(
        `[SFUTransport] Requesting consumer for producer ${producerId}, kind: ${kind}`,
      );

      let consumer;

      if (kind === "data") {
        // Data consumers use consumedata endpoint (different from video/audio)
        const consumerParams = await new Promise((resolve, reject) => {
          this.socket.emit(
            "consumedata",
            {
              dataProducerId: producerId,
              transportId: this.recvTransport.id,
            },
            (error, params) => {
              if (error) {
                console.error(
                  `[SFUTransport] SFU consume-data request failed for producer ${producerId}:`,
                  error,
                );
                reject(error);
              } else {
                console.log(
                  `[SFUTransport] Received consumer params from SFU for data producer ${producerId}:`,
                  params,
                );
                resolve(params);
              }
            },
          );
        });

        // Create data consumer locally using parameters from SFU
        consumer = await this.recvTransport.consumeData({
          id: consumerParams.id, // Add the missing id parameter
          dataProducerId: consumerParams.dataProducerId,
          sctpStreamParameters: consumerParams.sctpStreamParameters,
          label: consumerParams.label,
          protocol: consumerParams.protocol,
        });

        console.log(`[SFUTransport] Created data consumer:`, {
          id: consumer.id,
          label: consumer.label,
          paused: consumer.paused,
          readyState: consumer.readyState,
        });

        // Resume consumer if paused (mediasoup consumers start paused by default)
        if (consumer.paused) {
          console.log(
            `[SFUTransport] Resuming paused data consumer:`,
            consumer.id,
          );
          await consumer.resume();
          console.log(`[SFUTransport] Data consumer resumed:`, consumer.id);
        }

        // Set up message handling for data consumers
        if (this.dataChannelManager) {
          // Track consumer state
          consumer.on("transportclose", () => {
            console.log(
              `[SFUTransport] Data consumer transport closed:`,
              consumer.id,
            );
          });

          consumer.on("close", () => {
            console.log(`[SFUTransport] Data consumer closed:`, consumer.id);
          });

          consumer.on("open", () => {
            console.log(`[SFUTransport] Data consumer opened:`, consumer.id);
          });

          consumer.on("message", (message) => {
            console.log(
              `[SFUTransport] 📨 Data consumer received message:`,
              message,
            );
            console.log(
              `[SFUTransport] Message type: ${typeof message}, value:`,
              message,
            );
            // For SFU, we don't have the socketId mapping, so pass null
            this.dataChannelManager.handleIncomingMessage(message, null);
          });

          // Check ready state after a delay
          setTimeout(() => {
            console.log(`[SFUTransport] Data consumer state after delay:`, {
              id: consumer.id,
              label: consumer.label,
              readyState: consumer.readyState,
              paused: consumer.paused,
              closed: consumer.closed,
            });
          }, 2000);
        }
      } else {
        // Video/audio consumers use sfu-consume endpoint
        const consumerParams = await new Promise((resolve, reject) => {
          this.socket.emit(
            "sfu-consume",
            {
              producerId: producerId,
              transportId: this.recvTransport.id,
              rtpCapabilities: this.device.rtpCapabilities,
              ignoreDtx: kind === "audio", // Ignore DTX for audio consumers
            },
            (error, params) => {
              if (error) {
                console.error(
                  `[SFUTransport] SFU consume request failed for producer ${producerId}:`,
                  error,
                );
                reject(error);
              } else {
                console.log(
                  `[SFUTransport] Received consumer params from SFU for producer ${producerId}:`,
                  params,
                );
                resolve(params);
              }
            },
          );
        });

        // Create audio/video consumer locally using parameters from SFU
        // For audio consumers, ignore DTX packets to prevent sync drift
        const consumeOptions =
          kind === "audio"
            ? { ...consumerParams, ignoreDtx: true }
            : consumerParams;
        consumer = await this.recvTransport.consume(consumeOptions);
      }

      // Store consumer
      this.consumers.set(producerId, consumer);

      console.log(`[SFUTransport] Created ${kind} consumer:`, {
        producerId,
        consumerId: consumer.id,
      });

      // Start drift monitoring if enabled and not already running
      if (
        this.driftMonitoringEnabled &&
        !this.driftMonitoringInterval &&
        this.consumers.size > 0
      ) {
        this.startDriftMonitoring();
      }

      return consumer;
    } catch (error) {
      console.error(`[SFUTransport] Failed to create ${kind} consumer:`, error);
      throw error;
    }
  }

  /**
   * Start soft drift monitoring (logging only, no restarts).
   * Monitors consumer stats and logs warnings when drift exceeds thresholds.
   * @private
   */
  startDriftMonitoring() {
    if (this.driftMonitoringInterval) {
      return; // Already running
    }

    console.log(
      "[SFUTransport] Starting drift monitoring (soft monitoring only)",
    );

    // Monitor every 5 seconds
    this.driftMonitoringInterval = setInterval(() => {
      this.checkDrift();
    }, 5000);
  }

  /**
   * Stop drift monitoring.
   * @private
   */
  stopDriftMonitoring() {
    if (this.driftMonitoringInterval) {
      clearInterval(this.driftMonitoringInterval);
      this.driftMonitoringInterval = null;
      console.log("[SFUTransport] Stopped drift monitoring");
    }
  }

  /**
   * Check for drift in consumers and log warnings if thresholds exceeded.
   * This is soft monitoring - we log but don't restart transports.
   * @private
   */
  async checkDrift() {
    if (this.consumers.size === 0) {
      this.stopDriftMonitoring();
      return;
    }

    for (const [producerId, consumer] of this.consumers.entries()) {
      try {
        // Skip data consumers - they don't have getStats() method
        if (!consumer.getStats) {
          continue;
        }

        // Get consumer stats (only for video/audio consumers)
        const stats = await consumer.getStats();

        // Find audio/video stats
        for (const [id, stat] of stats.entries()) {
          if (stat.type === "inbound-rtp" && stat.kind) {
            const kind = stat.kind;
            const isAudio = kind === "audio";

            // Check jitter buffer (for audio, this is critical)
            if (isAudio && stat.jitter !== undefined) {
              const jitterMs = stat.jitter * 1000; // Convert to ms
              if (jitterMs > this.driftThresholds.audioJitterMs) {
                console.warn(
                  `[SFUTransport] Audio jitter high: ${jitterMs.toFixed(2)}ms (threshold: ${this.driftThresholds.audioJitterMs}ms)`,
                  {
                    producerId,
                    consumerId: consumer.id,
                  },
                );
              }
            }

            // Check packet loss
            if (
              stat.packetsLost !== undefined &&
              stat.packetsReceived !== undefined
            ) {
              const totalPackets = stat.packetsLost + stat.packetsReceived;
              if (totalPackets > 0) {
                const lossPercent = (stat.packetsLost / totalPackets) * 100;
                if (lossPercent > this.driftThresholds.packetLossPercent) {
                  console.warn(
                    `[SFUTransport] ${kind} packet loss high: ${lossPercent.toFixed(2)}% (threshold: ${this.driftThresholds.packetLossPercent}%)`,
                    {
                      producerId,
                      consumerId: consumer.id,
                      packetsLost: stat.packetsLost,
                      packetsReceived: stat.packetsReceived,
                    },
                  );
                }
              }
            }

            // Check round-trip time (if available)
            if (stat.roundTripTime !== undefined) {
              const rttMs = stat.roundTripTime * 1000;
              // Note: RTT drift detection would require baseline comparison
              // For now, just log if RTT is unusually high
              if (rttMs > 500) {
                console.warn(
                  `[SFUTransport] ${kind} RTT high: ${rttMs.toFixed(2)}ms`,
                  {
                    producerId,
                    consumerId: consumer.id,
                  },
                );
              }
            }
          }
        }
      } catch (error) {
        // Silently ignore stats errors (consumer may be closed)
        if (error.message && !error.message.includes("closed")) {
          console.debug(
            `[SFUTransport] Error getting stats for consumer ${producerId}:`,
            error.message,
          );
        }
      }
    }
  }

  /**
   * Cleanup all transports and resources.
   */
  async cleanup() {
    // Close producers
    if (this.videoProducer) {
      try {
        this.videoProducer.close();
      } catch (e) {}
      this.videoProducer = null;
    }
    if (this.audioProducer) {
      try {
        this.audioProducer.close();
      } catch (e) {}
      this.audioProducer = null;
    }
    if (this.dataProducer) {
      try {
        this.dataProducer.close();
      } catch (e) {}
      this.dataProducer = null;
    }

    // Stop drift monitoring
    this.stopDriftMonitoring();

    // Close consumers
    this.consumers.forEach((consumer) => {
      try {
        consumer.close();
      } catch (e) {}
    });
    this.consumers.clear();

    // Close transports
    if (this.videoSendTransport) {
      try {
        this.videoSendTransport.close();
      } catch (e) {}
      this.videoSendTransport = null;
    }
    if (this.audioSendTransport) {
      try {
        this.audioSendTransport.close();
      } catch (e) {}
      this.audioSendTransport = null;
    }
    if (this.dataSendTransport) {
      try {
        this.dataSendTransport.close();
      } catch (e) {}
      this.dataSendTransport = null;
    }
    if (this.sendTransport) {
      try {
        this.sendTransport.close();
      } catch (e) {}
      this.sendTransport = null;
    }
    if (this.recvTransport) {
      try {
        this.recvTransport.close();
      } catch (e) {}
      this.recvTransport = null;
    }

    this.device = null;
    this.useSFU = false;
  }
}

window.SFUTransport = SFUTransport;

/**
 * ChatComponent - In-game chat UI component
 *
 * Features:
 * - Docked/undocked chat interface
 * - Message formatting with sender continuation
 * - Emoji picker support
 * - Semi-transparent overlay
 * - Persistent chat when in rooms
 */

class ChatComponent {
  /**
   * @param {Object} emulator - The main emulator instance
   * @param {Object} netplayEngine - NetplayEngine instance
   * @param {Object} socketTransport - SocketTransport instance
   */
  constructor(emulator, netplayEngine, socketTransport) {
    this.emulator = emulator;
    this.netplayEngine = netplayEngine;
    this.socketTransport = socketTransport;

    // UI state
    this.isVisible = false;
    this.isDocked = true;
    this.isEmojiPickerVisible = false;

    // Message state
    this.messages = [];
    this.lastMessageSender = null;
    this.chatHistoryLoaded = false;

    // DOM elements
    this.chatTab = null;
    this.chatPanel = null;
    this.messagesContainer = null;
    this.inputField = null;
    this.sendButton = null;
    this.emojiButton = null;
    this.emojiPicker = null;
    this.undockButton = null;
    this.closeButton = null;

    // Drag state for undocked mode
    this.isDragging = false;
    this.dragOffset = { x: 0, y: 0 };

    // Resize state for undocked mode
    this.isResizing = false;
    this.resizeStart = { x: 0, y: 0, width: 0, height: 0 };

    // Bind methods
    this.handleMessage = this.handleMessage.bind(this);
    this.sendMessage = this.sendMessage.bind(this);
    this.toggleEmojiPicker = this.toggleEmojiPicker.bind(this);
    this.insertEmoji = this.insertEmoji.bind(this);
    this.toggleDock = this.toggleDock.bind(this);
    this.hide = this.hide.bind(this);
    this.handleKeyPress = this.handleKeyPress.bind(this);
    this.handleDragStart = this.handleDragStart.bind(this);
    this.handleDragMove = this.handleDragMove.bind(this);
    this.handleDragEnd = this.handleDragEnd.bind(this);
    this.handleResizeStart = this.handleResizeStart.bind(this);
    this.handleResizeMove = this.handleResizeMove.bind(this);
    this.handleResizeEnd = this.handleResizeEnd.bind(this);

    // Initialize UI
    this.createUI();

    // Load dock state from localStorage
    this.loadDockState();
  }

  /**
   * Create the chat UI elements
   */
  createUI() {
    // Create chat tab (right edge)
    this.chatTab = document.createElement('div');
    this.chatTab.className = 'ejs-chat-tab';
    this.chatTab.innerHTML = '💬';
    this.chatTab.title = 'Toggle Chat';
    this.chatTab.addEventListener('click', () => this.toggle());

    // Create chat panel
    this.chatPanel = document.createElement('div');
    this.chatPanel.className = 'ejs-chat-panel ejs-chat-docked';

    // Header with controls
    const header = document.createElement('div');
    header.className = 'ejs-chat-header';

    const title = document.createElement('div');
    title.className = 'ejs-chat-title';
    title.textContent = 'Room Chat';
    header.appendChild(title);

    this.undockButton = document.createElement('button');
    this.undockButton.className = 'ejs-chat-button ejs-chat-undock-btn';
    this.undockButton.innerHTML = '↗';
    this.undockButton.title = 'Undock Chat';
    this.undockButton.addEventListener('click', this.toggleDock);
    header.appendChild(this.undockButton);

    this.closeButton = document.createElement('button');
    this.closeButton.className = 'ejs-chat-button ejs-chat-close-btn';
    this.closeButton.innerHTML = '×';
    this.closeButton.title = 'Close Chat';
    this.closeButton.addEventListener('click', this.hide);
    header.appendChild(this.closeButton);

    this.chatPanel.appendChild(header);

    // Messages container
    this.messagesContainer = document.createElement('div');
    this.messagesContainer.className = 'ejs-chat-messages';
    this.chatPanel.appendChild(this.messagesContainer);

    // Input area
    const inputArea = document.createElement('div');
    inputArea.className = 'ejs-chat-input-area';

    this.emojiButton = document.createElement('button');
    this.emojiButton.className = 'ejs-chat-button ejs-chat-emoji-btn';
    this.emojiButton.innerHTML = '😀';
    this.emojiButton.title = 'Emoji Picker';
    this.emojiButton.addEventListener('click', this.toggleEmojiPicker);
    inputArea.appendChild(this.emojiButton);

    this.inputField = document.createElement('input');
    this.inputField.className = 'ejs-chat-input';
    this.inputField.type = 'text';
    this.inputField.placeholder = 'Type a message...';
    this.inputField.maxLength = 500;
    this.inputField.addEventListener('keypress', this.handleKeyPress);
    inputArea.appendChild(this.inputField);

    this.sendButton = document.createElement('button');
    this.sendButton.className = 'ejs-chat-button ejs-chat-send-btn';
    this.sendButton.innerHTML = 'Send';
    this.sendButton.addEventListener('click', this.sendMessage);
    inputArea.appendChild(this.sendButton);

    this.chatPanel.appendChild(inputArea);

    // Create emoji picker
    this.createEmojiPicker();

    // Add drag handles for undocked mode
    this.createDragHandles();

    // Initially hide everything
    this.chatTab.style.display = 'none';
    this.chatPanel.style.display = 'none';
    this.emojiPicker.style.display = 'none';

    // Add to document
    document.body.appendChild(this.chatTab);
    document.body.appendChild(this.chatPanel);
    document.body.appendChild(this.emojiPicker);
  }

  /**
   * Create the emoji picker component
   */
  createEmojiPicker() {
    this.emojiPicker = document.createElement('div');
    this.emojiPicker.className = 'ejs-emoji-picker';

    // Common emojis for gaming/netplay
    const emojis = [
      '😀', '😂', '😊', '😉', '😎', '🤔', '😮', '😢', '😭', '😤',
      '👍', '👎', '👌', '✌️', '🤞', '👏', '🙌', '🤝', '💪', '🙏',
      '❤️', '💔', '💯', '🔥', '⭐', '⚡', '💎', '🎮', '🎯', '🏆',
      '🎉', '🎊', '🎈', '🎁', '🏠', '🚀', '⚽', '🏀', '🎾', '🎲'
    ];

    emojis.forEach(emoji => {
      const emojiBtn = document.createElement('button');
      emojiBtn.className = 'ejs-emoji-button';
      emojiBtn.textContent = emoji;
      emojiBtn.addEventListener('click', () => this.insertEmoji(emoji));
      this.emojiPicker.appendChild(emojiBtn);
    });
  }

  /**
   * Create drag handles for undocked mode
   */
  createDragHandles() {
    // Drag handle for moving the undocked panel
    const dragHandle = document.createElement('div');
    dragHandle.className = 'ejs-chat-drag-handle';
    dragHandle.addEventListener('mousedown', this.handleDragStart);

    // Resize handle for bottom-right corner
    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'ejs-chat-resize-handle';
    resizeHandle.addEventListener('mousedown', this.handleResizeStart);

    this.chatPanel.appendChild(dragHandle);
    this.chatPanel.appendChild(resizeHandle);
  }

  /**
   * Show the chat interface
   */
  show() {
    if (this.isVisible) return;

    this.isVisible = true;
    this.chatTab.style.display = 'block';
    this.chatPanel.style.display = 'block';

    // Auto-open the panel when shown
    setTimeout(() => this.openPanel(), 100);

    // Focus input field
    setTimeout(() => this.inputField.focus(), 200);

    console.log('[ChatComponent] Chat shown');
  }

  /**
   * Hide the chat interface
   */
  hide() {
    if (!this.isVisible) return;

    this.isVisible = false;
    this.closePanel();

    // Hide after animation
    setTimeout(() => {
      this.chatTab.style.display = 'none';
      this.chatPanel.style.display = 'none';
    }, 300);

    console.log('[ChatComponent] Chat hidden');
  }

  /**
   * Toggle chat panel visibility
   */
  toggle() {
    if (this.chatPanel.classList.contains('ejs-chat-open')) {
      this.closePanel();
    } else {
      this.openPanel();
    }
  }

  /**
   * Open the chat panel
   */
  openPanel() {
    this.chatPanel.classList.add('ejs-chat-open');
    setTimeout(() => this.inputField.focus(), 200);
  }

  /**
   * Close the chat panel
   */
  closePanel() {
    this.chatPanel.classList.remove('ejs-chat-open');
    this.emojiPicker.style.display = 'none';
    this.isEmojiPickerVisible = false;
  }

  /**
   * Toggle docked/undocked state
   */
  toggleDock() {
    this.isDocked = !this.isDocked;

    if (this.isDocked) {
      // Switch to docked mode
      this.chatPanel.classList.remove('ejs-chat-undocked');
      this.chatPanel.classList.add('ejs-chat-docked');
      this.undockButton.innerHTML = '↗';
      this.undockButton.title = 'Undock Chat';
    } else {
      // Switch to undocked mode
      this.chatPanel.classList.remove('ejs-chat-docked');
      this.chatPanel.classList.add('ejs-chat-undocked');
      this.undockButton.innerHTML = '↙';
      this.undockButton.title = 'Dock Chat';

      // Set initial undocked position if not set
      if (!this.chatPanel.style.left && !this.chatPanel.style.top) {
        this.chatPanel.style.left = '50px';
        this.chatPanel.style.top = '50px';
        this.chatPanel.style.width = '400px';
        this.chatPanel.style.height = '300px';
      }
    }

    // Save dock state
    this.saveDockState();

    console.log(`[ChatComponent] Chat ${this.isDocked ? 'docked' : 'undocked'}`);
  }

  /**
   * Toggle emoji picker visibility
   */
  toggleEmojiPicker() {
    this.isEmojiPickerVisible = !this.isEmojiPickerVisible;
    this.emojiPicker.style.display = this.isEmojiPickerVisible ? 'block' : 'none';

    if (this.isEmojiPickerVisible) {
      // Position emoji picker below emoji button
      const buttonRect = this.emojiButton.getBoundingClientRect();
      this.emojiPicker.style.left = buttonRect.left + 'px';
      this.emojiPicker.style.bottom = (window.innerHeight - buttonRect.top + 10) + 'px';
    }
  }

  /**
   * Insert emoji at cursor position in input field
   */
  insertEmoji(emoji) {
    const start = this.inputField.selectionStart;
    const end = this.inputField.selectionEnd;
    const text = this.inputField.value;
    const before = text.substring(0, start);
    const after = text.substring(end);

    this.inputField.value = before + emoji + after;
    this.inputField.selectionStart = this.inputField.selectionEnd = start + emoji.length;
    this.inputField.focus();

    // Hide emoji picker after selection
    this.toggleEmojiPicker();
  }

  /**
   * Handle incoming chat messages
   */
  handleMessage(message) {
    console.log('[ChatComponent] Received message:', message);

    // Add message to local history
    this.messages.push(message);

    // Limit local message history
    if (this.messages.length > 100) {
      this.messages = this.messages.slice(-100);
    }

    // Add to UI
    this.addMessageToUI(message);

    // Auto-scroll to bottom if panel is open
    if (this.chatPanel.classList.contains('ejs-chat-open')) {
      setTimeout(() => {
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
      }, 100);
    }
  }

  /**
   * Add a message to the UI
   */
  addMessageToUI(message) {
    const messageDiv = document.createElement('div');
    messageDiv.className = 'ejs-chat-message';
    messageDiv.setAttribute('data-userid', message.userid);
    messageDiv.setAttribute('data-message-id', message.messageId);

    // Check if this is a continuation (same sender as previous message)
    const isContinuation = this.lastMessageSender === message.userid;

    if (!isContinuation) {
      // New sender - show name
      const senderSpan = document.createElement('span');
      senderSpan.className = 'ejs-chat-sender';
      senderSpan.textContent = message.playerName + ': ';
      messageDiv.appendChild(senderSpan);
    }

    // Add message text
    const textSpan = document.createElement('span');
    textSpan.className = 'ejs-chat-text';
    textSpan.textContent = message.message;
    messageDiv.appendChild(textSpan);

    // Add timestamp (optional, could be shown on hover)
    messageDiv.title = new Date(message.timestamp).toLocaleTimeString();

    this.messagesContainer.appendChild(messageDiv);

    // Update last sender for continuation logic
    this.lastMessageSender = message.userid;

    // Limit DOM nodes for performance
    while (this.messagesContainer.children.length > 100) {
      this.messagesContainer.removeChild(this.messagesContainer.firstChild);
    }
  }

  /**
   * Send a message
   */
  sendMessage() {
    const message = this.inputField.value.trim();
    if (!message) return;

    if (this.socketTransport && this.socketTransport.socket && this.socketTransport.socket.connected) {
      console.log('[ChatComponent] Sending message:', message);

      this.socketTransport.socket.emit('chat-message', {
        message: message
      });

      // Clear input
      this.inputField.value = '';
      this.inputField.focus();
    } else {
      console.warn('[ChatComponent] Cannot send message: socket not connected');
    }
  }

  /**
   * Handle key press in input field
   */
  handleKeyPress(event) {
    if (event.key === 'Enter') {
      event.preventDefault();
      this.sendMessage();
    } else if (event.key === 'Escape') {
      this.toggleEmojiPicker(); // Close emoji picker if open
    }
  }

  /**
   * Handle drag start for undocked panel
   */
  handleDragStart(event) {
    if (this.isDocked) return;

    this.isDragging = true;
    const rect = this.chatPanel.getBoundingClientRect();
    this.dragOffset.x = event.clientX - rect.left;
    this.dragOffset.y = event.clientY - rect.top;

    document.addEventListener('mousemove', this.handleDragMove);
    document.addEventListener('mouseup', this.handleDragEnd);

    event.preventDefault();
  }

  /**
   * Handle drag move
   */
  handleDragMove(event) {
    if (!this.isDragging) return;

    const newLeft = event.clientX - this.dragOffset.x;
    const newTop = event.clientY - this.dragOffset.y;

    // Constrain to viewport
    const rect = this.chatPanel.getBoundingClientRect();
    const constrainedLeft = Math.max(0, Math.min(window.innerWidth - rect.width, newLeft));
    const constrainedTop = Math.max(0, Math.min(window.innerHeight - rect.height, newTop));

    this.chatPanel.style.left = constrainedLeft + 'px';
    this.chatPanel.style.top = constrainedTop + 'px';
  }

  /**
   * Handle drag end
   */
  handleDragEnd() {
    this.isDragging = false;
    document.removeEventListener('mousemove', this.handleDragMove);
    document.removeEventListener('mouseup', this.handleDragEnd);
    this.saveDockState();
  }

  /**
   * Handle resize start
   */
  handleResizeStart(event) {
    if (this.isDocked) return;

    this.isResizing = true;
    const rect = this.chatPanel.getBoundingClientRect();
    this.resizeStart.x = event.clientX;
    this.resizeStart.y = event.clientY;
    this.resizeStart.width = rect.width;
    this.resizeStart.height = rect.height;

    document.addEventListener('mousemove', this.handleResizeMove);
    document.addEventListener('mouseup', this.handleResizeEnd);

    event.preventDefault();
  }

  /**
   * Handle resize move
   */
  handleResizeMove(event) {
    if (!this.isResizing) return;

    const deltaX = event.clientX - this.resizeStart.x;
    const deltaY = event.clientY - this.resizeStart.y;

    const newWidth = Math.max(300, this.resizeStart.width + deltaX);
    const newHeight = Math.max(200, this.resizeStart.height + deltaY);

    this.chatPanel.style.width = newWidth + 'px';
    this.chatPanel.style.height = newHeight + 'px';
  }

  /**
   * Handle resize end
   */
  handleResizeEnd() {
    this.isResizing = false;
    document.removeEventListener('mousemove', this.handleResizeMove);
    document.removeEventListener('mouseup', this.handleResizeEnd);
    this.saveDockState();
  }

  /**
   * Save dock state to localStorage
   */
  saveDockState() {
    const state = {
      isDocked: this.isDocked,
      left: this.chatPanel.style.left,
      top: this.chatPanel.style.top,
      width: this.chatPanel.style.width,
      height: this.chatPanel.style.height
    };
    localStorage.setItem('ejs-chat-dock-state', JSON.stringify(state));
  }

  /**
   * Load dock state from localStorage
   */
  loadDockState() {
    try {
      const state = JSON.parse(localStorage.getItem('ejs-chat-dock-state'));
      if (state) {
        this.isDocked = state.isDocked !== false; // Default to docked
        if (!this.isDocked && state.left && state.top) {
          this.chatPanel.style.left = state.left;
          this.chatPanel.style.top = state.top;
          this.chatPanel.style.width = state.width || '400px';
          this.chatPanel.style.height = state.height || '300px';
        }
      }
    } catch (e) {
      // Ignore localStorage errors
    }
  }

  /**
   * Clear all messages (for room changes)
   */
  clearMessages() {
    this.messages = [];
    this.lastMessageSender = null;
    this.messagesContainer.innerHTML = '';
  }

  /**
   * Cleanup and destroy the component
   */
  destroy() {
    this.hide();

    // Remove event listeners
    document.removeEventListener('mousemove', this.handleDragMove);
    document.removeEventListener('mouseup', this.handleDragEnd);
    document.removeEventListener('mousemove', this.handleResizeMove);
    document.removeEventListener('mouseup', this.handleResizeEnd);

    // Remove DOM elements
    if (this.chatTab && this.chatTab.parentNode) {
      this.chatTab.parentNode.removeChild(this.chatTab);
    }
    if (this.chatPanel && this.chatPanel.parentNode) {
      this.chatPanel.parentNode.removeChild(this.chatPanel);
    }
    if (this.emojiPicker && this.emojiPicker.parentNode) {
      this.emojiPicker.parentNode.removeChild(this.emojiPicker);
    }

    console.log('[ChatComponent] Destroyed');
  }
}
/**
 * NetplayEngine - Main orchestrator for netplay functionality
 *
 * Coordinates all netplay subsystems:
 * - Transport layer (SFU, Socket.IO, Data Channels)
 * - Input synchronization
 * - Room management
 * - Session state
 * - Configuration
 *
 * Note: This file uses direct class references instead of ES6 imports
 * to work with concatenated/minified builds. All dependencies must be
 * loaded before this file in the build order.
 */

// Dependencies are expected to be in global scope after concatenation:
// SocketTransport, SFUTransport, DataChannelManager, InputSync,
// SessionState, FrameCounter, ConfigManager, RoomManager, PlayerManager,
// MetadataValidator, GameModeManager, UsernameManager, SpectatorManager, SlotManager, ChatComponent

// #region agent log
try {
} catch (e) {
  console.error("Error in NetplayEngine.js instrumentation:", e);
}
// #endregion

class NetplayEngine {
  // Room mode and phase enums for DELAY_SYNC implementation
  static RoomMode = {
    LIVE_STREAM: "live_stream",
    DELAY_SYNC: "delay_sync",
  };

  static RoomPhase = {
    LOBBY: "lobby",
    PREPARE: "prepare",
    RUNNING: "running",
    ENDED: "ended",
  };

  /**
   * Get display name for ROM (for UI only, never for validation)
   * @returns {string}
   */
  getRomDisplayName() {
    // Priority: embedded title > filename without extension > fallback
    if (this.config.romTitle) {
      return this.config.romTitle;
    }

    const filename = this.config.romName || this.config.romFilename;
    if (filename) {
      // Strip extension
      return filename.replace(/\.[^/.]+$/, "");
    }

    return "Unknown ROM";
  }

  /**
   * @param {IEmulator} emulatorAdapter - Emulator adapter implementing IEmulator interface
   * @param {Object} config - Netplay configuration
   */
  constructor(emulatorAdapter, netplayMenu, config = {}) {
    this.emulator = emulatorAdapter;
    this.netplayMenu = netplayMenu;
    this.config = config || {};
    this.id = Math.random().toString(36).substr(2, 9); // Add unique ID for debugging
    console.log(`[NetplayEngine:${this.id}] Constructor called with config:`, {
      hasCallbacks: !!config.callbacks,
      callbackKeys: config.callbacks ? Object.keys(config.callbacks) : [],
      hasOnUsersUpdated: !!config.callbacks?.onUsersUpdated,
    });

    // Subsystems (initialized in initialize())
    this.configManager = null;
    this.sessionState = null;
    this.frameCounter = null;
    this.socketTransport = null;
    this.sfuTransport = null;
    this.dataChannelManager = null;
    this.gameModeManager = null;
    this.metadataValidator = null;
    this.usernameManager = null;
    this.slotManager = null;
    this.playerManager = null;
    this.spectatorManager = null;
    this.roomManager = null;
    this.inputSync = null;
    this.chatComponent = null;

    // Initialization state
    this._initialized = false;
  }

  // Helper method to get player name from token/cookies (same logic as NetplayMenu)
  getPlayerName() {
    let playerName = "Player"; // Default fallback

    try {
      // Get token from window.EJS_netplayToken or token cookie
      let token = window.EJS_netplayToken;
      if (!token) {
        // Try to get token from cookie
        const cookies = document.cookie.split(";");
        for (const cookie of cookies) {
          const [name, value] = cookie.trim().split("=");
          if (name === "romm_sfu_token" || name === "sfu_token") {
            token = decodeURIComponent(value);
            break;
          }
        }
      }

      if (token) {
        // Decode JWT payload to get netplay ID from 'sub' field
        // JWT uses base64url encoding, not standard base64, so we need to convert
        const base64UrlDecode = (str) => {
          // Convert base64url to base64 by replacing chars and adding padding
          let base64 = str.replace(/-/g, "+").replace(/_/g, "/");
          while (base64.length % 4) {
            base64 += "=";
          }

          // Decode base64 to binary string, then convert to proper UTF-8
          const binaryString = atob(base64);

          // Convert binary string to UTF-8 using TextDecoder if available, otherwise fallback
          if (typeof TextDecoder !== "undefined") {
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
            return new TextDecoder("utf-8").decode(bytes);
          } else {
            // Fallback for older browsers: this may not handle all UTF-8 correctly
            return decodeURIComponent(escape(binaryString));
          }
        };

        try {
          const payloadStr = base64UrlDecode(token.split(".")[1]);
          const payload = JSON.parse(payloadStr);

          if (payload.sub) {
            // Use the netplay ID as player name, truncate if too long (Unicode-safe)
            playerName = Array.from(payload.sub).slice(0, 20).join("");
          }
        } catch (parseError) {
          console.error(
            "[NetplayEngine] Failed to parse JWT payload:",
            parseError,
          );
        }
      }
    } catch (e) {
      console.warn(
        "[NetplayEngine] Failed to extract player name from token:",
        e,
      );
    }

    return playerName;
  }

  /**
   * Initialize the netplay engine and all subsystems.
   * @returns {Promise<void>}
   */
  async initialize() {
    if (this._initialized) {
      console.warn("[NetplayEngine] Already initialized");
      return;
    }

    try {
      // Check if dependencies are available (they should be after concatenation)
      if (typeof ConfigManager === "undefined") {
        throw new Error(
          "ConfigManager not available - modules may not be loaded correctly",
        );
      }

      // 1. Configuration Manager
      this.configManager = new ConfigManager(this.emulator, this.config);

      // 2. Session State
      this.sessionState = new SessionState();

      // 3. Frame Counter
      this.frameCounter = new FrameCounter(this.emulator);

      // 4. Game Mode Manager
      this.gameModeManager = new GameModeManager();

      // 5. Metadata Validator
      this.metadataValidator = new MetadataValidator(this.gameModeManager);

      // 6. Username Manager
      this.usernameManager = new UsernameManager();

      // 7. Slot Manager
      this.slotManager = new SlotManager(
        this.configManager?.loadConfig() || {},
      );

      // 8. Player Manager
      this.playerManager = new PlayerManager(this.slotManager);

      // 9. Socket Transport
      const socketCallbacks = {
        onConnect: (socketId) => {
          if (this.config.callbacks?.onSocketConnect) {
            this.config.callbacks.onSocketConnect(socketId);
          }
        },
        onConnectError: (error) => {
          if (this.config.callbacks?.onSocketError) {
            this.config.callbacks.onSocketError(error);
          }
        },
        onDisconnect: (reason) => {
          if (this.config.callbacks?.onSocketDisconnect) {
            this.config.callbacks.onSocketDisconnect(reason);
          }
        },
        onSocketReady: (callback) => {
          // Callback when socket is ready (for join room flow)
          if (this.socketTransport && this.socketTransport.isConnected()) {
            callback();
          } else {
            // Wait for connection
            const checkReady = () => {
              if (this.socketTransport && this.socketTransport.isConnected()) {
                callback();
              } else {
                setTimeout(checkReady, 100);
              }
            };
            checkReady();
          }
        },
      };
      this.socketTransport = new SocketTransport(
        {
          ...this.configManager?.loadConfig(),
          callbacks: socketCallbacks,
        },
        this.socketTransport, // Pass existing socket if reinitializing
      );

      // Connect the socket transport
      const sfuUrl =
        this.config.sfuUrl || this.config.netplayUrl || window.EJS_netplayUrl;
      if (!sfuUrl) {
        throw new Error("No SFU URL configured for socket connection");
      }

      // Get authentication token (same logic as listRooms)
      let token = window.EJS_netplayToken;
      if (!token) {
        // Try to get token from cookie
        const cookies = document.cookie.split(";");
        for (const cookie of cookies) {
          const [name, value] = cookie.trim().split("=");
          if (name === "romm_sfu_token" || name === "sfu_token") {
            token = decodeURIComponent(value);
            break;
          }
        }
      }

      console.log(
        "[NetplayEngine] Connecting socket to:",
        sfuUrl,
        token ? "(with auth token)" : "(no auth token)",
      );
      await this.socketTransport.connect(sfuUrl, token);

      // 10. SFU Transport
      this.sfuTransport = new SFUTransport(
        this.configManager?.loadConfig() || {},
        this.socketTransport,
      );

      // Initialize SFU transport (checks availability, loads device)
      const sfuAvailable = await this.sfuTransport.initialize();
      if (!sfuAvailable) {
        console.warn(
          "[NetplayEngine] SFU not available, continuing without WebRTC streaming",
        );
      }

      // 11. Data Channel Manager
      const inputMode =
        this.configManager?.getSetting("inputMode") ||
        this.config.inputMode ||
        "orderedRelay";
      console.log(
        "[NetplayEngine] 🎮 Initializing DataChannelManager with mode:",
        inputMode,
      );
      this.dataChannelManager = new DataChannelManager({
        mode: inputMode,
      });

      // Connect DataChannelManager to SFUTransport
      if (this.sfuTransport) {
        this.sfuTransport.dataChannelManager = this.dataChannelManager;
        console.log(
          "[NetplayEngine] Connected DataChannelManager to SFUTransport",
        );
      } else {
        console.warn(
          "[NetplayEngine] SFUTransport not available for DataChannelManager connection",
        );
      }

      // Input callback will be set up later in netplayJoinRoom or setupLiveStreamInputSync

      // 12. Spectator Manager
      this.spectatorManager = new SpectatorManager(
        this.configManager?.loadConfig() || {},
        this.socketTransport,
      );

      // 13. Room Manager
      // Set up callbacks for room events
      this.config.callbacks = {
        onPlayerSlotUpdated: (playerId, newSlot) => {
          console.log(
            `[NetplayEngine] onPlayerSlotUpdated callback called for player ${playerId} to slot ${newSlot}`,
          );
          if (this.netplayMenu && this.netplayMenu.netplayUpdatePlayerSlot) {
            this.netplayMenu.netplayUpdatePlayerSlot(playerId, newSlot);
          }
        },
        onUsersUpdated: (users) => {
          console.log(
            "[NetplayEngine] onUsersUpdated callback called with users:",
            Object.keys(users || {}),
          );
          if (this.netplayMenu && this.netplayMenu.netplayUpdatePlayerList) {
            this.netplayMenu.netplayUpdatePlayerList({ players: users });
          }
        },
        onPlayerReadyUpdated: (playerId, ready) => {
          console.log(
            `[NetplayEngine] onPlayerReadyUpdated callback called for player ${playerId}: ${ready}`,
          );
          if (this.netplayMenu && this.netplayMenu.netplayUpdatePlayerReady) {
            this.netplayMenu.netplayUpdatePlayerReady(playerId, ready);
          }
        },
        onPrepareStart: (data) => {
          console.log("[NetplayEngine] onPrepareStart callback called:", data);
          if (this.netplayMenu && this.netplayMenu.netplayHandlePrepareStart) {
            this.netplayMenu.netplayHandlePrepareStart(data);
          }
        },
        onGameStart: (data) => {
          console.log("[NetplayEngine] onGameStart callback called:", data);
          if (this.netplayMenu && this.netplayMenu.netplayHandleGameStart) {
            this.netplayMenu.netplayHandleGameStart(data);
          }
        },
        onPlayerValidationUpdated: (
          playerId,
          validationStatus,
          validationReason,
        ) => {
          console.log(
            `[NetplayEngine] onPlayerValidationUpdated callback called for ${playerId}: ${validationStatus}`,
          );
          if (
            this.netplayMenu &&
            this.netplayMenu.netplayUpdatePlayerValidation
          ) {
            this.netplayMenu.netplayUpdatePlayerValidation(
              playerId,
              validationStatus,
              validationReason,
            );
          }
        },
        onRoomClosed: (data) => {
          console.log("[NetplayEngine] Room closed:", data);
        },
      };
      this.roomManager = new RoomManager(
        this.socketTransport,
        { ...this.config, ...(this.configManager?.loadConfig() || {}) },
        this.sessionState,
      );
      this.roomManager.config.callbacks = this.config.callbacks;
      this.roomManager.setupEventListeners();

      // Create emulator adapter for InputSync
      const EmulatorJSAdapterClass =
        typeof EmulatorJSAdapter !== "undefined"
          ? EmulatorJSAdapter
          : typeof window !== "undefined" && window.EmulatorJSAdapter
            ? window.EmulatorJSAdapter
            : null;

      const emulatorAdapter = new EmulatorJSAdapterClass(this.emulator);

      // 14. Input Sync (initialize first, then get callback)
      // Create slot change callback to keep playerTable in sync
      const onSlotChanged = (playerId, slot) => {
        console.log(
          "[NetplayEngine] Slot changed via InputSync:",
          playerId,
          "-> slot",
          slot,
        );
        // Update playerTable through NetplayMenu if available
        if (this.emulator?.netplay?.menu) {
          this.emulator.netplay.menu.updatePlayerSlot(playerId, slot);
        }
      };

      // Create slot getter function for centralized slot management
      const getPlayerSlot = () => {
        const myPlayerId = this.sessionState?.localPlayerId;
        const joinedPlayers = this.emulator?.netplay?.joinedPlayers || [];
        // joinedPlayers is an array, find the player by ID
        const myPlayer = joinedPlayers.find(
          (player) => player.id === myPlayerId,
        );
        // If player found in joinedPlayers, use their slot; otherwise fall back to localSlot
        return myPlayer
          ? (myPlayer.slot ?? 0)
          : (this.emulator?.netplay?.localSlot ?? 0);
      };

      // Create config with slot getter callback for SimpleController
      const inputSyncConfig = {
        ...(this.configManager?.loadConfig() || {}),
        getCurrentSlot: getPlayerSlot,
      };

      this.inputSync = new InputSync(
        emulatorAdapter,
        inputSyncConfig,
        this.sessionState,
        null, // Will set callback after creation
        onSlotChanged,
      );

      // Get the callback from InputSync
      const sendInputCallback = this.inputSync.createSendInputCallback(
        this.dataChannelManager,
        this.configManager,
        this.emulator,
        this.socketTransport,
        getPlayerSlot,
      );

      // Set the callback on InputSync
      this.inputSync.sendInputCallback = sendInputCallback;

      // Setup data channel input receiver
      if (this.dataChannelManager) {
        console.log(
          "[NetplayEngine] Setting up DataChannelManager input receiver",
        );
        this.dataChannelManager.onInput(({ payload, fromSocketId }) => {
          console.log(
            "[NetplayEngine] 🔄 Received input from DataChannelManager:",
            {
              frame: payload.getFrame(),
              slot: payload.getSlot(),
              player: payload.p,
              input: payload.k,
              value: payload.v,
              fromSocketId,
            },
          );

          // Delegate to input sync for processing
          if (this.inputSync) {
            this.inputSync.handleRemoteInput(payload, fromSocketId);
          }
        });
      } else {
        console.warn(
          "[NetplayEngine] DataChannelManager not available for input receiver setup",
        );
      }

      // Setup socket data message handler for inputs
      if (this.socketTransport) {
        this.socketTransport.on("data-message", (data) => {
          this.handleDataMessage(data);
        });
      }

      // Setup spectator chat listeners
      if (this.spectatorManager) {
        this.spectatorManager.setupChatListeners();
      }

      // Setup frame callback for input processing
      if (this.emulator && typeof this.emulator.onFrame === "function") {
        this._frameUnsubscribe = this.emulator.onFrame((frame) => {
          // Process frame inputs (host only)
          if (this.sessionState?.isHostRole()) {
            this.processFrameInputs();
          }
        });
      }

      // Setup start event listener for producer setup (livestream hosts)
      if (this.emulator && typeof this.emulator.on === "function") {
        this.emulator.on("start", async () => {
          console.log(
            "[Netplay] Emulator start event received, checking if host should retry producer setup",
          );
          console.log("[Netplay] Current state:", {
            isHost: this.sessionState?.isHostRole(),
            netplayMode: this.emulator.netplay?.currentRoom?.netplay_mode,
          });

          // For livestream hosts, retry producer setup when game starts (in case initial setup failed)
          if (
            this.sessionState?.isHostRole() &&
            this.emulator.netplay?.currentRoom?.netplay_mode === 0
          ) {
            console.log(
              "[Netplay] Game started - retrying livestream producer setup",
            );

            try {
              // Check if we already have video/audio producers
              const hasVideoProducer = this.sfuTransport?.videoProducer;
              const hasAudioProducer = this.sfuTransport?.audioProducer;

              console.log("[Netplay] Current producer status:", {
                hasVideoProducer,
                hasAudioProducer,
              });

              // If we don't have video producer, try to create it now that canvas should be available
              if (!hasVideoProducer) {
                console.log("[Netplay] Retrying video producer creation...");
                try {
                  const videoTrack = await this.netplayCaptureCanvasVideo();
                  if (videoTrack) {
                    await this.sfuTransport.createVideoProducer(videoTrack);
                    console.log(
                      "[Netplay] ✅ Video producer created on game start",
                    );
                  } else {
                    console.warn("[Netplay] ⚠️ Still no video track available");
                  }
                } catch (videoError) {
                  console.error(
                    "[Netplay] ❌ Failed to create video producer on game start:",
                    videoError,
                  );
                }
              }

              // If we don't have audio producer, try to create it with retry logic
              if (!hasAudioProducer) {
                console.log("[Netplay] Retrying audio producer creation...");
                try {
                  let audioTrack = await this.waitForEmulatorAudio();
                  let retryCount = 0;
                  const maxRetries = 3;

                  // Retry audio capture a few times in case emulator audio isn't ready yet
                  while (!audioTrack && retryCount < maxRetries) {
                    console.log(
                      `[Netplay] Game start audio capture attempt ${retryCount + 1}/${maxRetries} failed, retrying in 1 second...`,
                    );
                    await new Promise((resolve) => setTimeout(resolve, 1000));
                    audioTrack = await this.waitForEmulatorAudio();
                    retryCount++;
                  }

                  if (audioTrack) {
                    await this.sfuTransport.createAudioProducer(audioTrack);
                    console.log(
                      "[Netplay] ✅ Audio producer created on game start",
                    );
                  } else {
                    console.warn(
                      "[Netplay] ⚠️ Still no audio track available after retries",
                    );
                  }
                } catch (audioError) {
                  console.error(
                    "[Netplay] ❌ Failed to create audio producer on game start:",
                    audioError,
                  );
                }
              }
            } catch (error) {
              console.error(
                "[Netplay] Failed to retry producer setup after game start:",
                error,
              );
            }
          } else {
            console.log(
              "[Netplay] Not retrying producers - not a livestream host",
            );
          }
        });
      }

      // 15. Chat Component (only if enabled)
      const chatEnabled =
        typeof window.EJS_NETPLAY_CHAT_ENABLED === "boolean"
          ? window.EJS_NETPLAY_CHAT_ENABLED
          : (this.config.netplayChatEnabled ??
            this.configManager?.getSetting("netplayChatEnabled") ??
            false);

      if (chatEnabled) {
        this.chatComponent = new ChatComponent(
          this.emulator,
          this,
          this.socketTransport,
        );
        console.log("[NetplayEngine] ChatComponent initialized");

        // Set up chat message forwarding from socket transport
        if (this.socketTransport && this.chatComponent) {
          this.socketTransport.setupChatForwarding(this.chatComponent);
          console.log("[NetplayEngine] Chat message forwarding configured");
        }
      } else {
        console.log(
          "[NetplayEngine] ChatComponent disabled (netplayChatEnabled = false)",
        );
      }

      this._initialized = true;
      console.log("[NetplayEngine] Initialized with all subsystems");
    } catch (error) {
      console.error("[NetplayEngine] Initialization failed:", error);
      throw error;
    }
  }

  /**
   * Handle incoming data message from Socket.IO.
   * @private
   * @param {Object} data - Data message
   */
  handleDataMessage(data) {
    // Handle sync-control inputs
    if (data["sync-control"]) {
      const isHost = this.sessionState?.isHostRole() || false;

      data["sync-control"].forEach((value) => {
        const inFrame = parseInt(value.frame, 10);
        if (!value.connected_input || value.connected_input[0] < 0) return;

        if (isHost) {
          // Host: Queue input for frame processing
          this.inputSync.receiveInput(
            inFrame,
            value.connected_input,
            value.fromPlayerId || null,
          );
        } else {
          // Client (live stream mode): Apply input immediately
          const [playerIndex, inputIndex, inputValue] = value.connected_input;
          console.log(
            `[NetplayEngine] Client applying socket input immediately: player ${playerIndex}, input ${inputIndex}, value ${inputValue}`,
          );
          try {
            this.emulator.simulateInput(playerIndex, inputIndex, inputValue);
            console.log(
              `[NetplayEngine] ✅ Socket input applied successfully to emulator`,
            );
          } catch (error) {
            console.error(
              `[NetplayEngine] ❌ Failed to apply socket input to emulator:`,
              error,
            );
          }
        }

        // Send frame acknowledgment
        if (this.socketTransport) {
          this.socketTransport.sendFrameAck(inFrame);
        }
      });
    }

    // Handle frame data (for frame reconstruction)
    if (data.frameData && this.config.callbacks?.onFrameData) {
      this.config.callbacks.onFrameData(data.frameData);
    }
  }

  /**
   * Process inputs for current frame (called each frame from emulator loop).
   * @returns {Array} Array of inputs to send to clients
   */
  processFrameInputs() {
    console.log("[NetplayEngine] 🎯 processFrameInputs() called");

    if (!this.inputSync || !this.sessionState?.isHostRole()) {
      console.log("[NetplayEngine] ❌ Skipping processFrameInputs:", {
        hasInputSync: !!this.inputSync,
        isHost: this.sessionState?.isHostRole(),
      });
      return [];
    }

    // Update frame counter
    if (this.emulator && this.frameCounter) {
      const emulatorFrame = this.emulator.getCurrentFrame();
      console.log("[NetplayEngine] 📊 Frame counter update:", {
        emulatorFrame,
        frameCounter: this.frameCounter.getCurrentFrame(),
      });

      this.frameCounter.setCurrentFrame(emulatorFrame);
      this.inputSync.updateCurrentFrame(emulatorFrame);

      // Debug: Check if we have queued inputs for this frame
      const queuedInputs = this.inputSync.inputsData[emulatorFrame];
      console.log("[NetplayEngine] 📋 Queued inputs check:", {
        frame: emulatorFrame,
        queuedCount: queuedInputs?.length || 0,
        hasQueuedInputs: !!(queuedInputs && queuedInputs.length > 0),
      });

      if (queuedInputs && queuedInputs.length > 0) {
        console.log(
          `[NetplayEngine] 📝 Processing ${queuedInputs.length} queued inputs for frame ${emulatorFrame}`,
        );
        queuedInputs.forEach((input, idx) => {
          console.log(`[NetplayEngine] 📝 Input ${idx + 1}:`, input);
        });
      }
    } else {
      console.log("[NetplayEngine] ⚠️  Missing emulator or frameCounter:", {
        hasEmulator: !!this.emulator,
        hasFrameCounter: !!this.frameCounter,
      });
    }

    // Process inputs for current frame
    console.log("[NetplayEngine] 🔄 Calling inputSync.processFrameInputs()");
    const processedInputs = this.inputSync.processFrameInputs();
    console.log("[NetplayEngine] ✅ inputSync.processFrameInputs() returned:", {
      processedCount: processedInputs?.length || 0,
      processedInputs,
    });

    if (processedInputs && processedInputs.length > 0) {
      console.log(
        `[NetplayEngine] 🎉 Processed ${processedInputs.length} inputs for frame processing`,
      );
    } else {
      console.log("[NetplayEngine] 😔 No inputs processed this frame");
    }

    return processedInputs;
  }

  /**
   * Get current session state object (for backward compatibility).
   * @returns {Object} State object compatible with this.netplay
   */
  getStateObject() {
    if (!this._initialized) {
      return {
        initialized: false,
      };
    }

    return {
      initialized: this._initialized,
      currentFrame: this.frameCounter?.getCurrentFrame() || 0,
      inputsData: this.inputSync?.inputsData || {},
      owner: this.sessionState?.isHostRole() || false,
      players: this.playerManager?.getPlayersObject() || {},
      socket: this.socketTransport?.socket || null,
      url: this.config.netplayUrl || null,
      // Add other backward-compatible properties as needed
    };
  }

  /**
   * Check if engine is initialized.
   * @returns {boolean}
   */
  isInitialized() {
    return this._initialized;
  }

  /**
   * Create a new room (host only).
   * @param {string} roomName - Room name
   * @param {number} maxPlayers - Maximum players
   * @param {string|null} password - Optional password
   * @param {Object} playerInfo - Player information
   * @returns {Promise<Object>} Room creation result
   */
  async createRoom(roomName, maxPlayers, password = null, playerInfo = {}) {
    if (!this.roomManager) {
      throw new Error("NetplayEngine not initialized");
    }
    return await this.roomManager.createRoom(
      roomName,
      maxPlayers,
      password,
      playerInfo,
    );
  }

  /**
   * Join an existing room.
   * @param {string} sessionId - Session/room ID
   * @param {string} roomName - Room name
   * @param {number} maxPlayers - Maximum players
   * @param {string|null} password - Optional password
   * @param {Object} playerInfo - Player information
   * @returns {Promise<Object>} Join result
   */
  async joinRoom(
    sessionId,
    roomName,
    maxPlayers,
    password = null,
    playerInfo = {},
  ) {
    if (!this.roomManager) {
      throw new Error("NetplayEngine not initialized");
    }
    return await this.roomManager.joinRoom(
      sessionId,
      roomName,
      maxPlayers,
      password,
      playerInfo,
    );
  }

  /**
   * Leave the current room.
   * @param {string|null} reason - Optional leave reason
   * @returns {Promise<void>}
   */
  async leaveRoom(reason = null) {
    if (!this.roomManager) {
      throw new Error("NetplayEngine not initialized - no roomManager");
    }
    return await this.roomManager.leaveRoom(reason);
  }
  /**
   * List available rooms.
   * @returns {Promise<Array>} Array of room objects
   */
  async listRooms() {
    // Use HTTP request to SFU /list endpoint (same as old netplayGetRoomList)
    const sfuUrl = this.config.netplayUrl || window.EJS_netplayUrl;
    if (!sfuUrl) {
      throw new Error("No SFU URL configured");
    }

    console.log("[NetplayEngine] Fetching room list from:", sfuUrl);

    // Build URL with authentication token
    const token = window.EJS_netplayToken;
    let url = `${sfuUrl}/list?domain=${window.location.host}&game_id=${this.config.gameId || ""}`;
    if (token) {
      url += `&token=${encodeURIComponent(token)}`;
    }

    const headers = {};
    if (!token) {
      // If no token in global var, try to get it from cookie
      const cookies = document.cookie.split(";");
      for (const cookie of cookies) {
        const [name, value] = cookie.trim().split("=");
        if (name === "romm_sfu_token" || name === "sfu_token") {
          headers["Authorization"] = `Bearer ${decodeURIComponent(value)}`;
          break;
        }
      }
    }

    const response = await fetch(url, { headers });
    console.log(
      `[NetplayEngine] Room list response status: ${response.status}`,
    );

    if (!response.ok) {
      console.warn(
        `[NetplayEngine] Room list fetch failed with status ${response.status}`,
      );
      return [];
    }

    const data = await response.json();
    console.log("[NetplayEngine] Raw server response:", data);

    // Convert server response format to expected format (same as netplayGetRoomList)
    const rooms = [];
    if (data && typeof data === "object") {
      console.log(
        "[NetplayEngine] Processing server data entries:",
        Object.keys(data),
      );
      Object.entries(data).forEach(([roomId, roomInfo]) => {
        console.log(`[NetplayEngine] Processing room ${roomId}:`, roomInfo);
        if (roomInfo && roomInfo.room_name) {
          const room = {
            id: roomId,
            name: roomInfo.room_name,
            current: roomInfo.current || 0,
            max: roomInfo.max || 4,
            hasPassword: roomInfo.hasPassword || false,
            netplay_mode: roomInfo.netplay_mode || 0,
            sync_config: roomInfo.sync_config || null,
            spectator_mode: roomInfo.spectator_mode || 1,
            rom_hash: roomInfo.rom_hash || null,
            core_type: roomInfo.core_type || null,
          };
          console.log(`[NetplayEngine] Added room to list:`, room);
          rooms.push(room);
        } else {
          console.log(
            `[NetplayEngine] Skipping room ${roomId} - missing room_name:`,
            roomInfo,
          );
        }
      });
    } else {
      console.log("[NetplayEngine] Server data is not an object:", data);
    }

    console.log("[NetplayEngine] Final parsed rooms array:", rooms);
    return rooms;
  }

  /**
   * Initialize SFU transports for host (create send transport).
   * @returns {Promise<void>}
   */
  async initializeHostTransports() {
    if (!this.sessionState?.isHostRole()) {
      throw new Error("Only host can initialize host transports");
    }

    try {
      console.log(
        "[Netplay] Initializing host transports (video, audio, data)...",
      );

      // Initialize SFU if needed
      if (!this.sfuTransport.useSFU) {
        await this.sfuTransport.initialize();
      }

      // Create single send transport for all media types (video, audio, data)
      await this.sfuTransport.createSendTransport("video"); // Creates the main send transport
      // Audio and data will reuse the same transport

      // Create receive transport for consuming data from clients
      await this.sfuTransport.createRecvTransport();

      console.log(
        "[Netplay] ✅ Host transports initialized (video, audio, data)",
      );
    } catch (error) {
      console.error("[Netplay] Failed to initialize host transports:", error);
      throw error;
    }
  }

  /**
   * Initialize SFU transports for client (create receive transport only).
   * @returns {Promise<void>}
   */
  async initializeClientTransports() {
    if (this.sessionState?.isHostRole()) {
      throw new Error("Host should use initializeHostTransports()");
    }

    try {
      console.log("[Netplay] Initializing client transports (receive only)...");

      // Initialize SFU if needed
      if (!this.sfuTransport.useSFU) {
        await this.sfuTransport.initialize();
      }

      // Create receive transport for consuming video/audio/data from host
      await this.sfuTransport.createRecvTransport();

      console.log("[Netplay] ✅ Client transports initialized (receive only)");
    } catch (error) {
      console.error("[Netplay] Failed to initialize client transports:", error);
      throw error;
    }
  }

  /**
   * Shutdown and cleanup all subsystems.
   * @returns {Promise<void>}
   */
  async shutdown() {
    if (!this._initialized) return;

    try {
      // Cleanup in reverse order
      if (this.spectatorManager) {
        this.spectatorManager.removeChatListeners();
        this.spectatorManager.clear();
      }

      if (this.inputSync) {
        this.inputSync.cleanup();
      }

      if (this.dataChannelManager) {
        this.dataChannelManager.cleanup();
      }

      if (this.sfuTransport) {
        await this.sfuTransport.cleanup();
      }

      if (this.socketTransport) {
        await this.socketTransport.disconnect();
      }

      if (this.roomManager) {
        // Room manager cleanup if needed
      }

      if (this.playerManager) {
        this.playerManager.clear();
      }

      if (this.sessionState) {
        this.sessionState.reset();
      }

      // Cleanup frame callback
      if (this._frameUnsubscribe) {
        this._frameUnsubscribe();
        this._frameUnsubscribe = null;
      }
    } catch (error) {
      console.error("[NetplayEngine] Shutdown error:", error);
    }

    this._initialized = false;
    console.log("[NetplayEngine] Shutdown complete");
  }

  async netplayGetRoomList() {
    try {
      console.log("[Netplay] Attempting to fetch room list...");

      // Build URL with authentication token
      const token = window.EJS_netplayToken;
      const baseUrl = window.EJS_netplayUrl || this.config.netplayUrl;

      if (!baseUrl) {
        console.error(
          "[Netplay] No netplay URL configured (window.EJS_netplayUrl or this.config.netplayUrl)",
        );
        return [];
      }

      let url = `${baseUrl}/list?domain=${window.location.host}&game_id=${this.config.gameId || ""}`;
      if (token) {
        url += `&token=${encodeURIComponent(token)}`;
      }

      console.log("[Netplay] Fetching room list from:", url);

      const headers = {};
      if (!token) {
        // If no token in global var, try to get it from cookie
        const cookies = document.cookie.split(";");
        for (const cookie of cookies) {
          const [name, value] = cookie.trim().split("=");
          if (name === "romm_sfu_token" || name === "sfu_token") {
            headers["Authorization"] = `Bearer ${decodeURIComponent(value)}`;
            break;
          }
        }
      }

      const response = await fetch(url, { headers });
      console.log(`[Netplay] Room list response status: ${response.status}`);

      if (!response.ok) {
        console.warn(`Room list fetch failed with status ${response.status}`);
        return [];
      }

      const data = await response.json();
      console.log("[Netplay] Raw server response:", data);

      // Convert server response format to expected format
      const rooms = [];
      if (data && typeof data === "object") {
        console.log(
          "[Netplay] Processing server data entries:",
          Object.keys(data),
        );
        Object.entries(data).forEach(([roomId, roomInfo]) => {
          console.log(`[Netplay] 🔍 Processing room ${roomId}:`, {
            roomInfo,
            netplay_mode: roomInfo?.netplay_mode,
            rom_name: roomInfo?.rom_name,
            rom_hash: roomInfo?.rom_hash,
            core_type: roomInfo?.core_type,
            allKeys: roomInfo ? Object.keys(roomInfo) : [],
          });
          if (roomInfo && roomInfo.room_name) {
            // Normalize netplay_mode (handle both string and number formats)
            const netplayMode =
              roomInfo.netplay_mode === "delay_sync" ||
              roomInfo.netplay_mode === 1
                ? "delay_sync"
                : "live_stream";

            const room = {
              id: roomId,
              name: roomInfo.room_name,
              current: roomInfo.current || 0,
              max: roomInfo.max || 4,
              hasPassword: roomInfo.hasPassword || false,
              netplay_mode: netplayMode, // Use normalized value
              sync_config: roomInfo.sync_config || null,
              spectator_mode: roomInfo.spectator_mode || 1,
              // Include all ROM and emulator metadata
              rom_hash: roomInfo.rom_hash || null,
              rom_name: roomInfo.rom_name || null,
              core_type: roomInfo.core_type || null,
              system: roomInfo.system || null,
              platform: roomInfo.platform || null,
              coreId: roomInfo.coreId || null,
              coreVersion: roomInfo.coreVersion || null,
              romHash: roomInfo.romHash || null,
              systemType: roomInfo.systemType || null,
            };
            console.log(`[Netplay] ✅ Added room to list with metadata:`, {
              id: room.id,
              netplay_mode: room.netplay_mode,
              rom_name: room.rom_name,
              rom_hash: room.rom_hash,
              core_type: room.core_type,
            });
            rooms.push(room);
          } else {
            console.log(
              `[Netplay] Skipping room ${roomId} - missing room_name:`,
              roomInfo,
            );
          }
        });
      } else {
        console.log("[Netplay] Server data is not an object:", data);
      }

      console.log("[Netplay] Final parsed rooms array:", rooms);
      return rooms;
    } catch (error) {
      console.error("[Netplay] Failed to get room list:", error);
      return [];
    }
  }
  // Helper method to create a room
  async netplayCreateRoom(
    roomName,
    maxPlayers,
    password,
    allowSpectators = true,
    roomType = "live_stream",
    frameDelay = 2,
    syncMode = "timeout",
  ) {
    const playerName = this.getPlayerName();
    if (!playerName || playerName === "Player") {
      throw new Error("Player name not set");
    }

    // CRITICAL: Ensure engine reference is set (it might be null after leaving a room)
    // Since this method is called on the NetplayEngine instance, 'this' IS the engine
    if (!this.emulator.netplay.engine) {
      console.log("[Netplay] Engine reference was null, restoring it");
      this.emulator.netplay.engine = this;
    }

    // Also ensure netplay.engine is set for consistency (used by NetplayMenu)
    if (
      this.netplayMenu &&
      this.netplayMenu.netplay &&
      !this.netplayMenu.netplay.engine
    ) {
      this.netplayMenu.netplay.engine = this;
    }

    // Use NetplayEngine if available
    if (this.emulator.netplay.engine) {
      console.log("[Netplay] Creating room via NetplayEngine:", {
        roomName,
        maxPlayers,
        password,
        allowSpectators,
        roomType,
      });

      // Initialize engine if not already initialized
      if (!this.isInitialized()) {
        console.log("[Netplay] Engine not initialized, initializing now...");
        try {
          await this.initialize();
          console.log("[Netplay] Engine initialized successfully");
        } catch (initError) {
          console.error("[Netplay] Engine initialization failed:", initError);
          throw new Error(
            `NetplayEngine initialization failed: ${initError.message}`,
          );
        }
      }

      // Prepare player info for engine
      const playerInfo = {
        player_name: playerName,
        player_slot: this.emulator.netplay.localSlot || 0,
        domain: window.location.host,
        // ✅ ADD ROM METADATA
        romHash: this.emulator.config.romHash,
        romName: this.emulator.config.romName,
        romFilename: this.emulator.config.romFilename,
        core: this.emulator.config.core,
        system: this.emulator.config.system,
        platform: this.emulator.config.platform,
        coreId: this.emulator.config.coreId,
        coreVersion: this.emulator.config.coreVersion,
        systemType: this.emulator.config.systemType,
      };

      // Add structured metadata for DELAY_SYNC rooms
      if (roomType === "delay_sync") {
        const emulatorId = this.config.system || this.config.core || "unknown";
        const EMULATOR_NAMES = {
          snes9x: "SNES9x",
          bsnes: "bsnes",
          mupen64plus: "Mupen64Plus",
          pcsx_rearmed: "PCSX-ReARMed",
          mednafen_psx: "Mednafen PSX",
          mednafen_snes: "Mednafen SNES",
          melonDS: "melonDS",
          citra: "Citra",
          dolphin: "Dolphin",
          ppsspp: "PPSSPP",
        };

        playerInfo.metadata = {
          rom: {
            displayName: this.getRomDisplayName(),
            hash: this.config.romHash
              ? {
                  algo: "sha256", // Assume SHA-256, could be configurable
                  value: this.config.romHash,
                }
              : null,
          },
          emulator: {
            id: emulatorId,
            displayName: EMULATOR_NAMES[emulatorId] || emulatorId,
            coreVersion: this.config.coreVersion || null,
          },
        };
      }

      // Add sync config for delay sync rooms
      if (roomType === "delay_sync") {
        playerInfo.sync_config = {
          frameDelay: frameDelay,
          syncMode: syncMode,
        };
      }

      // Add netplay_mode to playerInfo so it gets sent to server
      playerInfo.netplay_mode = roomType === "delay_sync" ? 1 : 0;
      playerInfo.room_phase =
        roomType === "delay_sync"
          ? NetplayEngine.RoomPhase.LOBBY
          : NetplayEngine.RoomPhase.RUNNING;

      try {
        const result = await this.createRoom(
          roomName,
          maxPlayers,
          password,
          playerInfo,
        );
        console.log("[Netplay] Room creation successful via engine:", result);

        this.emulator.netplay.engine.roomManager
          .updatePlayerMetadata(roomName, {
            coreId: this.emulator.config.system || null, // ✅ Emulator config
            coreVersion: this.emulator.config.coreVersion || null, // ✅ Emulator config
            romHash: this.emulator.config.romHash || null, // ✅ Emulator config
            systemType: this.emulator.config.system || null, // ✅ Emulator config
            platform: this.emulator.config.platform || null, // ✅ Emulator config
          })
          .catch((err) => {
            console.warn(
              "[NetplayEngine] Failed to update player metadata:",
              err,
            );
          });

        // Keep the room listing engine - it will be upgraded to a main engine

        // Store room info for later use
        this.emulator.netplay.currentRoomId = roomName; // RoomManager returns sessionid, but room ID is roomName
        this.emulator.netplay.currentRoom = {
          room_name: roomName,
          current: 1, // Creator is already joined
          max: maxPlayers,
          hasPassword: !!password,
          netplay_mode: roomType === "delay_sync" ? 1 : 0,
          room_phase:
            roomType === "delay_sync"
              ? NetplayEngine.RoomPhase.LOBBY
              : NetplayEngine.RoomPhase.RUNNING,
          sync_config:
            roomType === "delay_sync"
              ? {
                  frameDelay: frameDelay,
                  syncMode: syncMode,
                }
              : null,
          spectator_mode: allowSpectators ? 1 : 0,
          // Include detailed metadata for all room types
          metadata: {
            // Legacy fields for backward compatibility
            rom_hash: this.emulator.config.romHash || null,
            core_type: this.emulator.config.system || null, // ✅ Fix: use system
            system: this.emulator.config.system || null,
            platform: this.emulator.config.platform || null,
            coreId: this.emulator.config.system || null, // ✅ Fix: use system
            coreVersion: this.emulator.config.coreVersion || null,
            romHash: this.emulator.config.romHash || null,
            systemType: this.emulator.config.system || null,
            netplay_mode: roomType === "delay_sync" ? 1 : 0, // ✅ Add netplay_mode
          },
        };

        // For DELAY_SYNC, update room metadata after creation
        if (roomType === "delay_sync") {
          this.emulator.netplay.engine.roomManager
            .updateRoomMetadata(roomName, {
              // core, rom and system metadata
              rom_hash: this.emulator.config.romHash || null,
              rom_name:
                this.emulator.config.romName ||
                this.emulator.config.romFilename ||
                null,
              core_type: this.emulator.config.system || null, // Fixed
              system: this.emulator.config.system || null,
              platform: this.emulator.config.platform || null,
              coreId: this.emulator.config.system || null,
              coreVersion: this.emulator.config.coreVersion || null,
              romHash: this.emulator.config.romHash || null,
              systemType: this.emulator.config.system || null,
            })
            .catch((err) => {
              console.warn(
                "[NetplayEngine] Failed to update room metadata:",
                err,
              );
            });
        }
        // After room creation, join the room using unified join logic
        // This ensures host and guest use the same code path
        console.log(
          "[Netplay] Room created, now joining via unified join logic",
        );
        try {
          // Join the room we just created (host joins their own room)
          await this.netplayJoinRoom(
            roomName,
            !!password,
            roomType === "delay_sync" ? "delay_sync" : "live_stream",
          );
          console.log("[Netplay] Host successfully joined their own room");
        } catch (joinError) {
          console.error(
            "[Netplay] Failed to join room after creation:",
            joinError,
          );
          // Don't throw - room was created successfully, join failure is separate
          // The UI might already be switched by netplayJoinRoom
        }

        return result;
      } catch (error) {
        console.error("[Netplay] Room creation failed via engine:", error);
        throw error;
      }
    }

    // Fallback to old direct HTTP method if engine not available
    console.log(
      "[Netplay] NetplayEngine not available, falling back to direct HTTP",
    );

    // Determine netplay mode
    const netplayMode = roomType === "delay_sync" ? 1 : 0;

    // Create sync config for delay sync rooms
    let syncConfig = null;
    if (roomType === "delay_sync") {
      syncConfig = {
        frameDelay: frameDelay,
        syncMode: syncMode,
      };
    }

    // Determine spectator mode (1 = allow spectators, 0 = no spectators)
    const spectatorMode = allowSpectators ? 1 : 0;

    console.log("[Netplay] Creating room:", {
      roomName,
      maxPlayers,
      password,
      allowSpectators,
      roomType,
      netplayMode,
      syncConfig,
      spectatorMode,
    });

    // Request a write token from RomM for room creation
    console.log("[Netplay] Requesting write token for room creation...");
    let writeToken = null;
    try {
      // Try to get a write token from RomM
      const tokenResponse = await fetch("/api/sfu/token", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          // Include auth headers if available
        },
        body: JSON.stringify({ token_type: "write" }),
      });

      if (tokenResponse.ok) {
        const tokenData = await tokenResponse.json();
        writeToken = tokenData.token;
        console.log("[Netplay] Obtained write token for room creation");
      } else {
        console.warn(
          "[Netplay] Failed to get write token, falling back to existing token",
        );
      }
    } catch (error) {
      console.warn("[Netplay] Error requesting write token:", error);
    }

    // Send room creation request to SFU server
    const baseUrl = window.EJS_netplayUrl || this.config.netplayUrl;
    if (!baseUrl) {
      throw new Error("No netplay URL configured");
    }

    const createUrl = `${baseUrl}/create`;
    console.log("[Netplay] Sending room creation request to:", createUrl);

    const headers = {
      "Content-Type": "application/json",
    };

    // Add authentication - prefer write token, fallback to existing token
    const token = writeToken || window.EJS_netplayToken;
    if (token) {
      headers["Authorization"] = `Bearer ${token}`;
    } else {
      // Try to get token from cookie
      const cookies = document.cookie.split(";");
      for (const cookie of cookies) {
        const [name, value] = cookie.trim().split("=");
        if (name === "romm_sfu_token" || name === "sfu_token") {
          headers["Authorization"] = `Bearer ${decodeURIComponent(value)}`;
          break;
        }
      }
    }

    const roomData = {
      room_name: roomName,
      max_players: maxPlayers,
      password: password,
      allow_spectators: allowSpectators,
      netplay_mode: netplayMode,
      sync_config: syncConfig,
      spectator_mode: spectatorMode,
      domain: window.location.host,
      game_id: this.config.gameId || "",
      rom_hash: this.emulator.config.romHash || null,
      core_type: this.emulator.config.core || null,
      system: this.emulator.config.system || null,
      platform: this.emulator.config.platform || null,
      coreId: this.emulator.config.core || null,
      coreVersion: this.emulator.config.coreVersion || null,
      romHash: this.emulator.config.romHash || null,
      systemType: this.emulator.config.system || null,
    };

    console.log("[Netplay] Room creation payload:", roomData);

    const response = await fetch(createUrl, {
      method: "POST",
      headers,
      body: JSON.stringify(roomData),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(
        `[Netplay] Room creation failed with status ${response.status}:`,
        errorText,
      );
      throw new Error(`Room creation failed: ${response.status} ${errorText}`);
    }

    const result = await response.json();
    console.log("[Netplay] Room creation successful:", result);

    // Store room info for later use
    this.emulator.netplay.currentRoomId = result.room_id || result.id;
    this.emulator.netplay.currentRoom = result.room || result;

    // Switch to appropriate room UI
    if (roomType === "live_stream") {
      this.netplayMenu.netplaySwitchToLiveStreamRoom(roomName, password);
    } else if (roomType === "delay_sync") {
      this.netplayMenu.netplaySwitchToDelaySyncRoom(
        roomName,
        password,
        maxPlayers,
      );
    }

    // Note: Producer setup only available with NetplayEngine
  }

  // Helper method to set up WebRTC consumer transports
  // Called for all users to consume from other users' producers
  async netplaySetupConsumers() {
    console.log("[Netplay] 🎥 netplaySetupConsumers() called");
    console.log(
      "[Netplay] Current user is host:",
      this.emulator.netplay.engine?.sessionState?.isHostRole(),
    );
    console.log("[Netplay] Engine available:", !!this.emulator.netplay.engine);

    if (!this.emulator.netplay.engine) {
      console.warn("[Netplay] No engine available for consumer setup");
      return;
    }

    try {
      console.log("[Netplay] Setting up consumer transports...");

      // Ensure receive transport exists (both hosts and clients need this for bidirectional communication)
      const isHost = this.sessionState?.isHostRole();
      if (isHost) {
        // Hosts should already have receive transport from initializeHostTransports()
        // But make sure it's available
        await this.initializeHostTransports();
        console.log("[Netplay] ✅ Host receive transport ensured");
      } else {
        // Clients get receive transport
        await this.initializeClientTransports();
        console.log("[Netplay] ✅ Client receive transport created");
      }

      // First, get existing producers in the room
      console.log("[Netplay] Requesting existing producers...");
      try {
        if (this.socketTransport) {
          // Request existing video/audio producers
          const existingVideoAudioProducers = await new Promise(
            (resolve, reject) => {
              this.socketTransport.emit(
                "sfu-get-producers",
                {},
                (error, producers) => {
                  if (error) {
                    console.error(
                      "[Netplay] Failed to get existing video/audio producers:",
                      error,
                    );
                    reject(error);
                    return;
                  }
                  console.log(
                    "[Netplay] Received existing video/audio producers:",
                    producers,
                  );
                  resolve(producers || []);
                },
              );
            },
          );

          // Request existing data producers
          const existingDataProducers = await new Promise((resolve, reject) => {
            this.socketTransport.emit(
              "sfu-get-data-producers",
              {},
              (error, producers) => {
                if (error) {
                  console.error(
                    "[Netplay] Failed to get existing data producers:",
                    error,
                  );
                  reject(error);
                  return;
                }
                console.log(
                  "[Netplay] Received existing data producers:",
                  producers,
                );
                resolve(producers || []);
              },
            );
          });

          // Combine all producers - use actual kinds from SFU instead of defaulting to video
          const existingProducers = [
            ...existingVideoAudioProducers.map((p) => ({
              ...p,
              source: "video-audio",
              kind: p.kind || "unknown",
            })),
            // Clients should NOT consume host's data producers - they create their own data producers instead
            // Only hosts consume data producers from clients
            // ...existingDataProducers.map(p => ({ ...p, source: 'data', kind: p.kind || 'data' }))
          ];
          console.log(
            "[Netplay] Combined existing producers:",
            existingProducers,
          );

          // Create consumers for existing producers
          // Create consumers for existing producers
          for (const producer of existingProducers) {
            try {
              console.log(
                `[Netplay] Creating consumer for existing producer:`,
                producer,
              );

              try {
                // Create consumer based on producer kind
                const producerKind = producer.kind || "unknown";
                console.log(`[Netplay] Producer kind: ${producerKind}`);

                // Skip data producers for clients - clients create their own data producers
                if (producerKind === "data") {
                  console.log(
                    `[Netplay] Skipping data producer - clients don't consume host's data producers`,
                  );
                  continue;
                }

                if (producerKind === "video") {
                  const consumer = await this.sfuTransport.createConsumer(
                    producer.id,
                    "video",
                  );
                  console.log(
                    `[Netplay] ✅ Created video consumer for existing producer:`,
                    consumer.id,
                  );
                  if (consumer.track) {
                    // Use actual consumer kind returned by SFU, not assumed producer kind
                    this.netplayMenu.netplayAttachConsumerTrack(
                      consumer.track,
                      consumer.kind,
                    );
                  }
                } else if (producerKind === "audio") {
                  const consumer = await this.sfuTransport.createConsumer(
                    producer.id,
                    "audio",
                  );
                  console.log(
                    `[Netplay] ✅ Created audio consumer for existing producer:`,
                    consumer.id,
                  );
                  if (consumer.track) {
                    // Use actual consumer kind returned by SFU, not assumed producer kind
                    this.netplayMenu.netplayAttachConsumerTrack(
                      consumer.track,
                      consumer.kind,
                    );
                  }
                } else if (producerKind === "unknown") {
                  // Unknown kind - try to create consumer and use actual kind returned by SFU
                  console.log(
                    `[Netplay] Unknown producer kind, trying to create consumer to determine actual kind`,
                  );
                  try {
                    const consumer = await this.sfuTransport.createConsumer(
                      producer.id,
                      "video",
                    ); // Try video first
                    console.log(
                      `[Netplay] ✅ Created consumer for unknown producer:`,
                      consumer.id,
                      `actual kind: ${consumer.kind}`,
                    );
                    if (consumer.track) {
                      // Use actual consumer kind returned by SFU
                      this.netplayMenu.netplayAttachConsumerTrack(
                        consumer.track,
                        consumer.kind,
                      );
                    }
                  } catch (videoError) {
                    // If video fails, try audio
                    console.log(
                      `[Netplay] Video consumer failed, trying audio for unknown producer`,
                    );
                    try {
                      const consumer = await this.sfuTransport.createConsumer(
                        producer.id,
                        "audio",
                      );
                      console.log(
                        `[Netplay] ✅ Created audio consumer for unknown producer:`,
                        consumer.id,
                      );
                      if (consumer.track) {
                        this.netplayMenu.netplayAttachConsumerTrack(
                          consumer.track,
                          consumer.kind,
                        );
                      }
                    } catch (audioError) {
                      console.warn(
                        `[Netplay] Failed to create consumer for unknown producer ${producer.id}:`,
                        audioError.message,
                      );
                    }
                  }
                }
              } catch (error) {
                console.warn(
                  `[Netplay] Failed to create consumer for existing producer ${producer.id}:`,
                  error.message,
                );
                console.log(
                  `[Netplay] Producer may no longer exist (host may have left), skipping and waiting for new producers`,
                );
              }
            } catch (error) {
              console.warn(
                `[Netplay] Failed to create consumer for existing producer ${producer.id}:`,
                error.message,
              );
            }
          }
        }
      } catch (error) {
        console.warn("[Netplay] Failed to get existing producers:", error);
      }

      // Listen for new producers from any user (for bidirectional communication)
      console.log("[Netplay] Setting up new-producer event listener");
      if (this.socketTransport) {
        console.log(
          "[Netplay] Socket is connected:",
          this.socketTransport.isConnected(),
        );
        this.socketTransport.on("new-producer", async (data) => {
          console.log("[Netplay] 📡 RECEIVED new-producer event:", data);
          console.log("[Netplay] Producer details:", {
            id: data.id,
            kind: data.kind,
            socketId: this.socketTransport?.socket?.id,
            isHost: this.sessionState?.isHostRole(),
          });

          try {
            const producerId = data.id;
            const producerKind = data.kind; // Now provided by SFU server

            if (!producerKind) {
              console.warn(
                "[Netplay] Producer kind not provided, trying video, audio, then data",
              );
              // Try video first, then audio, then data if those fail
              try {
                const consumer = await this.sfuTransport.createConsumer(
                  producerId,
                  "video",
                );
                console.log(
                  `[Netplay] ✅ Created video consumer:`,
                  consumer.id,
                );
                if (consumer.track) {
                  console.log(`[Netplay] 🎥 Video track ready, attaching...`);
                  this.netplayMenu.netplayAttachConsumerTrack(
                    consumer.track,
                    "video",
                  );
                } else {
                  console.warn(
                    `[Netplay] ⚠️ Video consumer created but no track available`,
                  );
                }
              } catch (videoError) {
                console.log(
                  `[Netplay] Video consumer failed, trying audio:`,
                  videoError.message,
                );
                try {
                  const consumer = await this.sfuTransport.createConsumer(
                    producerId,
                    "audio",
                  );
                  console.log(
                    `[Netplay] ✅ Created audio consumer:`,
                    consumer.id,
                  );
                  if (consumer.track) {
                    console.log(`[Netplay] 🎵 Audio track ready, attaching...`);
                    this.netplayMenu.netplayAttachConsumerTrack(
                      consumer.track,
                      "audio",
                    );
                  } else {
                    console.warn(
                      `[Netplay] ⚠️ Audio consumer created but no track available`,
                    );
                  }
                } catch (audioError) {
                  // Don't try data - clients don't consume host's data producers
                  console.warn(
                    "[Netplay] Failed to create video/audio consumer, skipping (not data):",
                    audioError.message,
                  );
                }
              }
              return;
            }

            // Skip data producers for clients
            if (producerKind === "data") {
              console.log(
                `[Netplay] Skipping data producer - clients don't consume host's data producers`,
              );
              return;
            }

            console.log(
              `[Netplay] Creating ${producerKind} consumer for producer ${producerId}`,
            );
            const consumer = await this.sfuTransport.createConsumer(
              producerId,
              producerKind,
            );
            console.log(
              `[Netplay] ✅ Created ${producerKind} consumer:`,
              consumer.id,
            );

            if (consumer.track) {
              console.log(
                `[Netplay] 🎵 Consumer track ready: ${producerKind}`,
                {
                  trackId: consumer.track.id,
                  kind: consumer.track.kind,
                  enabled: consumer.track.enabled,
                  muted: consumer.track.muted,
                  readyState: consumer.track.readyState,
                },
              );
              this.netplayMenu.netplayAttachConsumerTrack(
                consumer.track,
                producerKind,
              );
            } else {
              console.warn(
                `[Netplay] ⚠️ Consumer created but no track available: ${producerKind}`,
              );
            }
          } catch (error) {
            console.error(
              "[Netplay] ❌ Failed to create consumer for new producer:",
              error,
            );
            console.error("[Netplay] Error details:", {
              message: error.message,
              stack: error.stack,
              producerId: data?.id,
              producerKind: data?.kind,
            });
          }
        });

        // Note: Clients don't listen for new-data-producer events since they don't consume host's data producers
        // Only hosts listen for new-data-producer events (implemented in netplaySetupDataConsumers)

        // Also listen for users-updated to track room changes
        this.socketTransport.on("users-updated", (users) => {
          console.log(
            "[Netplay] 👥 RECEIVED users-updated from consumer socket:",
            Object.keys(users || {}),
          );
        });
      } else {
        console.warn(
          "[Netplay] No socket transport available for consumer setup",
        );
      }
      console.log(
        "[Netplay] Consumer setup complete - listening for new producers",
      );

      // Periodically check for existing producers in case they were created after initial check
      // This handles race conditions where host creates producers before client sets up listener
      const checkForProducers = async () => {
        try {
          if (!this.socketTransport || !this.socketTransport.isConnected()) {
            return false; // Signal to stop checking
          }

          const existingVideoAudioProducers = await new Promise(
            (resolve, reject) => {
              this.socketTransport.emit(
                "sfu-get-producers",
                {},
                (error, producers) => {
                  if (error) {
                    reject(error);
                    return;
                  }
                  resolve(producers || []);
                },
              );
            },
          );

          if (existingVideoAudioProducers.length > 0) {
            console.log(
              "[Netplay] 🔍 Found existing producers on retry:",
              existingVideoAudioProducers,
            );
            let createdNewConsumer = false;

            // Create consumers for any producers we haven't consumed yet
            for (const producer of existingVideoAudioProducers) {
              const producerId = producer.id;
              const producerKind = producer.kind || "unknown";

              // Check if we already have a consumer for this producer
              const existingConsumer =
                this.sfuTransport?.consumers?.get(producerId);
              if (existingConsumer) {
                console.log(
                  `[Netplay] Already have consumer for producer ${producerId}, skipping`,
                );
                continue;
              }

              if (producerKind === "data") {
                continue; // Skip data producers
              }

              try {
                console.log(
                  `[Netplay] Creating consumer for existing producer found on retry:`,
                  producer,
                );
                const consumer = await this.sfuTransport.createConsumer(
                  producerId,
                  producerKind,
                );
                console.log(
                  `[Netplay] ✅ Created ${producerKind} consumer from retry:`,
                  consumer.id,
                );
                if (consumer.track) {
                  this.netplayMenu.netplayAttachConsumerTrack(
                    consumer.track,
                    producerKind,
                  );
                }
                createdNewConsumer = true;
              } catch (error) {
                console.warn(
                  `[Netplay] Failed to create consumer for producer ${producerId} on retry:`,
                  error.message,
                );
              }
            }

            // If we didn't create any new consumers, all producers are already consumed
            if (!createdNewConsumer) {
              console.log(
                "[Netplay] All existing producers already have consumers, stopping periodic check",
              );
              return false; // Signal to stop checking
            }
          } else {
            // No producers found, can stop checking
            console.log(
              "[Netplay] No existing producers found, stopping periodic check",
            );
            return false; // Signal to stop checking
          }
        } catch (error) {
          console.debug(
            "[Netplay] Error checking for producers on retry:",
            error.message,
          );
        }
      };

      const checkForProducersInterval = setInterval(() => {
        checkForProducers()
          .then((shouldStop) => {
            if (shouldStop === false) {
              clearInterval(checkForProducersInterval);
            }
          })
          .catch((err) => {
            console.debug(
              "[Netplay] Unhandled error in producer check interval:",
              err.message,
            );
          });
      }, 2000); // Check every 2 seconds

      // Clear interval after 30 seconds (producers should be created by then)
      setTimeout(() => {
        clearInterval(checkForProducersInterval);
        console.log("[Netplay] Stopped periodic producer check");
      }, 30000);
    } catch (error) {
      console.error("[Netplay] Consumer setup failed:", error);
    }
  }

  // Helper method to join a room
  async netplayJoinRoom(roomId, hasPassword, roomNetplayMode = null) {
    const playerName = this.getPlayerName();
    if (!playerName || playerName === "Player") {
      throw new Error("Player name not set");
    }

    let password = null;
    if (hasPassword) {
      password = prompt("Enter room password:");
      if (!password) return; // User cancelled
    }

    // Use NetplayEngine if available
    if (this.emulator.netplay.engine) {
      console.log("[Netplay] Joining room via NetplayEngine:", {
        roomId,
        password,
        roomNetplayMode,
      });

      // Initialize engine if not already initialized
      if (!this.isInitialized()) {
        console.log("[Netplay] Engine not initialized, initializing now...");
        try {
          await this.initialize();
          console.log("[Netplay] Engine initialized successfully");
        } catch (initError) {
          console.error("[Netplay] Engine initialization failed:", initError);
          throw new Error(
            `NetplayEngine initialization failed: ${initError.message}`,
          );
        }
      }

      // Prepare player info for engine
      const playerInfo = {
        player_name: playerName,
        player_slot: this.emulator.netplay.localSlot || 0,
        domain: window.location.host,
        // ✅ ADD ROM METADATA FOR COMPATIBILITY VALIDATION
        romHash: this.emulator.config.romHash || null,
        romName: this.emulator.config.romName || null,
        romFilename: this.emulator.config.romFilename || null,
        core: this.emulator.config.core || null,
        system: this.emulator.config.system || null,
        platform: this.emulator.config.platform || null,
        coreId:
          this.emulator.config.coreId || this.emulator.config.system || null,
        coreVersion: this.emulator.config.coreVersion || null,
        systemType:
          this.emulator.config.systemType ||
          this.emulator.config.system ||
          null,
      };

      try {
        // Check if we're joining a room we just created (room creator is always host)
        const wasRoomCreator = this.emulator.netplay.currentRoomId === roomId;

        const result = await this.joinRoom(
          null,
          roomId,
          4,
          password,
          playerInfo,
        );
        console.log("[Netplay] Room join successful via engine:", result);

        // CRITICAL: If we created this room, ensure we're marked as host
        // (joinRoom might have overwritten it based on server response)
        if (wasRoomCreator && this.sessionState) {
          console.log(
            "[Netplay] Room creator detected - ensuring host role is set",
          );
          this.sessionState.setHost(true);
        }

        // Store room info
        this.emulator.netplay.currentRoomId = roomId;

        // Ensure currentRoom has netplay_mode set (use roomNetplayMode from room list if available)
        if (this.emulator.netplay.currentRoom) {
          // Set netplay_mode from roomNetplayMode parameter or result
          if (roomNetplayMode !== null && roomNetplayMode !== undefined) {
            this.emulator.netplay.currentRoom.netplay_mode =
              roomNetplayMode === "delay_sync" || roomNetplayMode === 1
                ? "delay_sync"
                : "live_stream";
          } else if (!this.emulator.netplay.currentRoom.netplay_mode) {
            // Fallback: determine from result.netplay_mode
            this.emulator.netplay.currentRoom.netplay_mode =
              result.netplay_mode === "delay_sync" || result.netplay_mode === 1
                ? "delay_sync"
                : "live_stream";
          }
          console.log(
            `[Netplay] Stored currentRoom.netplay_mode: ${this.emulator.netplay.currentRoom.netplay_mode}`,
          );
        }

        // Immediately update player list with users from join result
        // Switch to appropriate room UI and setup based on room type
        // Use roomNetplayMode from room list, fallback to result.netplay_mode
        let roomType = "live_stream"; // default
        if (roomNetplayMode === "delay_sync" || roomNetplayMode === 1) {
          roomType = "delay_sync";
        } else if (
          result.netplay_mode === "delay_sync" ||
          result.netplay_mode === 1
        ) {
          roomType = "delay_sync";
        } else if (roomNetplayMode === "live_stream" || roomNetplayMode === 0) {
          roomType = "live_stream";
        } else if (
          result.netplay_mode === "live_stream" ||
          result.netplay_mode === 0
        ) {
          roomType = "live_stream";
        }

        console.log(
          `[Netplay] Determined room type: ${roomType} (from roomNetplayMode: ${roomNetplayMode}, result.netplay_mode: ${result.netplay_mode})`,
        );

        if (roomType === "live_stream") {
          this.netplayMenu.netplaySwitchToLiveStreamRoom(roomId, password);

          // LIVESTREAM ROOM: Set up WebRTC consumer transports
          // Both hosts and clients need consumers for data channels
          // Only clients need video/audio consumers from host
          // CRITICAL: Use this.sessionState (not this.emulator.netplay.engine.sessionState)
          // because 'this' IS the NetplayEngine instance
          const isHost = this.sessionState?.isHostRole();
          console.log(
            "[Netplay] After joining livestream room - isHost:",
            isHost,
            "sessionState.isHost:",
            this.sessionState?.isHost,
          );

          if (this.emulator.netplay.engine) {
            // PAUSE LOCAL EMULATOR FOR CLIENTS - they should watch the host's stream
            if (!isHost) {
              console.log(
                "[Netplay] Pausing local emulator for client - watching host stream",
              );
              try {
                if (
                  this.emulator.netplay.adapter &&
                  typeof this.emulator.netplay.adapter.pause === "function"
                ) {
                  this.emulator.netplay.adapter.pause();
                } else if (typeof this.emulator.pause === "function") {
                  this.emulator.pause();
                } else {
                  console.warn(
                    "[Netplay] Could not pause emulator - pause method not available",
                  );
                }
              } catch (error) {
                console.error("[Netplay] Failed to pause emulator:", error);
              }
            } else {
              // Host: Set up video/audio producers (with continuous retry)
              console.log(
                "[Netplay] Host: Setting up video/audio producers with continuous retry",
              );
              console.log("[Netplay] Host session state:", {
                isHost: this.sessionState?.isHostRole(),
                sessionState: this.sessionState,
              });

              // Start producer setup immediately
              this.netplaySetupProducers().catch((err) => {
                console.error("[Netplay] Initial producer setup failed:", err);
              });

              // Also set up continuous retry every 5 seconds for hosts in livestream rooms
              // This ensures producers get created even if canvas isn't available initially
              this._producerRetryInterval = setInterval(() => {
                if (
                  this.sessionState?.isHostRole() &&
                  this.emulator.netplay?.currentRoom?.netplay_mode === 0
                ) {
                  // Check if we have both video and audio producers
                  const hasVideo = this.sfuTransport?.videoProducer;
                  const hasAudio = this.sfuTransport?.audioProducer;

                  if (!hasVideo || !hasAudio) {
                    console.log(
                      "[Netplay] Host retrying producer setup - missing producers:",
                      { hasVideo, hasAudio },
                    );
                    this.netplaySetupProducers().catch((err) => {
                      console.debug(
                        "[Netplay] Producer retry failed:",
                        err.message,
                      );
                    });
                  } else {
                    console.log(
                      "[Netplay] Host has all producers, stopping retry",
                    );
                    clearInterval(this._producerRetryInterval);
                    this._producerRetryInterval = null;
                  }
                } else {
                  // No longer host or not in livestream room
                  if (this._producerRetryInterval) {
                    console.log(
                      "[Netplay] Stopping producer retry - no longer host or livestream room",
                    );
                    clearInterval(this._producerRetryInterval);
                    this._producerRetryInterval = null;
                  }
                }
              }, 5000);
            }

            console.log(
              "[Netplay] Setting up WebRTC consumer transports for data channels",
            );
            setTimeout(() => this.netplaySetupConsumers(), 1000);

            // Set up data producers for input
            // Host always sends input, clients send input if they have a player slot assigned
            const currentPlayerSlot = this.emulator.netplay.localSlot;
            const hasPlayerSlot =
              currentPlayerSlot !== undefined &&
              currentPlayerSlot !== null &&
              currentPlayerSlot >= 0;

            // Always set up data consumers (to receive inputs from host/other clients)
            console.log(
              "[Netplay] Setting up data consumers for live stream room",
            );
            setTimeout(() => {
              this.netplaySetupConsumers().catch((err) => {
                console.error("[Netplay] Failed to setup consumers:", err);
              });
            }, 1000);

            // Set up data producers for clients who have player slots (to send inputs to host)
            if (hasPlayerSlot) {
              console.log(
                "[Netplay] Client has player slot, setting up data producers for input",
              );
              setTimeout(() => {
                this.netplaySetupDataProducers().catch((err) => {
                  console.error(
                    "[Netplay] Failed to setup data producers:",
                    err,
                  );
                });
              }, 1500);

              // Check if P2P mode is enabled and initiate P2P connection
              // First check emulator settings, then configManager, then DataChannelManager mode
              const emulatorInputMode =
                this.emulator?.getSettingValue?.("netplayInputMode") ||
                this.emulator?.netplayInputMode;
              const configInputMode =
                this.configManager?.getSetting("netplayInputMode");
              const dataChannelMode = this.dataChannelManager?.mode;
              const inputMode =
                emulatorInputMode ||
                configInputMode ||
                dataChannelMode ||
                this.config.inputMode ||
                "orderedRelay";

              console.log(
                `[Netplay] P2P mode check: emulator=${emulatorInputMode}, config=${configInputMode}, dataChannel=${dataChannelMode}, final=${inputMode}`,
              );

              console.log(
                `[Netplay] Client checking P2P setup: mode=${inputMode}, hasSlot=${hasPlayerSlot}`,
              );

              if (
                (inputMode === "unorderedP2P" || inputMode === "orderedP2P") &&
                hasPlayerSlot
              ) {
                console.log(
                  `[Netplay] Client input mode is ${inputMode}, initiating P2P connection to host...`,
                );
                setTimeout(() => {
                  this.netplayInitiateP2PConnection().catch((err) => {
                    console.error(
                      "[Netplay] Failed to initiate P2P connection:",
                      err,
                    );
                  });
                }, 2000);
              } else {
                console.log(
                  `[Netplay] Client not setting up P2P: mode=${inputMode}, hasSlot=${hasPlayerSlot}`,
                );
              }
            } else {
              console.log(
                "[Netplay] Client has no player slot assigned - spectator mode",
              );
            }
          }
          // Note: Video/audio consumption is handled by new-producer events
        } else if (roomType === "delay_sync") {
          this.netplayMenu.netplaySwitchToDelaySyncRoom(roomId, password, 4); // max players not returned, default to 4

          // DELAY SYNC ROOM: Set up bidirectional WebRTC communication
          if (this.emulator.netplay.engine) {
            console.log(
              "[Netplay] Setting up WebRTC transports for delay-sync bidirectional communication",
            );
            setTimeout(() => this.netplaySetupConsumers(), 1000);

            // Set up data producers for input (everyone needs to send inputs)
            console.log("[Netplay] Setting up data producers for input");
            setTimeout(() => this.netplaySetupDataProducers(), 1500);
          }
        }

        // Show chat component after successful room join (only if enabled)
        if (this.chatComponent) {
          console.log("[Netplay] Showing chat component after room join");
          this.chatComponent.clearMessages(); // Clear any previous messages
          this.chatComponent.show();
        }

        return result;
      } catch (error) {
        console.error("[Netplay] Room join failed via engine:", error);
        throw error;
      }
    }

    // Fallback to old direct HTTP method if engine not available
    console.log(
      "[Netplay] NetplayEngine not available, falling back to direct HTTP",
    );

    console.log("[Netplay] Joining room:", { roomId, password });

    // Request a write token from RomM for room joining
    console.log("[Netplay] Requesting write token for room joining...");
    let writeToken = null;
    try {
      const tokenResponse = await fetch("/api/sfu/token", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ token_type: "write" }),
      });

      if (tokenResponse.ok) {
        const tokenData = await tokenResponse.json();
        writeToken = tokenData.token;
        console.log("[Netplay] Obtained write token for room joining");
      } else {
        console.warn(
          "[Netplay] Failed to get write token, falling back to existing token",
        );
      }
    } catch (error) {
      console.warn("[Netplay] Error requesting write token:", error);
    }

    // Send room join request to SFU server
    const baseUrl = window.EJS_netplayUrl || this.config.netplayUrl;
    if (!baseUrl) {
      throw new Error("No netplay URL configured");
    }

    const joinUrl = `${baseUrl}/join/${roomId}`;
    console.log("[Netplay] Sending room join request to:", joinUrl);

    const headers = {
      "Content-Type": "application/json",
    };

    // Add authentication - prefer write token, fallback to existing token
    const token = writeToken || window.EJS_netplayToken;
    if (token) {
      headers["Authorization"] = `Bearer ${token}`;
    } else {
      // Try to get token from cookie
      const cookies = document.cookie.split(";");
      for (const cookie of cookies) {
        const [name, value] = cookie.trim().split("=");
        if (name === "romm_sfu_token" || name === "sfu_token") {
          headers["Authorization"] = `Bearer ${decodeURIComponent(value)}`;
          break;
        }
      }
    }

    const joinData = {
      password: password,
      player_name: this.emulator.netplay.getNetplayId(),
      domain: window.location.host,
    };

    console.log("[Netplay] Room join payload:", joinData);

    const response = await fetch(joinUrl, {
      method: "POST",
      headers,
      body: JSON.stringify(joinData),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(
        `[Netplay] Room join failed with status ${response.status}:`,
        errorText,
      );
      throw new Error(`Room join failed: ${response.status} ${errorText}`);
    }

    const result = await response.json();
    console.log("[Netplay] Room join successful:", result);

    // Store room info
    this.emulator.netplay.currentRoomId = roomId;
    this.emulator.netplay.currentRoom = result.room || result;

    // Switch to appropriate room UI based on room type
    const roomType =
      result.room?.netplay_mode === 1 ? "delay_sync" : "live_stream";
    if (roomType === "live_stream") {
      this.netplayMenu.netplaySwitchToLiveStreamRoom(
        result.room?.room_name || "Unknown Room",
        password,
      );
    } else if (roomType === "delay_sync") {
      this.netplayMenu.netplaySwitchToDelaySyncRoom(
        result.room?.room_name || "Unknown Room",
        password,
        result.room?.max || 4,
      );
    }
  }

  // Initialize the netplay engine for real-time communication
  async netplayInitializeEngine(roomName) {
    console.log("[Netplay] Initializing netplay engine for room:", roomName);

    // Set up netplay simulateInput if not already done (always needed)
    if (!this.emulator.netplay.simulateInput) {
      this.emulator.netplay.simulateInput = (
        playerIndex,
        inputIndex,
        value,
      ) => {
        // In netplay, use the local player's slot from centralized playerTable
        const myPlayerId =
          this.emulator.netplay?.engine?.sessionState?.localPlayerId;
        const joinedPlayers = this.emulator.netplay?.joinedPlayers || [];
        // joinedPlayers is an array, find the player by ID
        const myPlayer = joinedPlayers.find(
          (player) => player.id === myPlayerId,
        );
        // If player found in joinedPlayers, use their slot; otherwise fall back to localSlot
        const mySlot = myPlayer
          ? (myPlayer.slot ?? 0)
          : (this.emulator.netplay?.localSlot ?? 0);

        console.log("[Netplay] Processing input via netplay.simulateInput:", {
          originalPlayerIndex: playerIndex,
          mySlot,
          inputIndex,
          value,
        });
        if (this.emulator.netplay.engine && this.inputSync) {
          console.log(
            "[Netplay] Sending input through InputSync using player table slot:",
            mySlot,
          );
          return this.inputSync.sendInput(mySlot, inputIndex, value);
        } else {
          console.warn("[Netplay] InputSync not available, input ignored");
          return false;
        }
      };
      console.log("[Netplay] Set up netplay.simulateInput");
    }

    // Check if we have an existing engine that can be upgraded
    const hasExistingEngine =
      this.emulator.netplay.engine && this.isInitialized();
    const existingIsRoomListing =
      this.emulator.netplay.engine?.config?.isRoomListing === true;
    const existingIsMain =
      this.emulator.netplay.engine?.config?.isRoomListing === false;

    console.log(
      `[Netplay] Checking existing engine: exists=${!!this.emulator.netplay.engine}, initialized=${hasExistingEngine}, isRoomListing=${existingIsRoomListing}, isMain=${existingIsMain}`,
    );

    if (existingIsMain) {
      console.log(
        "[Netplay] Main NetplayEngine already initialized, skipping setup",
      );
      return;
    }

    // If we have a room listing engine, upgrade it to a main engine
    if (hasExistingEngine && existingIsRoomListing) {
      console.log("[Netplay] Upgrading room listing engine to main engine");
      // Update the engine's config to main engine settings
      this.config.isRoomListing = false;
      this.config.callbacks = {
        onSocketConnect: (socketId) => {
          console.log("[Netplay] Socket connected:", socketId);
        },
        onSocketError: (error) => {
          console.error("[Netplay] Socket error:", error);
        },
        onSocketDisconnect: (reason) => {
          console.log("[Netplay] Socket disconnected:", reason);
        },
        onPlayerSlotUpdated: (playerId, newSlot) => {
          if (this.netplayMenu?.netplayUpdatePlayerSlot) {
            this.netplayMenu.netplayUpdatePlayerSlot(playerId, newSlot);
          }
        },
        onUsersUpdated: (users) => {
          this.netplayMenu.netplayUpdatePlayerList({ players: users });
        },
        onRoomClosed: (data) => {
          console.log("[Netplay] Room closed:", data);
        },
      };

      // Update the RoomManager's config as well
      if (this.roomManager) {
        this.roomManager.config.isRoomListing = false;
        this.roomManager.config.callbacks = this.config.callbacks;
      }

      // Re-setup event listeners with the new config
      if (this.roomManager) {
        this.roomManager.setupEventListeners();
      }
      return;
    }

    try {
      // Netplay modules should already be loaded globally

      // Get netplay classes
      const NetplayEngineClass =
        typeof NetplayEngine !== "undefined"
          ? NetplayEngine
          : typeof window !== "undefined" && window.NetplayEngine
            ? window.NetplayEngine
            : null;

      const EmulatorJSAdapterClass =
        typeof EmulatorJSAdapter !== "undefined"
          ? EmulatorJSAdapter
          : typeof window !== "undefined" && window.EmulatorJSAdapter
            ? window.EmulatorJSAdapter
            : null;

      const SocketTransportClass =
        typeof SocketTransport !== "undefined"
          ? SocketTransport
          : typeof window !== "undefined" && window.SocketTransport
            ? window.SocketTransport
            : null;

      if (
        !NetplayEngineClass ||
        !EmulatorJSAdapterClass ||
        !SocketTransportClass
      ) {
        console.error("[Netplay] CRITICAL: Netplay classes not found!");
        console.error(
          "[Netplay] The emulator files served by RomM do not include netplay support.",
        );
        console.error("[Netplay] You need to:");
        console.error(
          "[Netplay] 1. Build EmulatorJS with netplay: cd EmulatorJS-SFU && npm run minify",
        );
        console.error("[Netplay] 2. Copy the built files to RomM:");
        console.error(
          "[Netplay]    cp EmulatorJS-SFU/data/emulator.min.js RomM/frontend/public/assets/emulatorjs/",
        );
        console.error(
          "[Netplay]    cp EmulatorJS-SFU/data/emulator.hybrid.min.js RomM/frontend/public/assets/emulatorjs/",
        );
        console.error(
          "[Netplay]    cp EmulatorJS-SFU/data/emulator.min.css RomM/frontend/public/assets/emulatorjs/",
        );
        console.error("[Netplay] 3. Restart RomM");
        console.log(
          "[Netplay] Available globals:",
          Object.keys(typeof window !== "undefined" ? window : global),
        );
        return;
      }

      // Create socket transport
      const socketUrl = this.config.netplayUrl || window.EJS_netplayUrl;
      if (!socketUrl) {
        console.error("[Netplay] No socket URL available for netplay engine");
        return;
      }

      // Extract base URL for WebSocket connection (remove protocol and path)
      let socketBaseUrl = socketUrl;
      if (socketBaseUrl.startsWith("http://")) {
        socketBaseUrl = socketBaseUrl.substring(7);
      } else if (socketBaseUrl.startsWith("https://")) {
        socketBaseUrl = socketBaseUrl.substring(8);
      }
      // Remove any path after the domain
      const pathIndex = socketBaseUrl.indexOf("/");
      if (pathIndex > 0) {
        socketBaseUrl = socketBaseUrl.substring(0, pathIndex);
      }

      // Create emulator adapter
      const adapter = new EmulatorJSAdapterClass(this);

      // Create netplay engine (let it create its own transport)
      const engine = new NetplayEngineClass(adapter, {
        sfuUrl: socketUrl, // Pass the SFU URL so the engine can create the transport
        roomName,
        playerIndex: this.emulator.netplay.localSlot || 0,
        isRoomListing: false, // This is the main netplay engine
        callbacks: {
          onSocketConnect: (socketId) => {
            console.log("[Netplay] Socket connected:", socketId);

            // Event listeners are now handled by NetplayEngine's callback system
            // The onUsersUpdated callback in the engine config will handle player table updates

            // Now join the room via Socket.IO
            setTimeout(
              () => this.netplayMenu.netplayJoinRoomViaSocket(roomName),
              100,
            );
          },
          onSocketError: (error) => {
            console.error("[Netplay] Socket error:", error);
          },
          onSocketDisconnect: (reason) => {
            console.log("[Netplay] Socket disconnected:", reason);
            if (this.netplayMenu?.cleanupRoomUI) {
              this.netplayMenu?.cleanupRoomUI();
            }
          },
          onPlayerSlotUpdated: (playerId, newSlot) => {
            if (this.netplayMenu?.netplayUpdatePlayerSlot) {
              this.netplayMenu.netplayUpdatePlayerSlot(playerId, newSlot);
            }
          },
          onUsersUpdated: (users) => {
            this.netplayMenu.netplayUpdatePlayerList({ players: users });
          },
          onRoomClosed: (data) => {
            console.log("[Netplay] Room closed:", data);
            if (this.netplayMenu?.cleanupRoomUi) {
              this.netplayMenu.cleanupRoomUI();
            }
          },
        },
      });

      // Initialize the engine (sets up all subsystems including InputSync and transport)
      console.log("[Netplay] Initializing NetplayEngine...");
      let engineInitialized = false;
      try {
        await engine.initialize();
        engineInitialized = true;
        console.log("[Netplay] NetplayEngine initialized successfully");
      } catch (error) {
        console.warn(
          "[Netplay] NetplayEngine initialization failed, using basic transport:",
          error,
        );

        // Fall back to basic transport without NetplayEngine
        this.emulator.netplay.transport = new SocketTransportClass({
          callbacks: {
            onConnect: (socketId) => {
              console.log("[Netplay] Basic socket connected:", socketId);

              // Set up event listeners for basic functionality
              this.emulator.netplay.transport.on("users-updated", (data) => {
                console.log("[Netplay] Users updated event received:", data);
                if (data.users) {
                  this.netplayMenu.netplayUpdatePlayerList({
                    players: data.users,
                  });
                }
              });

              // Join the room
              setTimeout(
                () => this.netplayMenu.netplayJoinRoomViaSocket(roomName),
                100,
              );
            },
            onConnectError: (error) => {
              console.error("[Netplay] Basic socket connection error:", error);
            },
            onDisconnect: (reason) => {
              console.log("[Netplay] Basic socket disconnected:", reason);
            },
          },
        });

        // Connect the basic transport
        await this.emulator.netplay.transport.connect(`wss://${socketBaseUrl}`);
      }

      // Store references - assign the main engine if initialized (overwrites room listing engine)
      if (engineInitialized) {
        this.emulator.netplay.engine = engine;
        this.emulator.netplay.transport = engine.socketTransport;
        this.emulator.netplay.adapter = adapter;
        console.log(
          `[Netplay] Assigned main NetplayEngine:${engine.id} (initialized: ${engineInitialized})`,
        );
        // NetplayEngine handles its own transport connection
      } else {
        // Connect the basic transport (fallback case)
        console.log("[Netplay] Connecting basic SocketTransport...");
        await this.emulator.netplay.transport.connect(`wss://${socketBaseUrl}`);
      }

      // The socket connection will be established by the NetplayEngine
      // Room joining happens in the onSocketConnect callback

      console.log("[Netplay] Netplay engine initialized successfully");
    } catch (error) {
      console.error("[Netplay] Failed to initialize netplay engine:", error);
    }
  }

  // Leave room
  async netplayLeaveRoom() {
    console.log("[Netplay] Leaving room and cleaning up completely...");

    // ========================================================================
    // PHASE 1: UI CLEANUP (do this BEFORE clearing engine so UI can access state)
    // ========================================================================
    if (this.netplayMenu) {
      console.log("[Netplay] Phase 1: Cleaning up UI state...");

      // Reset netplay menu state flag
      this.netplayMenu.isNetplay = false;

      // Reset currentRoomType to listings (critical for preventing stale UI)
      if (this.netplayMenu.currentRoomType !== undefined) {
        this.netplayMenu.currentRoomType = "listings";
      }

      // Clear player table content (but preserve DOM elements for reuse)
      if (this.emulator.netplay) {
        // Clear liveStreamPlayerTable content
        if (this.emulator.netplay.liveStreamPlayerTable) {
          this.emulator.netplay.liveStreamPlayerTable.innerHTML = "";
          // Hide the table container
          const liveTableContainer =
            this.emulator.netplay.liveStreamPlayerTable.parentElement;
          if (liveTableContainer) {
            liveTableContainer.style.display = "none";
          }
        }

        // Clear delaySyncPlayerTable content
        if (this.emulator.netplay.delaySyncPlayerTable) {
          this.emulator.netplay.delaySyncPlayerTable.innerHTML = "";
          // Hide the table container
          const delayTableContainer =
            this.emulator.netplay.delaySyncPlayerTable.parentElement;
          if (delayTableContainer) {
            delayTableContainer.style.display = "none";
          }
        }

        // Clear joined players array
        if (this.emulator.netplay.joinedPlayers) {
          this.emulator.netplay.joinedPlayers = [];
        }

        // Remove slot selector if it exists (to prevent duplication on next room creation)
        if (
          this.emulator.netplay.slotSelect &&
          this.emulator.netplay.slotSelect.parentElement
        ) {
          const slotSelectParent =
            this.emulator.netplay.slotSelect.parentElement;
          // Find and remove the label "Player Select:" that comes before the selector
          const slotLabel = Array.from(slotSelectParent.childNodes).find(
            (node) =>
              node.nodeType === Node.ELEMENT_NODE &&
              node.tagName === "STRONG" &&
              node.innerText &&
              (node.innerText.includes("Player Select") ||
                node.innerText.includes("Player Slot")),
          );
          if (slotLabel) {
            slotLabel.remove();
          }
          this.emulator.netplay.slotSelect.remove();
          this.emulator.netplay.slotSelect = null; // Clear the reference
          console.log("[Netplay] Removed slot selector during cleanup");
        }

        // Clear room name and password display
        if (this.emulator.netplay.roomNameElem) {
          this.emulator.netplay.roomNameElem.innerText = "";
          this.emulator.netplay.roomNameElem.style.display = "none";
        }
        if (this.emulator.netplay.passwordElem) {
          this.emulator.netplay.passwordElem.innerText = "";
          this.emulator.netplay.passwordElem.style.display = "none";
        }

        // Switch to listings tab (rooms tab)
        if (
          this.emulator.netplay.tabs &&
          this.emulator.netplay.tabs[0] &&
          this.emulator.netplay.tabs[1]
        ) {
          this.emulator.netplay.tabs[0].style.display = ""; // Show rooms tab
          this.emulator.netplay.tabs[1].style.display = "none"; // Hide joined tab
        }
      }

      // Reset title to listings
      if (this.netplayMenu.netplayMenu) {
        const titleElement = this.netplayMenu.netplayMenu.querySelector("h4");
        if (titleElement) {
          titleElement.innerText = "Netplay Listings";
        }
      }

      // Setup listings bottom bar (this will start room list fetching)
      if (this.netplayMenu.setupNetplayBottomBar) {
        this.netplayMenu.setupNetplayBottomBar("listings");
      }

      // Reset global EJS netplay state
      if (window.EJS) {
        window.EJS.isNetplay = false;
      }

      console.log("[Netplay] UI cleanup completed");
    }

    // ========================================================================
    // PHASE 2: NETWORK & TRANSPORT CLEANUP
    // ========================================================================
    console.log("[Netplay] Phase 2: Cleaning up network and transport...");

    // 1. Clean up intervals
    if (this._producerRetryInterval) {
      clearInterval(this._producerRetryInterval);
      this._producerRetryInterval = null;
    }
    if (this._audioRetryInterval) {
      clearInterval(this._audioRetryInterval);
      this._audioRetryInterval = null;
    }

    // 2. Leave room via RoomManager (this clears sessionState)
    if (this.emulator.netplay && this.emulator.netplay.engine) {
      try {
        await this.leaveRoom();
        console.log("[Netplay] Left room successfully");
      } catch (error) {
        console.error("[Netplay] Error leaving room:", error);
      }
    }

    // 3. Disconnect transport
    if (this.emulator.netplay && this.emulator.netplay.transport) {
      try {
        await this.emulator.netplay.transport.disconnect();
        console.log("[Netplay] Transport disconnected");
      } catch (error) {
        console.error("[Netplay] Error disconnecting transport:", error);
      }
    }

    // ========================================================================
    // PHASE 3: ENGINE & SESSION STATE CLEANUP
    // ========================================================================
    console.log("[Netplay] Phase 3: Cleaning up engine and session state...");

    if (this.emulator.netplay) {
      // Clear engine, transport, and adapter references
      this.emulator.netplay.engine = null;
      this.emulator.netplay.transport = null;
      this.emulator.netplay.adapter = null;

      // Clear all room/session state
      this.emulator.netplay.currentRoom = null;
      this.emulator.netplay.currentRoomId = null;
      this.emulator.netplay.localSlot = null;

      // Note: Keep emulator.netplay.name as it's user preference, not session state
      // Note: Keep emulator.netplay.tabs, roomNameElem, passwordElem, etc. as they're UI structure
      // Note: Keep emulator.netplay.liveStreamPlayerTable and delaySyncPlayerTable DOM elements
      //   (they're cleared above, but DOM elements should persist for reuse)

      console.log("[Netplay] Cleared all engine, transport, and session state");
    }

    // ========================================================================
    // PHASE 4: GAME STATE CLEANUP
    // ========================================================================
    console.log("[Netplay] Phase 4: Cleaning up game state...");

    // Restore original simulateInput
    if (this.gameManager && this.gameManager.originalSimulateInput) {
      this.gameManager.simulateInput = this.gameManager.originalSimulateInput;
      delete this.gameManager.originalSimulateInput;
      console.log("[Netplay] Restored original simulateInput");
    }

    // ========================================================================
    // PHASE 5: FINAL UI CLEANUP
    // ========================================================================
    console.log("[Netplay] Phase 5: Final UI cleanup...");

    // Hide chat component
    if (this.chatComponent) {
      this.chatComponent.hide();
    }

    // Hide menu (user can reopen it to see listings)
    if (this.netplayMenu && this.netplayMenu.hide) {
      this.netplayMenu.hide();
    }

    console.log(
      "[Netplay] Room leave and cleanup completed - ready for new session",
    );
  }

  async netplaySetupProducers() {
    console.log("[Netplay] netplaySetupProducers called", {
      hasEngine: !!this.emulator.netplay.engine,
      isHost: this.sessionState?.isHostRole(),
      netplayMode: this.emulator.netplay?.currentRoom?.netplay_mode,
    });

    if (!this.emulator.netplay.engine || !this.sessionState?.isHostRole()) {
      console.log(
        "[Netplay] Not host or engine not available, skipping producer setup",
      );
      return;
    }

    try {
      console.log("[Netplay] Setting up video/audio producers...");

      // Initialize SFU transports for host
      console.log("[Netplay] Initializing host transports...");
      try {
        await this.initializeHostTransports();
        console.log("[Netplay] ✅ Host transports initialized");
        console.log("[Netplay] SFU transport status:", {
          hasSFUTransport: !!this.sfuTransport,
          isConnected: this.sfuTransport?.isConnected?.(),
          useSFU: this.sfuTransport?.useSFU,
        });
      } catch (error) {
        console.error(
          "[Netplay] ❌ Failed to initialize host transports:",
          error,
        );
        throw error;
      }

      // Capture canvas video
      try {
        const videoTrack = await this.netplayCaptureCanvasVideo();
        if (videoTrack) {
          await this.sfuTransport.createVideoProducer(videoTrack);
          console.log("[Netplay] ✅ Video producer created");
        } else {
          console.warn(
            "[Netplay] ⚠️ No video track captured - canvas may not be ready yet",
          );
          // For hosts, if video capture fails, we'll retry when game starts
          if (
            this.sessionState?.isHostRole() &&
            this.emulator.netplay?.currentRoom?.netplay_mode === 0
          ) {
            console.log("[Netplay] Will retry video capture when game starts");
          }
        }
      } catch (error) {
        console.error("[Netplay] ❌ Failed to create video producer:", error);
        // For hosts, if video capture fails, we'll retry when game starts
        if (
          this.sessionState?.isHostRole() &&
          this.emulator.netplay?.currentRoom?.netplay_mode === 0
        ) {
          console.log(
            "[Netplay] Will retry video capture when game starts due to error:",
            error.message,
          );
        }
      }

      // Capture game audio (emulator audio) with retry logic
      try {
        console.log("[Netplay] 🔊 Setting up game audio producer...");
        let gameAudioTrack = await this.waitForEmulatorAudio();
        let retryCount = 0;
        const maxRetries = 15;

        // Retry game audio capture more aggressively in case emulator audio isn't ready yet
        while (!gameAudioTrack && retryCount < maxRetries) {
          const delay = retryCount < 5 ? 2000 : 5000; // 2s for first 5, then 5s
          console.log(
            `[Netplay] Game audio capture attempt ${retryCount + 1}/${maxRetries} failed, retrying in ${delay / 1000}s...`,
          );
          await new Promise((resolve) => setTimeout(resolve, delay));
          gameAudioTrack = await this.waitForEmulatorAudio();
          retryCount++;
        }

        if (gameAudioTrack) {
          await this.sfuTransport.createAudioProducer(gameAudioTrack);
          console.log("[Netplay] ✅ Game audio producer created");
        } else {
          console.warn(
            "[Netplay] ⚠️ No game audio track captured after all retries",
          );

          // Set up continuous game audio capture retry for hosts
          if (
            this.sessionState?.isHostRole() &&
            this.emulator.netplay?.currentRoom?.netplay_mode === 0
          ) {
            console.log(
              "[Netplay] Setting up continuous game audio capture retry for host",
            );
            this._audioRetryInterval = setInterval(async () => {
              if (!this.sfuTransport?.audioProducer) {
                console.log("[Netplay] Host retrying game audio capture...");
                try {
                  const gameAudioTrack = await this.waitForEmulatorAudio();
                  if (gameAudioTrack) {
                    await this.sfuTransport.createAudioProducer(gameAudioTrack);
                    console.log(
                      "[Netplay] ✅ Game audio producer created on continuous retry",
                    );
                    clearInterval(this._audioRetryInterval);
                    this._audioRetryInterval = null;
                  }
                } catch (retryError) {
                  console.debug(
                    "[Netplay] Game audio retry failed:",
                    retryError.message,
                  );
                }
              } else {
                console.log(
                  "[Netplay] Host already has game audio producer, stopping continuous retry",
                );
                clearInterval(this._audioRetryInterval);
                this._audioRetryInterval = null;
              }
            }, 10000); // Retry every 10 seconds

            // Stop after 5 minutes
            setTimeout(() => {
              if (this._audioRetryInterval) {
                console.log(
                  "[Netplay] Stopping continuous game audio retry after timeout",
                );
                clearInterval(this._audioRetryInterval);
                this._audioRetryInterval = null;
              }
            }, 300000);
          }
        }
      } catch (error) {
        console.error(
          "[Netplay] ❌ Failed to create game audio producer:",
          error,
        );
        // Game audio is optional, don't throw here
      }

      // Capture mic audio for voice chat (only for non-spectators)
      const isSpectator = this.sessionState?.isSpectatorRole() || false;
      if (!isSpectator) {
        try {
          console.log(
            "[Netplay] 🎤 Setting up mic audio producer for voice chat...",
          );
          const micAudioTrack = await this.netplayCaptureMicAudio();
          if (micAudioTrack) {
            await this.sfuTransport.createMicAudioProducer(micAudioTrack);
            console.log("[Netplay] ✅ Mic audio producer created");
          } else {
            console.log(
              "[Netplay] ℹ️ Mic audio not available (user denied permission or no mic found)",
            );
          }
        } catch (error) {
          console.error(
            "[Netplay] ❌ Failed to create mic audio producer:",
            error,
          );
          // Mic audio is optional, don't throw here
        }
      } else {
        console.log(
          "[Netplay] 👁️ Spectator mode - skipping mic audio producer",
        );
      }

      // Create data producer for input relay
      console.log(
        "[Netplay] Attempting to create data producer for input relay",
      );
      try {
        const dataProducer = await this.sfuTransport.createDataProducer();
        if (dataProducer) {
          console.log("[Netplay] ✅ Data producer created successfully:", {
            id: dataProducer.id,
            hasDataChannelManager: !!this.dataChannelManager,
          });
        } else {
          console.log(
            "[Netplay] Data producer creation returned null (transport may not support data channels)",
          );
        }
      } catch (error) {
        console.warn("[Netplay] Data producer creation failed:", error.message);
        console.warn("[Netplay] Input relay will use Socket.IO fallback");
        // Continue - data producers are optional for livestream rooms
      }

      // Set up data consumers to receive inputs from clients via SFU data channels
      console.log(
        "[Netplay] Setting up data consumers to receive inputs from clients...",
      );
      try {
        await this.netplaySetupDataConsumers();
        console.log("[Netplay] ✅ Data consumers setup complete");
      } catch (error) {
        console.error("[Netplay] ❌ Failed to setup data consumers:", error);
        // Continue - input might still work via other methods
      }
      // Set up data consumers to receive inputs from clients via SFU data channels
      console.log(
        "[Netplay] Setting up data consumers to receive inputs from clients...",
      );
      await this.netplaySetupDataConsumers();

      // Check input mode and set up P2P channels if needed for unorderedP2P
      const inputMode =
        this.dataChannelManager?.mode ||
        this.configManager?.getSetting("inputMode") ||
        this.config.inputMode ||
        "orderedRelay";

      if (inputMode === "unorderedP2P" || inputMode === "orderedP2P") {
        console.log(
          `[Netplay] Input mode is ${inputMode}, setting up P2P data channels...`,
        );
        await this.netplaySetupP2PChannels();
        console.log(
          `[Netplay] P2P setup complete, checking channels:`,
          this.dataChannelManager?.p2pChannels?.size || 0,
        );
      }
    } catch (error) {
      console.error("[Netplay] Failed to setup producers:", error);
    }
  }

  // Setup data producers for input synchronization (both host and clients)
  async netplaySetupDataProducers() {
    if (!this.emulator.netplay.engine) {
      console.log(
        "[Netplay] Engine not available, skipping data producer setup",
      );
      return;
    }

    // Spectators don't need to create input data producers
    const isSpectator = this.sessionState?.isSpectatorRole() || false;
    if (isSpectator) {
      console.log(
        "[Netplay] 👁️ Spectator mode - skipping input data producer setup",
      );
      return;
    }

    try {
      console.log("[Netplay] Setting up data producers for input...");

      // Initialize transports if not already done
      const isHost = this.sessionState?.isHostRole();

      // Everyone needs receive transport for consumers
      if (isHost) {
        await this.initializeHostTransports(); // Creates send + recv for host
      } else {
        await this.initializeClientTransports(); // Creates recv for client
        // Clients also need send transport for data producers
        console.log(
          "[Netplay] Creating send transport for client data producers",
        );
        await this.sfuTransport.createSendTransport("data");
      }

      // Create data producer for input synchronization
      const dataProducer = await this.sfuTransport.createDataProducer();
      if (dataProducer) {
        console.log("[Netplay] Data producer created for input");

        // Set up input forwarding via data channel
        this.netplayMenu.netplaySetupInputForwarding(dataProducer);
      } else {
        console.log("[Netplay] Data producer not supported");
      }
    } catch (error) {
      console.error("[Netplay] Failed to setup data producers:", error);
    }
  }

  // Setup data consumers for hosts to receive inputs from clients via SFU
  async netplaySetupDataConsumers() {
    if (!this.emulator.netplay.engine || !this.sessionState?.isHostRole()) {
      console.log(
        "[Netplay] Not host or engine not available, skipping data consumer setup",
      );
      return;
    }

    try {
      console.log(
        "[Netplay] Setting up data consumers to receive inputs from clients...",
      );

      // Ensure receive transport exists (should already exist from initializeHostTransports)
      if (!this.sfuTransport?.recvTransport) {
        console.warn(
          "[Netplay] Receive transport not available, cannot set up data consumers",
        );
        return;
      }

      // Get existing data producers from clients
      if (this.socketTransport) {
        try {
          const existingDataProducers = await new Promise((resolve, reject) => {
            this.socketTransport.emit(
              "sfu-get-data-producers",
              {},
              (error, producers) => {
                if (error) {
                  console.warn(
                    "[Netplay] Failed to get existing data producers:",
                    error,
                  );
                  resolve([]);
                  return;
                }
                console.log(
                  "[Netplay] Received existing data producers:",
                  producers,
                );
                resolve(producers || []);
              },
            );
          });

          // Create data consumers for existing data producers
          // Message handling is automatically set up by SFUTransport.createConsumer()
          for (const producer of existingDataProducers) {
            try {
              console.log(
                `[Netplay] Creating data consumer for producer ${producer.id}`,
              );
              const consumer = await this.sfuTransport.createConsumer(
                producer.id,
                "data",
              );
              console.log(`[Netplay] ✅ Created data consumer:`, consumer.id);
            } catch (error) {
              console.warn(
                `[Netplay] Failed to create data consumer for producer ${producer.id}:`,
                error.message,
              );
            }
          }
        } catch (error) {
          console.warn(
            "[Netplay] Failed to get existing data producers:",
            error,
          );
        }

        this.socketTransport.on("new-data-producer", async (data) => {
          console.log("[Netplay] 📡 RECEIVED new-data-producer event:", data);
          try {
            const producerId = data.id;

            // Check if we already have a consumer for this producer
            if (
              this.sfuTransport &&
              this.sfuTransport.consumers &&
              this.sfuTransport.consumers.has(producerId)
            ) {
              console.log(
                `[Netplay] Already have consumer for producer ${producerId}, skipping`,
              );
              return;
            }

            console.log(
              `[Netplay] Creating data consumer for new producer ${producerId}`,
            );
            const consumer = await this.sfuTransport.createConsumer(
              producerId,
              "data",
            );
            console.log(`[Netplay] ✅ Created data consumer:`, consumer.id);
            console.log(
              `[Netplay] 🎮 Data consumer ready for input synchronization`,
            );
          } catch (error) {
            // Producer may have been closed/removed - this is not fatal
            if (error.message && error.message.includes("not found")) {
              console.warn(
                `[Netplay] ⚠️ Data producer ${data.id} no longer available (may have been closed) - this is normal if the producer left quickly`,
              );
            } else {
              console.error(
                "[Netplay] ❌ Failed to handle new-data-producer event:",
                error,
              );
            }
          }
        });
      }

      console.log(
        "[Netplay] Data consumer setup complete - ready to receive inputs from clients",
      );
    } catch (error) {
      console.error("[Netplay] Failed to setup data consumers:", error);
    }
  }

  // Client-side P2P connection initiation for unorderedP2P/orderedP2P modes
  async netplayInitiateP2PConnection() {
    console.log("[Netplay] 🔗 netplayInitiateP2PConnection called");

    // Prevent duplicate P2P initiations
    if (this._p2pInitiating) {
      console.log("[Netplay] P2P initiation already in progress, skipping");
      return;
    }
    this._p2pInitiating = true;

    if (!this.socketTransport || this.sessionState?.isHostRole()) {
      console.log(
        "[Netplay] Not a client or no socket transport, skipping P2P initiation",
      );
      this._p2pInitiating = false;
      return;
    }

    console.log("[Netplay] ✅ Client starting P2P connection initiation");

    // Find the host's player ID (first player in the room, usually the one with the earliest join time)
    let hostPlayerId = null;

    // Try multiple sources for player data
    let players = null;

    // Source 1: currentRoom.players
    if (this.emulator?.netplay?.currentRoom?.players) {
      players = this.emulator.netplay.currentRoom.players;
      console.log(
        "[Netplay] Using players from currentRoom:",
        Object.keys(players),
      );
    }
    // Source 2: NetplayMenu.joinedPlayers
    else if (this.emulator?.netplayMenu?.netplay?.joinedPlayers) {
      // Convert joinedPlayers array back to object format
      players = {};
      this.emulator.netplayMenu.netplay.joinedPlayers.forEach((player) => {
        players[player.id] = player;
      });
      console.log(
        "[Netplay] Using players from NetplayMenu joinedPlayers:",
        Object.keys(players),
      );
    }

    if (players) {
      console.log(
        "[Netplay] Looking for host among players:",
        Object.keys(players),
      );

      const playerEntries = Object.entries(players);
      if (playerEntries.length > 0) {
        // For simplicity, assume the first player in the list is the host
        // This is a heuristic - in practice, the server should provide host information
        [hostPlayerId] = playerEntries[0];
        console.log("[Netplay] Assuming first player is host:", hostPlayerId);
        console.log(
          "[Netplay] All available players:",
          playerEntries.map(([id]) => id),
        );
      }

      // Alternative: look for a player that might have host privileges or special markers
      for (const [playerId, playerData] of Object.entries(players)) {
        console.log(`[Netplay] Checking player ${playerId}:`, {
          slot: playerData.slot || playerData.player_slot,
          isHost: playerData.isHost || playerData.host,
          ready: playerData.ready,
        });
        if (playerData.isHost || playerData.host) {
          hostPlayerId = playerId;
          console.log("[Netplay] Found explicit host flag:", hostPlayerId);
          break;
        }
      }
    } else {
      console.log("[Netplay] No player data available from any source");
    }

    if (!hostPlayerId) {
      console.error(
        "[Netplay] Could not determine host player ID for P2P connection - will retry in 2 seconds",
      );

      // Retry after a short delay in case data becomes available
      setTimeout(() => {
        console.log("[Netplay] Retrying P2P connection initiation...");
        this.netplayInitiateP2PConnection().catch((err) => {
          console.error("[Netplay] P2P connection retry failed:", err);
        });
      }, 2000);
      return;
    }

    // Send to "host" - server will resolve to room owner
    const target = "host";
    console.log(
      "[Netplay] Will send P2P offer to target:",
      target,
      "(resolved by server to room owner)",
    );

    try {
      console.log("[Netplay] Initiating P2P connection to host...");

      // Get ICE servers - prioritize SFU-provided servers, then fall back to RomM config
      let iceServers = [];

      // First, try to get ICE servers from the SFU
      console.log("[Netplay] Checking SFU transport availability:", {
        hasSfuTransport: !!this.sfuTransport,
        sfuTransportType: typeof this.sfuTransport,
        sfuTransportInitialized: this.sfuTransport?.useSFU,
      });

      if (this.sfuTransport) {
        console.log("[Netplay] Attempting to fetch ICE servers from SFU...");
        try {
          const sfuIceServers = await this.sfuTransport.getIceServers();
          console.log("[Netplay] SFU getIceServers() returned:", {
            servers: sfuIceServers,
            count: sfuIceServers?.length || 0,
            isArray: Array.isArray(sfuIceServers),
          });

          if (sfuIceServers && sfuIceServers.length > 0) {
            iceServers = [...sfuIceServers];
            console.log(
              `[Netplay] ✅ Using ${iceServers.length} ICE servers from SFU:`,
              iceServers,
            );
          } else {
            console.log(
              "[Netplay] SFU returned no ICE servers, falling back to config",
            );
          }
        } catch (error) {
          console.warn(
            "[Netplay] Failed to fetch ICE servers from SFU:",
            error,
          );
          console.warn("[Netplay] Error details:", {
            message: error.message,
            stack: error.stack,
            name: error.name,
          });
        }
      } else {
        console.log(
          "[Netplay] No SFU transport available, skipping SFU ICE server fetch",
        );
      }

      // If no SFU servers or SFU fetch failed, fall back to RomM config
      if (iceServers.length === 0) {
        const rommIceServers =
          this.configManager?.getSetting("netplayIceServers") ||
          this.configManager?.getSetting("netplayICEServers") ||
          this.config?.netplayICEServers ||
          window.EJS_netplayICEServers;

        if (
          rommIceServers &&
          Array.isArray(rommIceServers) &&
          rommIceServers.length > 0
        ) {
          iceServers = [...rommIceServers];
          console.log(
            `[Netplay] ✅ Using ${iceServers.length} ICE servers from RomM config`,
          );
        } else {
          console.log(
            "[Netplay] No RomM ICE servers configured, falling back to public servers",
          );
        }
      }

      // Final fallback to public STUN/TURN servers if nothing else is available
      if (iceServers.length === 0) {
        iceServers = [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" },
          { urls: "stun:stun2.l.google.com:19302" },
          // Public TURN servers (may have rate limits)
          {
            urls: "turn:turn.anyfirewall.com:443?transport=tcp",
            username: "webrtc",
            credential: "webrtc",
          },
        ];
        console.log(
          "[Netplay] ⚠️ Using public STUN/TURN servers as final fallback",
        );
      }

      // Log ICE server configuration for debugging
      console.log(
        "[Netplay] 🎯 Using ICE servers for P2P:",
        JSON.stringify(iceServers, null, 2),
      );
      const stunCount = iceServers.filter(
        (s) =>
          s.urls &&
          (Array.isArray(s.urls) ? s.urls : [s.urls]).some((u) =>
            u.startsWith("stun:"),
          ),
      ).length;
      const turnCount = iceServers.filter(
        (s) =>
          s.urls &&
          (Array.isArray(s.urls) ? s.urls : [s.urls]).some((u) =>
            u.startsWith("turn:"),
          ),
      ).length;
      console.log(
        `[Netplay] 📊 ICE server summary: ${stunCount} STUN, ${turnCount} TURN servers configured`,
      );

      // Get unordered retries setting
      const unorderedRetries =
        this.configManager?.getSetting("netplayUnorderedRetries") || 0;

      // Create RTCPeerConnection for P2P data channels
      const pc = new RTCPeerConnection({
        iceServers: iceServers,
        iceTransportPolicy: "all", // Try all candidates
        bundlePolicy: "balanced",
        rtcpMuxPolicy: "require",
      });

      // Add comprehensive WebRTC monitoring
      let connectionTimeout = null;
      let iceGatheringTimeout = null;

      pc.oniceconnectionstatechange = () => {
        console.log(
          `[Netplay] P2P ICE connection state (${target}): ${pc.iceConnectionState}`,
        );
        if (
          pc.iceConnectionState === "connected" ||
          pc.iceConnectionState === "completed"
        ) {
          console.log(
            `[Netplay] ✅ P2P connection established with ${target}!`,
          );
          clearTimeout(connectionTimeout);
          clearTimeout(iceGatheringTimeout);
        } else if (
          pc.iceConnectionState === "failed" ||
          pc.iceConnectionState === "disconnected" ||
          pc.iceConnectionState === "closed"
        ) {
          console.warn(
            `[Netplay] ❌ P2P connection failed with ${target}: ${pc.iceConnectionState}`,
          );
          // Could fall back to relay mode here
        }
      };

      pc.onicegatheringstatechange = () => {
        console.log(
          `[Netplay] P2P ICE gathering state (${target}): ${pc.iceGatheringState}`,
        );
        if (pc.iceGatheringState === "complete") {
          clearTimeout(iceGatheringTimeout);
        }
      };

      // Track candidate types for diagnostics
      let candidateTypes = { host: 0, srflx: 0, relay: 0, prflx: 0 };

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          const candidate = event.candidate;
          candidateTypes[candidate.type] =
            (candidateTypes[candidate.type] || 0) + 1;
          console.log(
            `[Netplay] P2P ICE candidate (${target}): ${candidate.type} ${candidate.protocol}:${candidate.port} priority:${candidate.priority}`,
          );

          // Log relay candidate detection (TURN working)
          if (candidate.type === "relay") {
            console.log(
              `[Netplay] ✅ TURN server provided relay candidate for ${target} - P2P should work!`,
            );
          }
        } else {
          const totalCandidates = Object.values(candidateTypes).reduce(
            (a, b) => a + b,
            0,
          );
          console.log(
            `[Netplay] P2P ICE candidate gathering complete (${target}) - gathered ${totalCandidates} candidates:`,
            candidateTypes,
          );

          // Warn if no relay candidates (TURN servers not working)
          if (candidateTypes.relay === 0) {
            console.warn(
              `[Netplay] ⚠️ No relay candidates detected for ${target} - TURN servers may not be working properly`,
            );
          }
        }
      };

      pc.onconnectionstatechange = () => {
        console.log(
          `[Netplay] P2P connection state (${target}): ${pc.connectionState}`,
        );
        if (
          pc.connectionState === "connected" ||
          pc.connectionState === "completed"
        ) {
          console.log(`[Netplay] ✅ P2P connection established with ${target}`);
        } else if (
          pc.connectionState === "failed" ||
          pc.connectionState === "disconnected"
        ) {
          console.warn(
            `[Netplay] ⚠️ P2P connection ${pc.connectionState} with ${target}`,
          );
        }
      };

      // Set timeout for connection establishment (longer for local networks)
      connectionTimeout = setTimeout(() => {
        if (
          pc.connectionState !== "connected" &&
          pc.connectionState !== "completed"
        ) {
          console.error(
            `[Netplay] ❌ P2P connection timeout with ${target} - falling back to relay mode`,
          );
          pc.close();
          this.handleP2PFallback(target);
        }
      }, 30000); // 30 second timeout for local networks

      // Set timeout for ICE gathering (increased for coturn servers)
      iceGatheringTimeout = setTimeout(() => {
        if (pc.iceGatheringState !== "complete") {
          const candidateCount =
            pc.localDescription?.sdp
              ?.split("\n")
              .filter((line) => line.startsWith("a=candidate")).length || 0;
          console.warn(
            `[Netplay] ⚠️ P2P ICE gathering timeout with ${target} - gathered ${candidateCount} candidates`,
          );

          // Check if we have relay candidates (TURN servers working)
          const hasRelayCandidates =
            pc.localDescription?.sdp?.includes("typ relay") || false;

          if (!hasRelayCandidates && candidateCount < 10) {
            console.warn(
              `[Netplay] 🚨 No relay candidates detected - TURN servers may be failing. Triggering early fallback to relay mode.`,
            );
            // Clear connection timeout since we're handling fallback now
            clearTimeout(connectionTimeout);
            pc.close();
            this.handleP2PFallback(target);
            return;
          }

          // Continue with connection attempt even if gathering didn't complete
          // The connection timeout will handle fallback if needed
        }
      }, 10000); // 10 second timeout for ICE gathering

      // Create data channels as offerer (client creates channels, host receives them)
      console.log(`[Netplay] Creating data channels for P2P connection`);
      const unorderedChannel = pc.createDataChannel("input-unordered", {
        ordered: false,
        maxRetransmits: unorderedRetries > 0 ? unorderedRetries : undefined,
        maxPacketLifeTime: unorderedRetries === 0 ? 3000 : undefined,
      });
      console.log(
        `[Netplay] Created unordered channel: ${unorderedChannel.label}, id: ${unorderedChannel.id}, readyState: ${unorderedChannel.readyState}`,
      );

      const orderedChannel = pc.createDataChannel("input-ordered", {
        ordered: true,
      });
      console.log(
        `[Netplay] Created ordered channel: ${orderedChannel.label}, id: ${orderedChannel.id}, readyState: ${orderedChannel.readyState}`,
      );

      // Add channels to DataChannelManager immediately
      if (this.dataChannelManager) {
        console.log(
          `[Netplay] Adding P2P channels for host to DataChannelManager`,
        );
        this.dataChannelManager.addP2PChannel("host", {
          ordered: orderedChannel,
          unordered: unorderedChannel,
        });
        console.log(
          `[Netplay] Client DataChannelManager now has ${this.dataChannelManager.p2pChannels.size} P2P connections`,
        );
      }

      // Set up channel event handlers
      unorderedChannel.onopen = () => {
        console.log(
          `[Netplay] Client unordered P2P channel opened with host - READY FOR INPUTS!`,
        );
        console.log(`[Netplay] Unordered channel state:`, {
          label: unorderedChannel.label,
          id: unorderedChannel.id,
          readyState: unorderedChannel.readyState,
          bufferedAmount: unorderedChannel.bufferedAmount,
        });
      };
      orderedChannel.onopen = () => {
        console.log(`[Netplay] Client ordered P2P channel opened with host`);
        console.log(`[Netplay] Ordered channel state:`, {
          label: orderedChannel.label,
          id: orderedChannel.id,
          readyState: orderedChannel.readyState,
          bufferedAmount: orderedChannel.bufferedAmount,
        });
      };

      unorderedChannel.onmessage = (event) => {
        console.log(
          `[Netplay] Client received P2P message on unordered channel:`,
          event.data,
        );
      };
      orderedChannel.onmessage = (event) => {
        console.log(
          `[Netplay] Client received P2P message on ordered channel:`,
          event.data,
        );
      };

      unorderedChannel.onclose = () => {
        console.log(`[Netplay] Client unordered P2P channel closed with host`);
      };
      orderedChannel.onclose = () => {
        console.log(`[Netplay] Client ordered P2P channel closed with host`);
      };

      unorderedChannel.onerror = (error) => {
        console.error(`[Netplay] Client unordered P2P channel error:`, error);
      };
      orderedChannel.onerror = (error) => {
        console.error(`[Netplay] Client ordered P2P channel error:`, error);
      };

      // Listen for data channels (though we created them, this handles any additional ones)
      pc.ondatachannel = (event) => {
        const channel = event.channel;
        console.log(
          `[Netplay] Client received data channel: ${channel.label}, id: ${channel.id}, readyState: ${channel.readyState}`,
        );

        // Determine channel type and add to DataChannelManager
        if (this.dataChannelManager) {
          if (channel.label === "input-unordered") {
            console.log(
              `[Netplay] Adding unordered channel to DataChannelManager`,
            );
            this.dataChannelManager.addP2PChannel("host", {
              unordered: channel,
              ordered: null, // Will be set when ordered channel arrives
            });
          } else if (channel.label === "input-ordered") {
            console.log(
              `[Netplay] Adding ordered channel to DataChannelManager`,
            );
            // Update existing entry with ordered channel
            const existing = this.dataChannelManager.p2pChannels.get("host");
            if (existing) {
              existing.ordered = channel;
            } else {
              this.dataChannelManager.addP2PChannel("host", {
                ordered: channel,
                unordered: null,
              });
            }
          }
          console.log(
            `[Netplay] Client DataChannelManager now has ${this.dataChannelManager.p2pChannels.size} P2P connections`,
          );
        }

        // Set up event handlers
        channel.onopen = () => {
          console.log(
            `[Netplay] Client ${channel.label} P2P channel opened with host`,
          );
        };

        channel.onerror = (error) => {
          console.error(
            `[Netplay] Client ${channel.label} P2P channel error:`,
            error,
          );
        };

        channel.onclose = () => {
          console.log(
            `[Netplay] Client ${channel.label} P2P channel closed with host`,
          );
          if (this.dataChannelManager) {
            this.dataChannelManager.removeP2PChannel("host");
          }
        };
      };

      // Handle ICE candidates
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          // Send ICE candidate to host via signaling
          this.socketTransport.sendDataMessage({
            "webrtc-signal": {
              candidate: event.candidate,
            },
          });
        }
      };

      // Create offer and send to host
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      // Send offer to host via signaling
      const clientId = this.socketTransport?.socket?.id || "client";
      console.log(
        "[Netplay] Sending WebRTC offer to host:",
        target,
        "from client:",
        clientId,
      );
      this.socketTransport.emit("webrtc-signal", {
        target: target,
        sender: clientId,
        offer: offer,
      });

      // Listen for host's answer and remote ICE candidates
      const handleWebRTCSignal = async (data) => {
        try {
          console.log("[Netplay] Client received WebRTC signal:", data);
          const { answer, candidate, target, sender } = data;

          // Only process signals targeted at this client
          const clientId = this.socketTransport?.socket?.id || "client";
          if (target && target !== clientId) {
            console.log(
              `[Netplay] Ignoring WebRTC signal targeted at ${target}, we are ${clientId}`,
            );
            return;
          }

          // Note: We trust the server to only relay legitimate signals from the host
          console.log(
            `[Netplay] Processing WebRTC signal from sender: ${sender}`,
          );

          if (answer) {
            console.log(
              `[Netplay] Received answer from host, current signaling state: ${pc.signalingState}`,
            );
            console.log(
              `[Netplay] Answer SDP type: ${answer.type}, contains 'm=application': ${answer.sdp?.includes("m=application")}`,
            );
            if (pc.signalingState === "have-local-offer") {
              console.log(
                "[Netplay] Setting remote description with answer...",
              );
              await pc.setRemoteDescription(new RTCSessionDescription(answer));
              console.log(
                "[Netplay] Remote description set successfully, new signaling state:",
                pc.signalingState,
              );
            } else if (pc.signalingState === "stable") {
              console.log(
                "[Netplay] Connection already stable, ignoring duplicate answer",
              );
            } else {
              console.warn(
                `[Netplay] Cannot set remote description: wrong signaling state: ${pc.signalingState}`,
              );
            }
          }

          if (candidate) {
            console.log(
              "[Netplay] Received ICE candidate from host, adding to PC...",
            );
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
          }
        } catch (error) {
          console.error("[Netplay] Error handling WebRTC signal:", error);
        }
      };

      this.socketTransport.on("webrtc-signal", handleWebRTCSignal);

      console.log("[Netplay] P2P connection offer sent to host");
    } catch (error) {
      console.error("[Netplay] Failed to initiate P2P connection:", error);
    } finally {
      this._p2pInitiating = false;
    }
  }

  /**
   * Handle P2P connection failure by falling back to relay mode
   * @param {string} targetId - The peer ID that failed P2P connection
   */
  handleP2PFallback(targetId) {
    console.log(`[Netplay] 🔄 Handling P2P fallback for ${targetId}`);

    if (!this.dataChannelManager) {
      console.warn("[Netplay] No DataChannelManager available for fallback");
      return;
    }

    const currentMode = this.dataChannelManager.mode;
    if (currentMode === "unorderedP2P") {
      console.log(
        `[Netplay] Falling back from unorderedP2P to unorderedRelay for ${targetId}`,
      );
      this.dataChannelManager.mode = "unorderedRelay";
      // Remove failed P2P channel
      this.dataChannelManager.removeP2PChannel(targetId);
      // TODO: Notify UI of mode change when method is implemented
    } else if (currentMode === "orderedP2P") {
      console.log(
        `[Netplay] Falling back from orderedP2P to orderedRelay for ${targetId}`,
      );
      this.dataChannelManager.mode = "orderedRelay";
      // Remove failed P2P channel
      this.dataChannelManager.removeP2PChannel(targetId);
      // TODO: Notify UI of mode change when method is implemented
    }

    // Send notification to user
    console.warn(
      `[Netplay] ⚠️ P2P connection failed with ${targetId}, switched to relay mode. Check network/firewall settings for better P2P performance.`,
    );
    console.warn(`[Netplay] 💡 P2P troubleshooting tips:`);
    console.warn(
      `[Netplay]   - Ensure both devices are on different networks or same network with proper routing`,
    );
    console.warn(
      `[Netplay]   - Check firewall settings allow UDP connections on ports 3478-65535`,
    );
    console.warn(`[Netplay]   - Try disabling VPN if active`);
    console.warn(
      `[Netplay]   - Public TURN servers have rate limits - consider private TURN server for production`,
    );
  }

  /**
   * Test P2P connectivity and log comprehensive diagnostics
   */
  async testP2PConnectivity() {
    console.log(
      "[Netplay] 🔍 Testing P2P connectivity and ICE server configuration...",
    );

    try {
      // Test all possible ICE server sources
      const iceSources = {
        configManager_netplayIceServers:
          this.configManager?.getSetting("netplayIceServers"),
        configManager_netplayICEServers:
          this.configManager?.getSetting("netplayICEServers"),
        config_netplayICEServers: this.config?.netplayICEServers,
        window_EJS_netplayICEServers: window.EJS_netplayICEServers,
      };

      console.log("[Netplay] 🔧 ICE server configuration sources:", iceSources);

      // Also test SFU ICE servers if available
      let sfuIceServers = [];
      if (this.sfuTransport) {
        console.log("[Netplay] Testing SFU ICE server availability...");
        try {
          sfuIceServers = await this.sfuTransport.getIceServers();
          console.log(
            `[Netplay] SFU provided ${sfuIceServers.length} ICE servers:`,
            sfuIceServers,
          );
        } catch (sfuError) {
          console.warn(
            "[Netplay] Failed to fetch ICE servers from SFU:",
            sfuError,
          );
        }
      } else {
        console.log(
          "[Netplay] No SFU transport available for ICE server testing",
        );
      }

      // Determine which source is being used (same logic as in P2P initiation)
      let iceServers = [];

      // First, use SFU servers if available
      if (sfuIceServers && sfuIceServers.length > 0) {
        iceServers = [...sfuIceServers];
        console.log(
          `[Netplay] Test will use ${iceServers.length} ICE servers from SFU`,
        );
      } else {
        // Fall back to RomM config
        const rommIceServers =
          iceSources.configManager_netplayIceServers ||
          iceSources.configManager_netplayICEServers ||
          iceSources.config_netplayICEServers ||
          iceSources.window_EJS_netplayICEServers;

        if (
          rommIceServers &&
          Array.isArray(rommIceServers) &&
          rommIceServers.length > 0
        ) {
          iceServers = [...rommIceServers];
          console.log(
            `[Netplay] Test will use ${iceServers.length} ICE servers from RomM config`,
          );
        } else {
          iceServers = [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
            { urls: "stun:stun2.l.google.com:19302" },
          ];
          console.log(
            "[Netplay] Test will use public STUN servers as final fallback",
          );
        }
      }

      console.log(
        `[Netplay] 🎯 Using ICE servers:`,
        JSON.stringify(iceServers, null, 2),
      );

      // Analyze ICE server configuration
      const stunServers = [];
      const turnServers = [];
      iceServers.forEach((server) => {
        if (server.urls) {
          const urls = Array.isArray(server.urls) ? server.urls : [server.urls];
          urls.forEach((url) => {
            if (url.startsWith("stun:")) {
              stunServers.push(url);
            } else if (url.startsWith("turn:")) {
              turnServers.push({
                url,
                username: server.username,
                credential: server.credential,
              });
            }
          });
        }
      });

      console.log(
        `[Netplay] 📡 STUN servers found: ${stunServers.length}`,
        stunServers,
      );
      console.log(
        `[Netplay] 🔄 TURN servers found: ${turnServers.length}`,
        turnServers.map((t) => `${t.url} (${t.username ? "auth" : "no-auth"})`),
      );

      if (turnServers.length === 0) {
        console.warn(
          "[Netplay] ⚠️ No TURN servers configured - P2P may fail for clients behind NAT/firewalls",
        );
      }

      // Create test RTCPeerConnection
      const testPC = new RTCPeerConnection({
        iceServers,
        iceTransportPolicy: "all",
        bundlePolicy: "balanced",
        rtcpMuxPolicy: "require",
      });

      let candidateCount = 0;
      let stunCandidates = 0;
      let turnCandidates = 0;
      let hostCandidates = 0;

      testPC.onicecandidate = (event) => {
        if (event.candidate) {
          candidateCount++;
          const type = event.candidate.type;
          if (type === "srflx") stunCandidates++;
          else if (type === "relay") turnCandidates++;
          else if (type === "host") hostCandidates++;

          console.log(
            `[Netplay] 🎯 ICE candidate ${candidateCount}: ${type} ${event.candidate.protocol}:${event.candidate.port} (${event.candidate.address})`,
          );
        } else {
          console.log(
            `[Netplay] ✅ ICE gathering complete - Total candidates: ${candidateCount} (Host: ${hostCandidates}, STUN: ${stunCandidates}, TURN: ${turnCandidates})`,
          );
        }
      };

      testPC.onicegatheringstatechange = () => {
        console.log(
          `[Netplay] 🔄 ICE gathering state: ${testPC.iceGatheringState}`,
        );
        if (testPC.iceGatheringState === "complete") {
          console.log(
            `[Netplay] 📊 Final candidate summary: ${candidateCount} total (${hostCandidates} host, ${stunCandidates} STUN, ${turnCandidates} TURN)`,
          );
        }
      };

      testPC.oniceconnectionstatechange = () => {
        console.log(
          `[Netplay] 🔗 ICE connection state: ${testPC.iceConnectionState}`,
        );
      };

      // Create data channel to trigger ICE
      const testChannel = testPC.createDataChannel("test-connectivity");
      console.log(
        `[Netplay] 📺 Created test data channel: ${testChannel.readyState}`,
      );

      // Create offer to start ICE process
      console.log("[Netplay] 📤 Creating offer to trigger ICE gathering...");
      const offer = await testPC.createOffer();
      await testPC.setLocalDescription(offer);

      console.log(
        "[Netplay] ✅ P2P connectivity test initiated - monitoring ICE for 15 seconds",
      );

      // Clean up after 15 seconds
      setTimeout(() => {
        const finalState = {
          gatheringState: testPC.iceGatheringState,
          connectionState: testPC.iceConnectionState,
          candidatesFound: candidateCount,
          hostCandidates,
          stunCandidates,
          turnCandidates,
        };

        testPC.close();
        console.log(
          "[Netplay] 🧹 P2P connectivity test completed:",
          finalState,
        );

        // Provide recommendations
        if (
          turnCandidates === 0 &&
          iceServers.some(
            (s) =>
              s.urls &&
              (Array.isArray(s.urls) ? s.urls : [s.urls]).some((u) =>
                u.startsWith("turn:"),
              ),
          )
        ) {
          console.warn(
            "[Netplay] ⚠️ TURN servers configured but no relay candidates found - check TURN server credentials and connectivity",
          );
        }
        if (stunCandidates === 0 && stunServers.length > 0) {
          console.warn(
            "[Netplay] ⚠️ STUN servers configured but no server reflexive candidates found - check STUN server connectivity",
          );
        }
        if (candidateCount === hostCandidates) {
          console.warn(
            "[Netplay] ⚠️ Only host candidates found - this suggests NAT/firewall issues that may prevent P2P connectivity",
          );
        }
      }, 15000);
    } catch (error) {
      console.error("[Netplay] ❌ P2P connectivity test failed:", error);
    }
  }

  /**
   * Test ICE server configuration and STUN negotiation.
   * This method verifies that ICE servers are properly configured and accessible.
   */
  async testIceServerConfiguration() {
    console.log(
      "[Netplay] 🔍 Testing ICE server configuration and STUN negotiation...",
    );

    try {
      // Test SFU /ice endpoint directly
      console.log("[Netplay] 📡 Testing SFU /ice endpoint directly...");
      if (this.socket?.serverUrl) {
        const baseUrl = this.socket.serverUrl.replace(/\/socket\.io.*$/, "");
        const iceEndpoint = `${baseUrl}/ice`;
        const token = this.socket?.authToken;

        console.log("[Netplay] Direct /ice endpoint test:", {
          endpoint: iceEndpoint,
          hasToken: !!token,
          tokenPreview: token ? `${token.substring(0, 20)}...` : "none",
        });

        try {
          const response = await fetch(iceEndpoint, {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          });

          console.log("[Netplay] /ice endpoint response:", {
            status: response.status,
            statusText: response.statusText,
            ok: response.ok,
          });

          if (response.ok) {
            const data = await response.json();
            console.log("[Netplay] /ice endpoint returned data:", data);
          } else {
            const text = await response.text();
            console.error("[Netplay] /ice endpoint error response:", text);
          }
        } catch (fetchError) {
          console.error(
            "[Netplay] Direct /ice endpoint fetch failed:",
            fetchError,
          );
        }
      } else {
        console.warn(
          "[Netplay] No socket available for direct /ice endpoint test",
        );
      }

      // Test SFU ICE server fetching
      console.log(
        "[Netplay] 📡 Testing SFU ICE server endpoint via SFUTransport...",
      );
      let sfuIceServers = [];
      if (this.sfuTransport) {
        try {
          sfuIceServers = await this.sfuTransport.getIceServers();
          console.log(
            `[Netplay] ✅ SFU returned ${sfuIceServers.length} ICE servers:`,
            sfuIceServers,
          );
        } catch (error) {
          console.error(
            "[Netplay] ❌ Failed to fetch ICE servers from SFU:",
            error,
          );
        }
      } else {
        console.warn(
          "[Netplay] ⚠️ No SFU transport available - cannot test SFU ICE servers",
        );
      }

      // Test RomM config ICE servers
      console.log("[Netplay] 🔧 Testing RomM ICE server configuration...");
      const rommIceServers =
        this.configManager?.getSetting("netplayIceServers") ||
        this.configManager?.getSetting("netplayICEServers") ||
        this.config?.netplayICEServers ||
        window.EJS_netplayICEServers;

      if (
        rommIceServers &&
        Array.isArray(rommIceServers) &&
        rommIceServers.length > 0
      ) {
        console.log(
          `[Netplay] ✅ RomM config has ${rommIceServers.length} ICE servers:`,
          rommIceServers,
        );
      } else {
        console.warn("[Netplay] ⚠️ No ICE servers configured in RomM");
      }

      // Determine final ICE server list (same logic as P2P initiation)
      let finalIceServers = [];
      if (sfuIceServers && sfuIceServers.length > 0) {
        finalIceServers = [...sfuIceServers];
        console.log(
          `[Netplay] 🎯 Will use ${finalIceServers.length} ICE servers from SFU (preferred)`,
        );
      } else if (
        rommIceServers &&
        Array.isArray(rommIceServers) &&
        rommIceServers.length > 0
      ) {
        finalIceServers = [...rommIceServers];
        console.log(
          `[Netplay] 🎯 Will use ${finalIceServers.length} ICE servers from RomM config`,
        );
      } else {
        finalIceServers = [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" },
          { urls: "stun:stun2.l.google.com:19302" },
        ];
        console.warn("[Netplay] ⚠️ Will use public STUN servers as fallback");
      }

      // Analyze ICE server types
      const stunServers = finalIceServers.filter((s) => {
        const urls = Array.isArray(s.urls) ? s.urls : [s.urls];
        return urls.some(
          (url) => url.startsWith("stun:") || url.startsWith("stuns:"),
        );
      });

      const turnServers = finalIceServers.filter((s) => {
        const urls = Array.isArray(s.urls) ? s.urls : [s.urls];
        return urls.some(
          (url) => url.startsWith("turn:") || url.startsWith("turns:"),
        );
      });

      console.log(`[Netplay] 📊 Final ICE server analysis:`);
      console.log(`  - STUN servers: ${stunServers.length}`);
      console.log(`  - TURN servers: ${turnServers.length}`);

      if (turnServers.length === 0) {
        console.warn(
          "[Netplay] ⚠️ No TURN servers configured - P2P may fail for clients behind NAT/firewalls",
        );
      }

      // Test STUN server reachability (basic connectivity test)
      console.log("[Netplay] 🌐 Testing STUN server reachability...");
      for (const server of stunServers.slice(0, 2)) {
        // Test first 2 STUN servers
        const urls = Array.isArray(server.urls) ? server.urls : [server.urls];
        for (const url of urls) {
          if (url.startsWith("stun:") || url.startsWith("stuns:")) {
            try {
              // Create a minimal RTCPeerConnection just to test STUN reachability
              const testPC = new RTCPeerConnection({
                iceServers: [{ urls: url }],
              });

              let stunReachable = false;
              testPC.onicecandidate = (event) => {
                if (event.candidate && event.candidate.type === "srflx") {
                  stunReachable = true;
                  console.log(
                    `[Netplay] ✅ STUN server ${url} is reachable (got server-reflexive candidate)`,
                  );
                  testPC.close();
                }
              };

              // Create a dummy offer to trigger ICE
              const offer = await testPC.createOffer();
              await testPC.setLocalDescription(offer);

              // Wait a bit for ICE candidates
              await new Promise((resolve) => setTimeout(resolve, 3000));
              testPC.close();

              if (!stunReachable) {
                console.warn(
                  `[Netplay] ⚠️ STUN server ${url} may not be reachable (no server-reflexive candidate received)`,
                );
              }
            } catch (error) {
              console.error(
                `[Netplay] ❌ Error testing STUN server ${url}:`,
                error,
              );
            }
            break; // Only test first URL for each server
          }
        }
      }

      console.log("[Netplay] ✅ ICE server configuration test completed");

      return {
        sfuIceServers,
        rommIceServers,
        finalIceServers,
        stunCount: stunServers.length,
        turnCount: turnServers.length,
      };
    } catch (error) {
      console.error(
        "[Netplay] ❌ ICE server configuration test failed:",
        error,
      );
      return null;
    }
  }

  // Setup P2P data channels for unorderedP2P/orderedP2P input modes
  async netplaySetupP2PChannels() {
    if (!this.emulator.netplay.engine || !this.sessionState?.isHostRole()) {
      console.log(
        "[Netplay] Not host or engine not available, skipping P2P channel setup",
      );
      return;
    }

    try {
      console.log(
        "[Netplay] Setting up P2P data channels for input synchronization...",
      );

      const inputMode =
        this.dataChannelManager?.mode ||
        this.configManager?.getSetting("inputMode") ||
        this.config.inputMode ||
        "orderedRelay";

      if (inputMode !== "unorderedP2P" && inputMode !== "orderedP2P") {
        console.log(
          `[Netplay] Input mode is ${inputMode}, P2P channels not needed`,
        );
        return;
      }

      // Set up WebRTC signaling for P2P data channels
      if (this.socketTransport) {
        // Listen for WebRTC signaling from clients to establish P2P connections
        this.socketTransport.on("webrtc-signal", async (data) => {
          try {
            const { sender, offer, answer, candidate, requestRenegotiate } =
              data;

            if (!sender) {
              console.warn("[Netplay] WebRTC signal missing sender");
              return;
            }

            // Handle offer from client (client wants to establish P2P connection)
            if (offer) {
              console.log(
                `[Netplay] Received WebRTC offer from ${sender}, creating answer...`,
              );

              // Get ICE servers from config, check both lowercase and uppercase variants
              const iceServers = this.configManager?.getSetting(
                "netplayIceServers",
              ) ||
                this.configManager?.getSetting("netplayICEServers") ||
                this.config?.netplayICEServers ||
                window.EJS_netplayICEServers || [
                  { urls: "stun:stun.l.google.com:19302" },
                  { urls: "stun:stun1.l.google.com:19302" },
                  { urls: "stun:stun2.l.google.com:19302" },
                  // Public TURN servers (may have rate limits)
                  {
                    urls: "turn:turn.anyfirewall.com:443?transport=tcp",
                    username: "webrtc",
                    credential: "webrtc",
                  },
                ];

              // Log ICE server configuration for debugging
              console.log(
                "[Netplay] 🎯 Host using ICE servers for P2P:",
                JSON.stringify(iceServers, null, 2),
              );
              const stunCount = iceServers.filter(
                (s) =>
                  s.urls &&
                  (Array.isArray(s.urls) ? s.urls : [s.urls]).some((u) =>
                    u.startsWith("stun:"),
                  ),
              ).length;
              const turnCount = iceServers.filter(
                (s) =>
                  s.urls &&
                  (Array.isArray(s.urls) ? s.urls : [s.urls]).some((u) =>
                    u.startsWith("turn:"),
                  ),
              ).length;
              console.log(
                `[Netplay] 📊 Host ICE server summary: ${stunCount} STUN, ${turnCount} TURN servers configured`,
              );

              // Create RTCPeerConnection for P2P data channels
              const pc = new RTCPeerConnection({
                iceServers: iceServers,
                iceTransportPolicy: "all", // Try all candidates
                bundlePolicy: "balanced",
                rtcpMuxPolicy: "require",
              });

              // Add comprehensive WebRTC monitoring for host
              let connectionTimeout = null;
              let iceGatheringTimeout = null;

              pc.oniceconnectionstatechange = () => {
                console.log(
                  `[Netplay] Host P2P ICE connection state (${sender}): ${pc.iceConnectionState}`,
                );
                if (
                  pc.iceConnectionState === "connected" ||
                  pc.iceConnectionState === "completed"
                ) {
                  console.log(
                    `[Netplay] ✅ Host P2P connection established with ${sender}!`,
                  );
                  clearTimeout(connectionTimeout);
                  clearTimeout(iceGatheringTimeout);
                } else if (
                  pc.iceConnectionState === "failed" ||
                  pc.iceConnectionState === "disconnected" ||
                  pc.iceConnectionState === "closed"
                ) {
                  console.warn(
                    `[Netplay] ❌ Host P2P connection failed with ${sender}: ${pc.iceConnectionState}`,
                  );
                  // Could fall back to relay mode here
                }
              };

              pc.onicegatheringstatechange = () => {
                console.log(
                  `[Netplay] Host P2P ICE gathering state (${sender}): ${pc.iceGatheringState}`,
                );
                if (pc.iceGatheringState === "complete") {
                  clearTimeout(iceGatheringTimeout);
                }
              };

              // Track candidate types for diagnostics
              let candidateTypes = { host: 0, srflx: 0, relay: 0, prflx: 0 };

              pc.onicecandidate = (event) => {
                if (event.candidate) {
                  const candidate = event.candidate;
                  candidateTypes[candidate.type] =
                    (candidateTypes[candidate.type] || 0) + 1;
                  console.log(
                    `[Netplay] Host P2P ICE candidate (${sender}): ${candidate.type} ${candidate.protocol}:${candidate.port} priority:${candidate.priority}`,
                  );

                  // Log relay candidate detection (TURN working)
                  if (candidate.type === "relay") {
                    console.log(
                      `[Netplay] ✅ TURN server provided relay candidate for ${sender} - P2P should work!`,
                    );
                  }
                } else {
                  const totalCandidates = Object.values(candidateTypes).reduce(
                    (a, b) => a + b,
                    0,
                  );
                  console.log(
                    `[Netplay] Host P2P ICE candidate gathering complete (${sender}) - gathered ${totalCandidates} candidates:`,
                    candidateTypes,
                  );

                  // Warn if no relay candidates (TURN servers not working)
                  if (candidateTypes.relay === 0) {
                    console.warn(
                      `[Netplay] ⚠️ No relay candidates detected for ${sender} - TURN servers may not be working properly`,
                    );
                  }
                }
              };

              pc.onconnectionstatechange = () => {
                console.log(
                  `[Netplay] Host P2P connection state (${sender}): ${pc.connectionState}`,
                );
                if (
                  pc.connectionState === "connected" ||
                  pc.connectionState === "completed"
                ) {
                  console.log(
                    `[Netplay] ✅ Host P2P connection established with ${sender}`,
                  );
                } else if (
                  pc.connectionState === "failed" ||
                  pc.connectionState === "disconnected"
                ) {
                  console.warn(
                    `[Netplay] ⚠️ Host P2P connection ${pc.connectionState} with ${sender}`,
                  );
                }
              };

              // Set timeout for connection establishment (longer for local networks)
              connectionTimeout = setTimeout(() => {
                if (
                  pc.connectionState !== "connected" &&
                  pc.connectionState !== "completed"
                ) {
                  console.error(
                    `[Netplay] ❌ Host P2P connection timeout with ${sender} - falling back to relay mode`,
                  );
                  pc.close();
                  this.handleP2PFallback(sender);
                }
              }, 30000); // 30 second timeout for local networks

              // Set timeout for ICE gathering (increased for coturn servers)
              iceGatheringTimeout = setTimeout(() => {
                if (pc.iceGatheringState !== "complete") {
                  const candidateCount =
                    pc.localDescription?.sdp
                      ?.split("\n")
                      .filter((line) => line.startsWith("a=candidate"))
                      .length || 0;
                  console.warn(
                    `[Netplay] ⚠️ Host P2P ICE gathering timeout with ${sender} - gathered ${candidateCount} candidates`,
                  );

                  // Check if we have relay candidates (TURN servers working)
                  const hasRelayCandidates =
                    pc.localDescription?.sdp?.includes("typ relay") || false;

                  if (!hasRelayCandidates && candidateCount < 10) {
                    console.warn(
                      `[Netplay] 🚨 No relay candidates detected - TURN servers may be failing. Triggering early fallback to relay mode.`,
                    );
                    // Clear connection timeout since we're handling fallback now
                    clearTimeout(connectionTimeout);
                    pc.close();
                    this.handleP2PFallback(sender);
                    return;
                  }

                  // Continue with connection attempt even if gathering didn't complete
                  // The connection timeout will handle fallback if needed
                }
              }, 10000); // 10 second timeout for ICE gathering

              // Host receives data channels created by client (offerer)
              // Set up event handler to receive channels from client
              pc.ondatachannel = (event) => {
                const channel = event.channel;
                console.log(
                  `[Netplay] Host received data channel from ${sender}: ${channel.label}, id: ${channel.id}, readyState: ${channel.readyState}`,
                );

                // Add channel to DataChannelManager
                if (this.dataChannelManager) {
                  if (channel.label === "input-unordered") {
                    console.log(
                      `[Netplay] Adding unordered channel to DataChannelManager for ${sender}`,
                    );
                    this.dataChannelManager.addP2PChannel(sender, {
                      unordered: channel,
                      ordered: null, // Will be set when ordered channel arrives
                    });
                  } else if (channel.label === "input-ordered") {
                    console.log(
                      `[Netplay] Adding ordered channel to DataChannelManager for ${sender}`,
                    );
                    // Update existing entry with ordered channel
                    const existing =
                      this.dataChannelManager.p2pChannels.get(sender);
                    if (existing) {
                      existing.ordered = channel;
                    } else {
                      this.dataChannelManager.addP2PChannel(sender, {
                        ordered: channel,
                        unordered: null,
                      });
                    }
                  }
                  console.log(
                    `[Netplay] Host DataChannelManager now has ${this.dataChannelManager.p2pChannels.size} P2P connections`,
                  );
                }

                // Set up channel event handlers
                channel.onopen = () => {
                  console.log(
                    `[Netplay] Host ${channel.label} P2P channel opened with ${sender} - READY FOR INPUTS!`,
                  );
                  console.log(`[Netplay] Host channel state:`, {
                    label: channel.label,
                    id: channel.id,
                    readyState: channel.readyState,
                    bufferedAmount: channel.bufferedAmount,
                  });
                };

                channel.onmessage = (event) => {
                  console.log(
                    `[Netplay] Host received P2P message on ${channel.label}:`,
                    event.data,
                  );
                };

                channel.onerror = (error) => {
                  console.error(
                    `[Netplay] Host ${channel.label} P2P channel error:`,
                    error,
                  );
                };

                channel.onclose = () => {
                  console.log(
                    `[Netplay] Host ${channel.label} P2P channel closed with ${sender}`,
                  );
                  if (this.dataChannelManager) {
                    this.dataChannelManager.removeP2PChannel(sender);
                  }
                };
              };

              // Handle ICE candidates
              pc.onicecandidate = (event) => {
                if (event.candidate) {
                  console.log(
                    `[Netplay] Sending ICE candidate to client:`,
                    sender,
                  );
                  this.socketTransport.emit("webrtc-signal", {
                    target: sender,
                    candidate: event.candidate,
                  });
                }
              };

              // Set remote description and create answer
              await pc.setRemoteDescription(new RTCSessionDescription(offer));
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);

              // Send answer back to client
              console.log(`[Netplay] Sending WebRTC answer to client:`, sender);
              console.log(
                `[Netplay] Answer SDP type: ${answer.type}, contains 'm=application': ${answer.sdp?.includes("m=application")}`,
              );
              this.socketTransport.emit("webrtc-signal", {
                target: sender,
                answer: answer,
              });

              console.log(
                `[Netplay] ✅ P2P connection established with ${sender}`,
              );
            }

            // Handle answer from client (response to our offer)
            if (answer) {
              console.log(`[Netplay] Received WebRTC answer from ${sender}`);
              // Answer handling would be done if host initiates connection
              // Currently clients initiate, so this is less common
            }

            // Handle ICE candidate
            if (candidate) {
              console.log(`[Netplay] Received ICE candidate from ${sender}`);
              // ICE candidate handling would be done in RTCPeerConnection
            }
          } catch (error) {
            console.error("[Netplay] Failed to handle WebRTC signal:", error);
          }
        });

        console.log(
          "[Netplay] P2P channel setup complete - listening for WebRTC signals from clients",
        );
      }
    } catch (error) {
      console.error("[Netplay] Failed to setup P2P channels:", error);
    }
  }

  // Capture canvas as video track for netplay streaming
  async netplayCaptureCanvasVideo() {
    try {
      console.log("[Netplay] Attempting to capture canvas video...");
      // Get the canvas element
      const canvas = this.canvas || document.querySelector("canvas");
      console.log(
        "[Netplay] Canvas element:",
        canvas,
        "Width:",
        canvas?.width,
        "Height:",
        canvas?.height,
      );

      if (!canvas) {
        console.warn("[Netplay] No canvas found for video capture");
        return null;
      }

      // Create a video stream from canvas
      const stream = canvas.captureStream(30); // 30 FPS
      const videoTrack = stream.getVideoTracks()[0];

      if (videoTrack) {
        console.log("[Netplay] Canvas video captured:", {
          width: canvas.width,
          height: canvas.height,
          frameRate: 30,
        });
        return videoTrack;
      } else {
        console.warn("[Netplay] No video track available from canvas");
        return null;
      }
    } catch (error) {
      console.error("[Netplay] Failed to capture canvas video:", error);
      return null;
    }
  }

  async waitForEmulatorAudio(timeout = 5000) {
    const start = Date.now();

    while (Date.now() - start < timeout) {
      const ejs = window.EJS_emulator;
      if (ejs && typeof ejs.getAudioOutputNode === "function") {
        const node = ejs.getAudioOutputNode();
        if (node && node.context) return node;
      }
      await new Promise((r) => setTimeout(r, 100));
    }

    return null;
  }

  // Capture audio for netplay streaming
  async netplayCaptureAudio() {
    const ejs = window.EJS_emulator;

    if (!ejs || typeof ejs.getAudioOutputNode !== "function") {
      console.warn("[Netplay] EmulatorJS audio hook not available");
      return null;
    }

    const outputNode = ejs.getAudioOutputNode();
    if (!outputNode || !outputNode.context) {
      console.warn("[Netplay] EmulatorJS audio output node invalid");
      return null;
    }

    const audioContext = outputNode.context;

    // Resume context if suspended (VERY IMPORTANT)
    if (audioContext.state === "suspended") {
      await audioContext.resume();
    }

    // Create destination ONCE
    if (!this._netplayAudioDestination) {
      this._netplayAudioDestination =
        audioContext.createMediaStreamDestination();

      // Tap emulator audio
      outputNode.connect(this._netplayAudioDestination);

      console.log("[Netplay] Emulator audio tapped for capture");
    }

    const track =
      this._netplayAudioDestination.stream.getAudioTracks()[0] || null;

    if (!track) {
      console.warn("[Netplay] No audio track available from destination");
      return null;
    }

    console.log("[Netplay] Game audio capture ready", {
      id: track.id,
      settings: track.getSettings(),
    });

    return track;
  }

  /**
   * Capture microphone audio for voice chat.
   * @returns {Promise<MediaStreamTrack|null>} Microphone audio track or null if failed
   */
  async netplayCaptureMicAudio() {
    try {
      console.log("[Netplay] Requesting microphone access for voice chat");

      const micStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleRate: 48000, // Match Opus native rate
          channelCount: 1, // Mono for voice
        },
      });

      const micTrack = micStream.getAudioTracks()[0];
      if (micTrack) {
        console.log("[Netplay] ✅ Microphone audio captured for voice chat", {
          trackId: micTrack.id,
          enabled: micTrack.enabled,
          settings: micTrack.getSettings(),
        });
        return micTrack;
      } else {
        console.warn("[Netplay] No microphone track available");
        return null;
      }
    } catch (micError) {
      console.log("[Netplay] Microphone capture failed:", micError.message);
      if (micError.name === "NotAllowedError") {
        console.log("[Netplay] User denied microphone permission");
      } else if (micError.name === "NotFoundError") {
        console.log("[Netplay] No microphone found");
      } else {
        console.log("[Netplay] Microphone capture error:", micError);
      }
      return null;
    }
  }

  /**
   * Start ping test to debug channel connectivity.
   */
  startPingTest() {
    if (this.dataChannelManager) {
      this.dataChannelManager.startPingTest();
    } else {
      console.warn(
        "[NetplayEngine] No data channel manager available for ping test",
      );
    }
  }

  /**
   * Stop ping test.
   */
  stopPingTest() {
    if (this.dataChannelManager) {
      this.dataChannelManager.stopPingTest();
    }
  }

  /**
   * Temporarily force ordered mode to test for packet loss issues.
   * @param {boolean} ordered - True to force ordered, false to use configured mode
   */
  forceOrderedMode(ordered = true) {
    if (this.dataChannelManager) {
      const originalMode = this.dataChannelManager.mode;
      const newMode = ordered ? "orderedRelay" : "unorderedRelay";
      console.log(
        `[NetplayEngine] Forcing mode from ${originalMode} to ${newMode} for testing`,
      );
      this.dataChannelManager.mode = newMode;
      return originalMode; // Return original mode so it can be restored
    }
    return null;
  }
}

// Expose as global for concatenated/minified builds
// Direct assignment - browser environment always has window
// #region agent log
try {
} catch (e) {
  console.error("Error before assignment:", e);
}
// #endregion
window.NetplayEngine = NetplayEngine;
// #region agent log
try {
} catch (e) {
  console.error("Error after assignment:", e);
}
// #endregion
// #region agent log
// #endregion

/**
 * EmulatorJSAdapter - Thin adapter layer for EmulatorJS
 * 
 * Translates EmulatorJS-specific operations to IEmulator interface.
 * This allows the netplay core to work with EmulatorJS without
 * tight coupling to EmulatorJS internals.
 * 
 * TODO: Implement in Phase 2+
 */


// #region agent log
try {
} catch(e) {
  console.error("Error in EmulatorJSAdapter.js instrumentation:", e);
}
// #endregion

class EmulatorJSAdapter {
  /**
   * @param {EmulatorJS} emulatorInstance - EmulatorJS instance
   */
  constructor(emulatorInstance) {
    this.emulator = emulatorInstance;
    this._frameCallbacks = new Set();
    this._pauseCallbacks = new Set();
  }

  /**
   * Simulate input in EmulatorJS.
   * @param {number} playerIndex - Player index (0-3)
   * @param {number} inputIndex - Input index (0-29)
   * @param {number} value - Input value
   */
  simulateInput(playerIndex, inputIndex, value) {
    if (this.emulator.gameManager?.functions?.simulateInput) {
      this.emulator.gameManager.functions.simulateInput(
        playerIndex,
        inputIndex,
        value
      );
    } else if (this.emulator.netplay?._ejsRawSimulateInputFn) {
      this.emulator.netplay._ejsRawSimulateInputFn(
        playerIndex,
        inputIndex,
        value
      );
    } else {
      console.warn("[EmulatorJSAdapter] simulateInput not available");
    }
  }

  /**
   * Get current frame from EmulatorJS.
   * @returns {number}
   */
  getCurrentFrame() {
    return this.emulator.netplay?.currentFrame || 0;
  }

  /**
   * Set current frame in EmulatorJS.
   * @param {number} frame - Frame number
   */
  setCurrentFrame(frame) {
    if (this.emulator.netplay) {
      this.emulator.netplay.currentFrame = frame;
    }
  }

  /**
   * Subscribe to frame changes.
   * @param {function(number): void} callback - Frame callback
   * @returns {function(): void} Unsubscribe function
   */
  onFrame(callback) {
    this._frameCallbacks.add(callback);

    // Start frame loop if this is the first callback
    if (this._frameCallbacks.size === 1) {
      this._startFrameLoop();
    }

    return () => {
      this._frameCallbacks.delete(callback);
      if (this._frameCallbacks.size === 0) {
        this._stopFrameLoop();
      }
    };
  }

  /**
   * Start the frame callback loop.
   * @private
   */
  _startFrameLoop() {
    if (this._frameLoopRunning) return;

    this._frameLoopRunning = true;
    this._lastFrame = this.getCurrentFrame();

    const frameLoop = () => {
      if (!this._frameLoopRunning) return;

      const currentFrame = this.getCurrentFrame();
      if (currentFrame !== this._lastFrame) {
        this._lastFrame = currentFrame;
        // Call all frame callbacks
        this._frameCallbacks.forEach(callback => {
          try {
            callback(currentFrame);
          } catch (error) {
            console.error("[EmulatorJSAdapter] Frame callback error:", error);
          }
        });
      }

      requestAnimationFrame(frameLoop);
    };

    requestAnimationFrame(frameLoop);
  }

  /**
   * Stop the frame callback loop.
   * @private
   */
  _stopFrameLoop() {
    this._frameLoopRunning = false;
  }

  /**
   * Capture video stream from EmulatorJS canvas.
   * @param {number} fps - Target FPS
   * @returns {Promise<MediaStream | null>}
   */
  async captureVideoStream(fps) {
    if (!this.emulator.canvas) {
      return null;
    }
    
    if (typeof this.emulator.collectScreenRecordingMediaTracks === "function") {
      return this.emulator.collectScreenRecordingMediaTracks(
        this.emulator.canvas,
        fps
      );
    }
    
    return null;
  }

  /**
   * Capture audio stream from EmulatorJS (stub for now).
   * @returns {Promise<MediaStream | null>}
   */
  async captureAudioStream() {
    // TODO: Implement audio capture in Phase 3
    return null;
  }

  /**
   * Pause EmulatorJS emulation.
   */
  pause() {
    if (typeof this.emulator.pause === "function") {
      this.emulator.pause();
    }
  }

  /**
   * Resume EmulatorJS emulation.
   */
  resume() {
    if (typeof this.emulator.resume === "function") {
      this.emulator.resume();
    }
  }

  /**
   * Check if EmulatorJS is paused.
   * @returns {boolean}
   */
  isPaused() {
    return this.emulator.paused || false;
  }

  /**
   * Subscribe to pause state changes (stub for now).
   * @param {function(boolean): void} callback - Pause callback
   * @returns {function(): void} Unsubscribe function
   */
  onPauseChange(callback) {
    // TODO: Implement pause callback subscription in Phase 2
    this._pauseCallbacks.add(callback);
    return () => {
      this._pauseCallbacks.delete(callback);
    };
  }

  /**
   * Get EmulatorJS emulator information.
   * @returns {{core: string, version: string}}
   */
  getEmulatorInfo() {
    return {
      core: this.emulator.config?.core || "unknown",
      version: this.emulator.ejs_version || "unknown",
    };
  }

  /**
   * Get ROM information from EmulatorJS.
   * @returns {{hash: string, size: number, name: string} | null}
   */
  getROMInfo() {
    // Try to get ROM info from config
    if (this.emulator.config && this.emulator.config.gameUrl) {
      const gameUrl = this.emulator.config.gameUrl;
      const gameName = this.emulator.config.gameName || this.emulator.ejs_gameName || "Unknown";
      
      // For now, return basic info (hash would need to be computed from ROM data)
      // This is a placeholder - actual hash computation would require ROM file access
      return {
        hash: null, // TODO: Compute hash from ROM data if available
        size: 0,    // TODO: Get actual ROM size
        name: gameName,
      };
    }
    
    return null;
  }

  /**
   * Get input framework type for EmulatorJS.
   * @returns {"simple" | "complex"}
   */
  getInputFramework() {
    // EmulatorJS uses simple controllers (30 inputs)
    return "simple";
  }

  /**
   * Get controller type for EmulatorJS.
   * @returns {string}
   */
  getControllerType() {
    // EmulatorJS uses standard controllers
    return "standard";
  }

  /**
   * Display message in EmulatorJS.
   * @param {string} message - Message text
   * @param {number} durationMs - Duration in milliseconds
   */
  displayMessage(message, durationMs) {
    if (typeof this.emulator.displayMessage === "function") {
      this.emulator.displayMessage(message, durationMs);
    }
  }

  /**
   * Show overlay in EmulatorJS (stub for now).
   * @param {string} type - Overlay type
   * @param {*} data - Overlay data
   */
  showOverlay(type, data) {
    // TODO: Implement overlay system in Phase 4
    if (type === "host-paused" && typeof this.emulator.netplayShowHostPausedOverlay === "function") {
      this.emulator.netplayShowHostPausedOverlay();
    }
  }

  /**
   * Hide overlay in EmulatorJS (stub for now).
   * @param {string} type - Overlay type
   */
  hideOverlay(type) {
    // TODO: Implement overlay system in Phase 4
    if (type === "host-paused" && typeof this.emulator.netplayHideHostPausedOverlay === "function") {
      this.emulator.netplayHideHostPausedOverlay();
    }
  }
}


// Also expose as global for non-module environments (after minification)
// Direct assignment - browser environment always has window
// #region agent log
try {
} catch(e) {
  console.error('Error before assignment:', e);
}
// #endregion
window.EmulatorJSAdapter = EmulatorJSAdapter;
// #region agent log
try {
} catch(e) {
  console.error('Error after assignment:', e);
}
// #endregion

/**
 * NetplayMenu - Netplay UI management
 *
 * Handles:
 * - Netplay menu creation and management
 * - Room listing and joining
 * - Player management UI
 * - Game launching and room operations
 */

class NetplayMenu {
  /**
   * @param {Object} emulator - The main emulator instance
   */
  constructor(emulator, netplayEngine) {
    this.emulator = emulator;
    this.engine = netplayEngine;
    this.netplayMenu = null;
    this.netplayBottomBar = null;
    // this.menuElement = this.emulator.createPopup('Netplay', [], true);

    // Auto-bind emulator helpers to this instance
    [
      "createElement",
      "createPopup",
      "localization",
      "createSubPopup",
      "addEventListener",
      "saveSettings",
      // add other commonly used methods
    ].forEach((fn) => {
      this[fn] = (...args) => this.emulator[fn](...args);
    });
  }

  // Getter to redirect this.netplay to this.emulator.netplay
  get netplay() {
    return this.emulator.netplay;
  }
  set netplay(value) {
    this.emulator.netplay = value;
  }

  // Mobile detection utility
  isMobileDevice() {
    return (
      /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
        navigator.userAgent,
      ) ||
      (window.innerWidth <= 768 && window.innerHeight <= 1024)
    );
  }

  // ============================================================================
  // CENTRALIZED SLOT MANAGEMENT SYSTEM
  // ============================================================================

  /**
   * Get the authoritative player table (single source of truth)
   * @returns {Object} playerTable[playerId] = { playerId, slot, role, connected, ... }
   */
  getPlayerTable() {
    const joinedPlayers = this.netplay?.joinedPlayers || [];
    // Convert array to object keyed by playerId for backward compatibility
    const playerTable = {};
    for (const player of joinedPlayers) {
      if (player.id) {
        playerTable[player.id] = { ...player, playerId: player.id };
      }
    }

    // Ensure local player is always in the table (but avoid duplicates)
    const myPlayerId = this.getMyPlayerId();
    if (myPlayerId && !playerTable[myPlayerId]) {
      // Check if local player is already in joinedPlayers with a different ID
      const myPlayerName = this.netplay?.name;
      const existingLocalPlayer = joinedPlayers.find(
        (p) =>
          p.id === myPlayerId ||
          (myPlayerName && p.name === myPlayerName) ||
          p.id === this.netplay?.engine?.sessionState?.localPlayerId,
      );

      if (!existingLocalPlayer) {
        // Local player not found in joinedPlayers, add them
        const sessionSlot =
          this.netplay?.engine?.sessionState?.getLocalPlayerSlot();
        const localSlot =
          sessionSlot !== null && sessionSlot !== undefined
            ? sessionSlot
            : (this.netplay?.localSlot ?? 0);
        playerTable[myPlayerId] = {
          playerId: myPlayerId,
          id: myPlayerId,
          name: this.netplay?.name || myPlayerId,
          slot: localSlot,
          role: localSlot === 8 ? "spectator" : "player",
          connected: true,
          ready: false,
        };
        console.log(
          "[NetplayMenu] Added local player to player table:",
          myPlayerId,
          "slot:",
          localSlot,
          "(from session state:",
          sessionSlot !== null && sessionSlot !== undefined ? "yes" : "no",
          "fallback:",
          this.netplay?.localSlot ?? 0,
          ")",
        );
      } else {
        // Local player exists with different ID, use existing entry
        playerTable[existingLocalPlayer.id] = {
          ...existingLocalPlayer,
          playerId: existingLocalPlayer.id,
        };
        console.log(
          "[NetplayMenu] Local player already in joinedPlayers with different ID:",
          existingLocalPlayer.id,
          "using existing entry instead of adding duplicate",
        );
      }
    }

    return playerTable;
  }

  /**
   * Get current player's ID
   * @returns {string|null}
   */
  getMyPlayerId() {
    return (
      this.netplay?.engine?.sessionState?.localPlayerId ||
      this.netplay?.name ||
      null
    );
  }

  /**
   * Convert slot number to display text
   * @param {number} slot - Slot number (0-8)
   * @returns {string} Display text (P1-P8 or Spectator)
   */
  getSlotDisplayText(slot) {
    if (slot === 8) {
      return "Spectator";
    }
    return `P${slot + 1}`;
  }

  /**
   * Get status emoji for player in live stream mode
   * @param {Object} player - Player object
   * @returns {string} Status emoji (🖥️ Host, 🎮 Client, 👀 Spectator)
   */
  getPlayerStatusEmoji(player) {
    // Check if host first, then if spectator.
    if (player.is_host) {
      return "🖥️";
    } else if (player.slot === 8) {
      return "👀"; // Spectator
    } else {
      return "🎮";
    }
  }

  /**
   * Check if a player is the host (centralized host determination)
   * @param {Object} player - Player object with id property
   * @returns {boolean} True if this player is the host
   */
  isPlayerHost(player) {
    if (!player || !player.id) return false;

    const myPlayerId = this.getMyPlayerId();
    const myPlayerName = this.netplay?.name;
    const isHost = this.netplay?.engine?.sessionState?.isHostRole() || false;

    // Check if this player represents the current user (by ID or name)
    const isCurrentUser =
      player.id === myPlayerId ||
      (myPlayerName && player.name === myPlayerName) ||
      player.id === this.netplay?.engine?.sessionState?.localPlayerId;

    return isCurrentUser && isHost;
  }

  /**
   * CENTRAL SLOT UPDATE FUNCTION - Only way slots should change
   * @param {string} playerId - Player to update
   * @param {number} newSlot - New slot (0-7) or 8 for spectator
   * @returns {boolean} true if update succeeded
   */
  updatePlayerSlot(playerId, newSlot) {
    const playerTable = this.getPlayerTable();
    const player = playerTable[playerId];

    if (!player) {
      console.warn(
        "[NetplayMenu] Cannot update slot for unknown player:",
        playerId,
      );
      return false;
    }

    // Prevent slot collision (each slot can be occupied by at most one player)
    if (newSlot !== null) {
      for (const [pid, p] of Object.entries(playerTable)) {
        if (pid !== playerId && p.slot === newSlot) {
          console.warn(
            "[NetplayMenu] Slot",
            newSlot,
            "already occupied by player",
            pid,
          );
          return false; // slot already taken
        }
      }
    }

    const oldSlot = player.slot;
    player.slot = newSlot;

    // Update role based on slot
    if (newSlot === 8) {
      player.role = "spectator";
    } else if (newSlot >= 0 && newSlot <= 7) {
      player.role = "player";
    }

    // Also update the joinedPlayers array if the player exists there
    if (this.netplay?.joinedPlayers) {
      const joinedPlayer = this.netplay.joinedPlayers.find(
        (p) => p.id === playerId,
      );
      if (joinedPlayer) {
        joinedPlayer.slot = newSlot;
        if (newSlot === 8) {
          joinedPlayer.role = "spectator";
        } else if (newSlot >= 0 && newSlot <= 7) {
          joinedPlayer.role = "player";
        }
        console.log(
          "[NetplayMenu] Updated slot in joinedPlayers array:",
          playerId,
          oldSlot,
          "->",
          newSlot,
        );
      } else {
        // Player not in joinedPlayers, add them
        this.netplay.joinedPlayers.push({
          id: playerId,
          name: player.name || playerId,
          slot: newSlot,
          role: newSlot === 8 ? "spectator" : "player",
          connected: true,
          ready: false,
        });
        console.log(
          "[NetplayMenu] Added player to joinedPlayers array:",
          playerId,
          "slot:",
          newSlot,
        );
      }
    }

    console.log(
      "[NetplayMenu] Updated player slot:",
      playerId,
      oldSlot,
      "->",
      newSlot,
      "(role:",
      player.role,
      ")",
    );

    // Notify all systems of the change
    this.notifyPlayerTableUpdated();

    return true;
  }

  /**
   * Compute available slots (derived from playerTable, never stored)
   * @param {string} myPlayerId - Current player's ID (to exclude their slot)
   * @param {Array<number>} allSlots - All possible slots [0,1,2,3]
   * @returns {Array<number>} Available slots
   */
  computeAvailableSlots(myPlayerId, allSlots = [0, 1, 2, 3]) {
    const playerTable = this.getPlayerTable();

    // Slots taken by other players (exclude our own slot)
    const taken = new Set(
      Object.values(playerTable)
        .filter(
          (p) =>
            p.playerId !== myPlayerId &&
            p.slot !== null &&
            p.slot !== undefined &&
            p.slot !== 8, // Spectators don't take player slots
        )
        .map((p) => p.slot),
    );

    return allSlots.filter((slot) => !taken.has(slot));
  }

  /**
   * Get slot selector options (derived from playerTable)
   * @param {string} myPlayerId - Current player's ID
   * @param {Array<number>} allSlots - All possible slots [0,1,2,3]
   * @returns {Array<{value: number, text: string, disabled: boolean, selected: boolean}>}
   */
  getSlotSelectorOptions(myPlayerId, allSlots = [0, 1, 2, 3]) {
    // Find local player from player table (which ensures local player is included)
    const playerTable = this.getPlayerTable();
    const me = playerTable[myPlayerId];

    if (!me) {
      console.warn(
        "[NetplayMenu] Cannot get slot selector options: local player not found in playerTable",
        {
          myPlayerId,
          localPlayerId: this.netplay?.engine?.sessionState?.localPlayerId,
          localPlayerName: this.netplay?.name,
        },
      );
      return [];
    }

    const available = this.computeAvailableSlots(myPlayerId, allSlots);
    const options = [];

    // Get current player's slot from player table (synchronized with UI updates)
    let currentPlayerSlot = me.slot;

    // Debug: Log player table slot info
    console.log("[NetplayMenu] Slot selector player table debug:");
    console.log("  myPlayerId:", myPlayerId);
    console.log("  currentPlayerSlot from table:", currentPlayerSlot);
    console.log("  player table entry:", me);

    // Ensure we have a valid player slot (player table should always provide this)
    if (currentPlayerSlot === null || currentPlayerSlot === undefined) {
      console.warn(
        "[NetplayMenu] Player table returned invalid slot, defaulting to 0",
      );
      currentPlayerSlot = 0;
    }

    // Always include current slot first (now guaranteed to be a valid player slot)
    options.push({
      value: currentPlayerSlot,
      text: this.getSlotDisplayText(currentPlayerSlot),
      disabled: false,
      selected: true,
    });

    // Add available slots
    for (const slot of available) {
      if (slot !== currentPlayerSlot) {
        // Don't duplicate current slot
        options.push({
          value: slot,
          text: this.getSlotDisplayText(slot),
          disabled: false,
          selected: false,
        });
      }
    }

    // Add spectator option (never auto-selected - user must choose it explicitly)
    options.push({
      value: 8, // Special value for spectator
      text: "Spectator",
      disabled: false,
      selected: currentPlayerSlot === 8,
    });

    return options;
  }

  /**
   * Request a slot change (UI intent -> authoritative update)
   * @param {number} newSlot - Requested slot (0-3) or 4 for spectator
   */
  requestSlotChange(newSlot) {
    console.log(
      "[NetplayMenu] requestSlotChange called with newSlot:",
      newSlot,
    );

    // Try to get engine from multiple sources (handles case where engine was cleared)
    const engine =
      this.netplay?.engine || this.emulator.netplay?.engine || this.engine;
    if (!engine || !engine.sessionState) {
      console.warn(
        "[NetplayMenu] Cannot request slot change: engine or sessionState not available",
      );
      return;
    }

    // Find local player using session state (more reliable than player table)
    const localPlayerId = engine.sessionState?.localPlayerId;
    const localPlayerName = this.netplay?.name;

    let me = null;
    if (localPlayerId) {
      // Try to find by session state ID first
      me = this.netplay?.joinedPlayers?.find((p) => p.id === localPlayerId);
    }
    if (!me && localPlayerName) {
      // Fallback to finding by name
      me = this.netplay?.joinedPlayers?.find((p) => p.name === localPlayerName);
    }

    if (!me) {
      console.warn(
        "[NetplayMenu] Cannot request slot change: local player not found in joinedPlayers",
        {
          localPlayerId,
          localPlayerName,
          joinedPlayersCount: this.netplay?.joinedPlayers?.length,
        },
      );
      return;
    }

    // Convert spectator (4) to slot 8
    const actualSlot = newSlot === 4 ? 8 : newSlot;

    if (me.slot === actualSlot) {
      console.log(
        "[NetplayMenu] Slot change requested but already in slot:",
        actualSlot,
      );
      return;
    }

    console.log(
      "[NetplayMenu] Requesting slot change:",
      me.id,
      me.slot,
      "->",
      actualSlot,
    );

    // Update local state optimistically before server request
    this.updatePlayerSlot(me.id, actualSlot);

    this.notifyServerOfSlotChange(actualSlot);
  }

  /**
   * Notify server of slot change
   * @param {number|null} slot
   */
  async notifyServerOfSlotChange(slot) {
    console.log(
      "[NetplayMenu] notifyServerOfSlotChange called with slot:",
      slot,
    );

    // Try to get engine from multiple sources (handles case where engine was cleared)
    const engine =
      this.netplay?.engine || this.emulator.netplay?.engine || this.engine;

    console.log("[NetplayMenu] roomManager exists:", !!engine?.roomManager);
    console.log(
      "[NetplayMenu] slot condition check:",
      slot === 8 || (slot >= 0 && slot < 4),
    );

    if (engine?.roomManager && (slot === 8 || (slot >= 0 && slot < 4))) {
      try {
        console.log(
          "[NetplayMenu] Calling roomManager.updatePlayerSlot with slot:",
          slot,
        );
        await engine.roomManager.updatePlayerSlot(slot);

        // Update global slot variable for SimpleController
        window.EJS_NETPLAY_PREFERRED_SLOT = slot;
        this.netplay.localSlot = slot;

        console.log(
          "[NetplayMenu] Successfully notified server of slot change:",
          slot,
        );
        console.log(
          "[NetplayMenu] Updated window.EJS_NETPLAY_PREFERRED_SLOT to:",
          slot,
        );
      } catch (error) {
        console.error(
          "[NetplayMenu] Failed to notify server of slot change:",
          error,
        );
        console.error("[NetplayMenu] Error details:", error.message);
      }
    } else {
      console.log(
        "[NetplayMenu] Skipping server notification - not in room or invalid slot",
      );
    }
  }

  /**
   * NOTIFICATION SYSTEM - Called whenever playerTable changes for any reason
   */
  notifyPlayerTableUpdated() {
    console.log(
      "[NetplayMenu] Player table updated, refreshing all dependent UI",
    );

    // Update slot selector UI
    this.updateSlotSelectorUI();

    // Update input sync with new slot
    this.updateInputSyncWithCurrentSlot();

    // Update player table display
    if (this.netplay.liveStreamPlayerTable) {
      this.netplayUpdatePlayerTable(this.netplay.joinedPlayers); // Uses real data
    }

    // Update taken slots tracking (for backward compatibility)
    this.updateTakenSlotsFromPlayerTable();

    // Update ready and launch button states (for delay sync rooms)
    const room = this.emulator.netplay.currentRoom;
    if (room && room.netplay_mode === "delay_sync") {
      this.netplayUpdateReadyButton();
      this.netplayUpdateLaunchButton();
    }
  }

  /**
   * NOTIFICATION SYSTEM - Called for targeted updates (avoids full table rebuild)
   */
  notifyPlayerTableUpdatedTargeted() {
    console.log(
      "[NetplayMenu] Player table updated (targeted), refreshing dependent UI only",
    );

    // Update slot selector UI
    this.updateSlotSelectorUI();

    // Update input sync with new slot
    this.updateInputSyncWithCurrentSlot();

    // Update taken slots tracking (for backward compatibility)
    this.updateTakenSlotsFromPlayerTable();

    // SKIP: Full table rebuild - we only updated specific cells
  }

  /**
   * Update slot selector UI from playerTable
   */
  updateSlotSelectorUI() {
    if (!this.netplay?.slotSelect) return;

    const myPlayerId = this.getMyPlayerId();
    if (!myPlayerId) return;

    const options = this.getSlotSelectorOptions(myPlayerId);

    // Check if spectator option already exists
    const existingSpectator =
      this.netplay.slotSelect.querySelector('option[value="8"]');

    // Clear existing options
    this.netplay.slotSelect.innerHTML = "";

    // Add new options
    for (const option of options) {
      if (option.value === 8 && existingSpectator) {
        this.netplay.slotSelect.appendChild(existingSpectator);
        continue;
      }
      const opt = this.createElement("option");
      opt.value = String(option.value);
      opt.innerText = option.text;
      if (option.disabled) opt.disabled = true;
      if (option.selected) opt.selected = true;
      this.netplay.slotSelect.appendChild(opt);
    }

    console.log(
      "[NetplayMenu] Updated slot selector UI with",
      options.length,
      "options",
    );
  }

  /**
   * Update input sync to use current slot from playerTable
   */
  updateInputSyncWithCurrentSlot() {
    // Find local player directly from joinedPlayers
    const localPlayerId = this.netplay?.engine?.sessionState?.localPlayerId;
    const localPlayerName = this.netplay?.name;

    let me = null;
    if (localPlayerId) {
      me = this.netplay?.joinedPlayers?.find((p) => p.id === localPlayerId);
    }
    if (!me && localPlayerName) {
      me = this.netplay?.joinedPlayers?.find((p) => p.name === localPlayerName);
    }

    const mySlot = me?.slot;

    // Update InputSync slot manager
    if (
      this.netplay?.engine?.inputSync?.slotManager &&
      mySlot !== null &&
      mySlot !== undefined
    ) {
      const playerId = me.id;
      const assignedSlot = this.netplay.engine.inputSync.slotManager.assignSlot(
        playerId,
        mySlot,
      );
      console.log(
        "[NetplayMenu] Updated InputSync slot manager:",
        playerId,
        "-> slot",
        assignedSlot,
      );
    }

    // Update global slot preference
    if (typeof window !== "undefined") {
      window.EJS_NETPLAY_PREFERRED_SLOT = mySlot;
    }

    // Clear SimpleController cache for slot changes
    if (this.netplay?.engine?.inputSync?.controller?.lastInputValues) {
      this.netplay.engine.inputSync.controller.lastInputValues = {};
    }
  }

  /**
   * Update taken slots tracking (for backward compatibility with existing code)
   */
  updateTakenSlotsFromPlayerTable() {
    if (!this.netplay.takenSlots) {
      this.netplay.takenSlots = new Set();
    }
    this.netplay.takenSlots.clear();

    const playerTable = this.getPlayerTable();
    for (const player of Object.values(playerTable)) {
      if (
        player.slot !== null &&
        player.slot !== undefined &&
        player.slot !== 8 && // Spectators don't take player slots
        player.slot < 4
      ) {
        this.netplay.takenSlots.add(player.slot);
      }
    }
  }
  show() {
    if (this.netplayMenu) {
      this.netplayMenu.style.display = "block";
      this.setupNetplayBottomBar("listings");

      // Switch to rooms tab when showing listings
      if (this.netplay.tabs && this.netplay.tabs[0] && this.netplay.tabs[1]) {
        this.netplay.tabs[0].style.display = ""; // Show rooms tab
        this.netplay.tabs[1].style.display = "none"; // Hide joined tab
      }
    }
  }

  hide() {
    if (this.netplayMenu) {
      this.netplayMenu.style.display = "none";
      this.restoreNormalBottomBar();
    }
  }

  // Returns true if the menu is visible, false otherwise, optional isHidden does opposite.
  isVisible() {
    return this.netplayMenu && this.netplayMenu.style.display !== "none";
  }
  isHidden() {
    return !this.isVisible();
  }

  // All netplay menu functions are now methods of the NetplayMenu class
  netplayShowHostPausedOverlay() {
    try {
      // Only relevant for spectators/clients.
      if (!this.netplay || this.netplay.owner) return;

      // If an older build created a second overlay element, remove it so we can
      // only ever show the message in one place.
      try {
        if (
          this.netplayHostPausedElem &&
          this.netplayHostPausedElem.parentNode
        ) {
          this.netplayHostPausedElem.parentNode.removeChild(
            this.netplayHostPausedElem,
          );
        }
        this.netplayHostPausedElem = null;
      } catch (e) {
        // ignore
      }

      // Standard top-left toast message. Use a long timeout so it effectively
      // persists until host resumes or SFU restarts.
      this.displayMessage("Host has paused emulation", 24 * 60 * 60 * 1000);
    } catch (e) {
      // Best-effort.
    }
  }

  netplayHideHostPausedOverlay() {
    try {
      // Remove legacy overlay element if present.
      try {
        if (
          this.netplayHostPausedElem &&
          this.netplayHostPausedElem.parentNode
        ) {
          this.netplayHostPausedElem.parentNode.removeChild(
            this.netplayHostPausedElem,
          );
        }
        this.netplayHostPausedElem = null;
      } catch (e) {
        // ignore
      }

      // Clear the paused message if it's currently being shown.
      if (
        this.msgElem &&
        this.msgElem.innerText === "Host has paused emulation"
      ) {
        clearTimeout(this.msgTimeout);
        this.msgElem.innerText = "";
      }
    } catch (e) {
      // Best-effort.
    }
  }

  netplaySetupDelaySyncLobby() {
    console.log("[Netplay] Setting up delay sync lobby interface");

    // Ensure we're on the joined tab
    if (this.netplay.tabs && this.netplay.tabs[0] && this.netplay.tabs[1]) {
      this.netplay.tabs[0].style.display = "none";
      this.netplay.tabs[1].style.display = "";
    }

    // Stop room list refresh (if not already stopped)
    if (this.netplay.updateList) {
      this.netplay.updateList.stop();
    }

    // Update table headers for lobby
    if (this.netplay.playerTable && this.netplay.playerTable.parentElement) {
      const table = this.netplay.playerTable.parentElement;
      const thead = table.querySelector("thead");
      if (thead) {
        const headerRow = thead.querySelector("tr");
        if (headerRow && headerRow.children.length >= 3) {
          headerRow.children[2].innerText = "Status";
        }
      }
    }

    // Hide normal joined controls (bottom bar handles the buttons now)
    if (this.netplay.tabs && this.netplay.tabs[1]) {
      const joinedDiv = this.netplay.tabs[1];
      const joinedControls = joinedDiv.querySelector(".ejs_netplay_header");
      if (joinedControls) {
        joinedControls.style.display = "none";
      }
    }

    // Mark as in lobby mode
    this.netplay.isInDelaySyncLobby = true;

    // Add debug ping test button for lobby
    this.addPingTestButton();
  }

  /**
   * Add a debug button to test ping functionality in lobby
   */
  addPingTestButton() {
    // Remove existing ping test button if it exists
    const existingButton = document.getElementById("ejs-netplay-ping-test");
    if (existingButton) {
      existingButton.remove();
    }

    // Create ping test button
    const pingButton = document.createElement("button");
    pingButton.id = "ejs-netplay-ping-test";
    pingButton.innerHTML = "🔄 Test Ping";
    pingButton.style.cssText = `
      position: fixed;
      top: 60px;
      right: 10px;
      z-index: 10000;
      background: #007bff;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    `;

    pingButton.onclick = () => {
      try {
        if (window.EJS_emulator && window.EJS_emulator.netplayEngine) {
          const engine = window.EJS_emulator.netplayEngine;

          if (pingButton.innerHTML.includes("Test Ping")) {
            // Start ping test
            console.log("[NetplayMenu] Starting ping test...");
            engine.startPingTest();
            pingButton.innerHTML = "⏹️ Stop Ping";
            pingButton.style.background = "#dc3545";
          } else {
            // Stop ping test
            console.log("[NetplayMenu] Stopping ping test...");
            engine.stopPingTest();
            pingButton.innerHTML = "🔄 Test Ping";
            pingButton.style.background = "#007bff";
          }
        } else {
          console.error(
            "[NetplayMenu] Netplay engine not available for ping test",
          );
          alert("Netplay engine not available");
        }
      } catch (error) {
        console.error("[NetplayMenu] Error with ping test:", error);
        alert("Error with ping test: " + error.message);
      }
    };

    // Create ordered mode test button
    const orderedButton = document.createElement("button");
    orderedButton.id = "ejs-netplay-ordered-test";
    orderedButton.innerHTML = "📋 Ordered Mode";
    orderedButton.style.cssText = `
      position: fixed;
      top: 90px;
      right: 10px;
      z-index: 10000;
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    `;

    orderedButton.onclick = () => {
      try {
        if (window.EJS_emulator && window.EJS_emulator.netplayEngine) {
          const engine = window.EJS_emulator.netplayEngine;

          if (orderedButton.innerHTML.includes("Ordered Mode")) {
            // Force ordered mode
            console.log("[NetplayMenu] Forcing ordered mode for testing...");
            const originalMode = engine.forceOrderedMode(true);
            orderedButton.innerHTML = "🔄 Unordered Mode";
            orderedButton.style.background = "#ffc107";
            orderedButton.style.color = "black";
            orderedButton._originalMode = originalMode;
          } else {
            // Restore original mode
            console.log("[NetplayMenu] Restoring unordered mode...");
            if (orderedButton._originalMode) {
              engine.forceOrderedMode(false);
            }
            orderedButton.innerHTML = "📋 Ordered Mode";
            orderedButton.style.background = "#28a745";
            orderedButton.style.color = "white";
          }
        } else {
          console.error(
            "[NetplayMenu] Netplay engine not available for ordered mode test",
          );
          alert("Netplay engine not available");
        }
      } catch (error) {
        console.error("[NetplayMenu] Error with ordered mode test:", error);
        alert("Error with ordered mode test: " + error.message);
      }
    };

    // Add hover effect
    orderedButton.onmouseover = () => {
      orderedButton.style.opacity = "0.8";
    };
    orderedButton.onmouseout = () => {
      orderedButton.style.opacity = "1";
    };

    document.body.appendChild(orderedButton);

    // Add hover effect
    pingButton.onmouseover = () => {
      pingButton.style.opacity = "0.8";
    };
    pingButton.onmouseout = () => {
      pingButton.style.opacity = "1";
    };

    document.body.appendChild(pingButton);
    console.log("[NetplayMenu] Added ping test button to lobby");
  }

  // Switch to live stream room UI
  netplaySwitchToLiveStreamRoom(roomName, password) {
    if (!this.netplayMenu) return;

    // Ensure netplay object and tabs are initialized
    if (
      !this.emulator.netplay ||
      !this.emulator.netplay.tabs ||
      !this.emulator.netplay.tabs[1]
    ) {
      console.warn(
        "[NetplayMenu] netplaySwitchToLiveStreamRoom: tabs not initialized, ensuring menu is set up",
      );
      // Ensure menu is properly initialized - tabs should exist if menu exists
      // If menu exists but tabs don't, we need to recreate them
      if (this.netplayMenu) {
        // Try to find the tabs in the DOM
        const popupBody = this.netplayMenu.querySelector(".ejs_popup_body");
        if (popupBody) {
          const children = Array.from(popupBody.children);
          const roomsTab = children.find((el) =>
            el.querySelector(".ejs_netplay_table"),
          );
          const joinedTab =
            children.find(
              (el) =>
                el.querySelector("strong") &&
                el.innerText.includes("{roomname}"),
            ) || children.find((el) => el !== roomsTab && el.tagName === "DIV");

          if (roomsTab && joinedTab) {
            if (!this.emulator.netplay) {
              this.emulator.netplay = {};
            }
            this.emulator.netplay.tabs = [roomsTab, joinedTab];
            console.log("[NetplayMenu] Recovered tabs from DOM");
          }
        }
      }

      // If still no tabs, we can't proceed
      if (
        !this.emulator.netplay ||
        !this.emulator.netplay.tabs ||
        !this.emulator.netplay.tabs[1]
      ) {
        console.error(
          "[NetplayMenu] Cannot switch to live stream room - tabs not available",
        );
        return;
      }
    }

    // Check if host and player slot at the beginning
    const isHost =
      this.emulator.netplay?.engine?.sessionState?.isHostRole() || false;

    // Remove existing slot selector if it exists (to prevent duplication)
    const joinedDiv = this.emulator.netplay.tabs[1];
    if (
      this.emulator.netplay.slotSelect &&
      this.emulator.netplay.slotSelect.parentElement
    ) {
      // Find and remove the label "Player Select:" that comes before the selector
      const slotSelectParent = this.emulator.netplay.slotSelect.parentElement;
      const slotLabel = Array.from(slotSelectParent.childNodes).find(
        (node) =>
          node.nodeType === Node.ELEMENT_NODE &&
          node.tagName === "STRONG" &&
          (node.innerText.includes("Player Select") ||
            node.innerText.includes("Player Slot")),
      );
      if (slotLabel) {
        slotLabel.remove();
      }
      this.emulator.netplay.slotSelect.remove();
      console.log(
        "[NetplayMenu] Removed existing slot selector before creating new one",
      );
    }

    // Create the slot selector
    const slotSelect = this.createSlotSelector(joinedDiv, "prepend");
    this.emulator.netplay.slotSelect = slotSelect;

    // Update the slot selector with current available slots.
    this.netplayUpdateSlotSelector();

    // For livestream clients, hide the canvas immediately so video can be displayed
    if (!isHost) {
      if (
        this.emulator &&
        this.emulator.canvas &&
        this.emulator.canvas.style.display !== "none"
      ) {
        console.log("[NetplayMenu] Hiding canvas for livestream client");
        this.emulator.canvas.style.display = "none";
      }
      // Attach video live stream track
      this.netplayAttachConsumerTrack(track, kind);
    }

    // Stop room list fetching
    if (this.emulator.netplay && this.emulator.netplay.updateList) {
      this.emulator.netplay.updateList.stop();
    }

    // Hide lobby tabs and show live stream room
    if (
      this.emulator.netplay.tabs &&
      this.emulator.netplay.tabs[0] &&
      this.emulator.netplay.tabs[1]
    ) {
      this.emulator.netplay.tabs[0].style.display = "none";
      this.emulator.netplay.tabs[1].style.display = "";
    }

    // Update title
    const titleElement = this.netplayMenu.querySelector("h4");
    if (titleElement) {
      titleElement.innerText = "Live Stream Room";
    }

    // Update room name and password display
    if (this.emulator.netplay.roomNameElem) {
      this.netplay.roomNameElem.innerText = roomName;
    }
    if (this.netplay.passwordElem) {
      this.netplay.passwordElem.innerText = password
        ? `Password: ${password}`
        : "";
      this.netplay.passwordElem.style.display = password ? "" : "none";
    }

    // Create the Live Stream UI if it doesn't exist.
    if (!this.netplay.liveStreamPlayerTable) {
      // Reorder elements: move room name above slot selector
      if (
        this.netplay.roomNameElem &&
        this.netplay.slotSelect &&
        this.netplay.slotSelect.parentElement
      ) {
        const joinedContainer =
          this.netplay.slotSelect.parentElement.parentElement;
        const slotControls = this.netplay.slotSelect.parentElement;
        // Move room name to be right above the slot selector
        joinedContainer.insertBefore(this.netplay.roomNameElem, slotControls);
      }

      // Create the player table
      const table = this.createNetplayTable("livestream");

      // Insert table after the slot selector
      if (this.netplay.slotSelect && this.netplay.slotSelect.parentElement) {
        this.netplay.slotSelect.parentElement.parentElement.insertBefore(
          table,
          this.netplay.slotSelect.parentElement.nextSibling,
        );
      }
    }

    // Hide delay sync table if it exists (we're in live stream mode)
    if (
      this.netplay.delaySyncPlayerTable &&
      this.netplay.delaySyncPlayerTable.parentElement
    ) {
      const table = this.netplay.delaySyncPlayerTable.parentElement;
      table.style.display = "none";
    }

    // Show live stream table
    if (
      this.netplay.liveStreamPlayerTable &&
      this.netplay.liveStreamPlayerTable.parentElement
    ) {
      const table = this.netplay.liveStreamPlayerTable.parentElement;
      table.style.display = "";
    }

    // CRITICAL: Set currentRoomType BEFORE updating player table
    // (netplayUpdatePlayerTable checks currentRoomType and will skip if not set)
    this.currentRoomType = "livestream";

    // Setup the bottom bar buttons (this also sets currentRoomType, but we set it above to be safe)
    this.setupNetplayBottomBar("livestream");

    // This populates and updates the table.
    // Call after setting currentRoomType so the guard doesn't skip it
    this.netplayUpdatePlayerTable(this.netplay.joinedPlayers); // Uses real data

    // Also update after a short delay in case users-updated event arrives after this function completes
    // This ensures the table gets populated even if joinedPlayers is empty initially
    setTimeout(() => {
      if (this.netplay.joinedPlayers && this.netplay.joinedPlayers.length > 0) {
        console.log(
          "[NetplayMenu] Delayed live stream player table update with",
          this.netplay.joinedPlayers.length,
          "players",
        );
        this.netplayUpdatePlayerTable(this.netplay.joinedPlayers);
      }
    }, 500);

    // Setup input syncing for non-host players
    // Use setTimeout to ensure engine is fully initialized
    setTimeout(() => {
      this.netplaySetupLiveStreamInputSync();
    }, 100);

    this.isNetplay = true;
    // Set global EJS netplay state for GameManager.simulateInput()
    if (window.EJS) {
      window.EJS.isNetplay = true;
    }
  }

  // Switch to delay sync room UI
  netplaySwitchToDelaySyncRoom(roomName, password, maxPlayers) {
    if (!this.netplayMenu) return;

    // Stop room list fetching
    if (this.netplay && this.netplay.updateList) {
      this.netplay.updateList.stop();
    }

    // Hide lobby tabs and show delay sync room
    if (this.netplay.tabs && this.netplay.tabs[0] && this.netplay.tabs[1]) {
      this.netplay.tabs[0].style.display = "none";
      this.netplay.tabs[1].style.display = "";
    }

    // Update title
    const titleElement = this.netplayMenu.querySelector("h4");
    if (titleElement) {
      titleElement.innerText = "Delay Sync Room";
    }

    // Update room name and password display
    if (this.netplay.roomNameElem) {
      this.netplay.roomNameElem.innerText = roomName;
    }
    if (this.netplay.passwordElem) {
      this.netplay.passwordElem.innerText = password
        ? `Password: ${password}`
        : "";
      this.netplay.passwordElem.style.display = password ? "" : "none";
    }

    // Ensure slot selector exists first (must be before player table)
    if (!this.netplay.slotSelect) {
      // Use netplaySetupSlotSelector which creates and initializes the listener
      this.netplaySetupSlotSelector();

      // Ensure the container is positioned correctly for delay sync
      if (this.netplay.slotSelect && this.netplay.slotSelect.parentElement) {
        const slotContainer = this.netplay.slotSelect.parentElement;
        const joinedDiv = this.netplay.tabs[1];

        // Move container to be after room name/password if needed
        if (
          joinedDiv &&
          this.netplay.passwordElem &&
          this.netplay.passwordElem.parentElement === joinedDiv
        ) {
          const nextSibling = this.netplay.passwordElem.nextSibling;
          if (nextSibling !== slotContainer) {
            joinedDiv.insertBefore(
              slotContainer,
              this.netplay.passwordElem.nextSibling,
            );
          }
        } else if (
          joinedDiv &&
          this.netplay.roomNameElem &&
          this.netplay.roomNameElem.parentElement === joinedDiv
        ) {
          const nextSibling = this.netplay.roomNameElem.nextSibling;
          if (nextSibling !== slotContainer) {
            joinedDiv.insertBefore(
              slotContainer,
              this.netplay.roomNameElem.nextSibling,
            );
          }
        }

        // Ensure container has proper styling
        slotContainer.classList.add("ejs_netplay_header");
        slotContainer.style.display = "flex";
        slotContainer.style.alignItems = "center";
        slotContainer.style.gap = "10px";
        slotContainer.style.margin = "10px 0";
        slotContainer.style.justifyContent = "center";
      }

      // Ensure event listener is attached using native onchange (backup/override)
      const slotSelect = this.netplay.slotSelect;
      if (slotSelect) {
        console.log(
          "[NetplayMenu] Ensuring native event listener for delay sync",
        );
        slotSelect.onchange = () => {
          console.log("[NetplayMenu] Native onchange fired for slot selector");
          const raw = parseInt(slotSelect.value, 10);
          const slot = isNaN(raw) ? 0 : Math.max(0, Math.min(8, raw));
          console.log("[NetplayMenu] Slot selector changed to:", slot);

          // Use centralized slot change system
          this.requestSlotChange(slot);

          // Update the slot selector UI after slot change
          this.netplayUpdateSlotSelector();

          // Reapply styling after update (since it clears innerHTML)
          const updatedSelect = this.netplay.slotSelect;
          if (updatedSelect) {
            updatedSelect.setAttribute(
              "style",
              "background-color: #333 !important; " +
                "border: 1px solid #555 !important; " +
                "border-radius: 4px !important; " +
                "padding: 4px 8px !important; " +
                "min-width: 80px !important; " +
                "cursor: pointer !important; " +
                "color: #fff !important;",
            );
            // Reattach listener after update
            updatedSelect.onchange = slotSelect.onchange;
          }

          // Save settings
          if (this.settings) {
            this.settings.netplayPreferredSlot = String(slot);
          }
          this.saveSettings();
        };
      }
    } else {
      // Slot selector already exists - ensure it's visible and styled
      const slotSelect = this.netplay.slotSelect;
      if (slotSelect && slotSelect.parentElement) {
        slotSelect.parentElement.style.display = "flex";
        slotSelect.parentElement.style.justifyContent = "center";
      }
      if (slotSelect) {
        slotSelect.style.display = "";
        // Reapply styling
        slotSelect.setAttribute(
          "style",
          "background-color: #333 !important; " +
            "border: 1px solid #555 !important; " +
            "border-radius: 4px !important; " +
            "padding: 4px 8px !important; " +
            "min-width: 80px !important; " +
            "cursor: pointer !important; " +
            "color: #fff !important;",
        );
        // Ensure listener is attached
        if (!slotSelect.onchange) {
          slotSelect.onchange = () => {
            const raw = parseInt(slotSelect.value, 10);
            const slot = isNaN(raw) ? 0 : Math.max(0, Math.min(8, raw));
            this.requestSlotChange(slot);
            this.netplayUpdateSlotSelector();
            const updatedSelect = this.netplay.slotSelect;
            if (updatedSelect) {
              updatedSelect.setAttribute(
                "style",
                "background-color: #333 !important; " +
                  "border: 1px solid #555 !important; " +
                  "border-radius: 4px !important; " +
                  "padding: 4px 8px !important; " +
                  "min-width: 80px !important; " +
                  "cursor: pointer !important; " +
                  "color: #fff !important;",
              );
              updatedSelect.onchange = slotSelect.onchange;
            }
            if (this.settings) {
              this.settings.netplayPreferredSlot = String(slot);
            }
            this.saveSettings();
          };
        }
      }
    }

    // Create the Delay Sync player table if it doesn't exist
    if (!this.netplay.delaySyncPlayerTable) {
      // Create the player table
      const table = this.createNetplayTable("delaysync");

      // Insert table after the slot selector (as sibling of slot selector's parent container)
      if (this.netplay.slotSelect && this.netplay.slotSelect.parentElement) {
        this.netplay.slotSelect.parentElement.parentElement.insertBefore(
          table,
          this.netplay.slotSelect.parentElement.nextSibling,
        );
      }
    }

    // Hide live stream table if it exists (we're in delay sync mode)
    if (
      this.netplay.liveStreamPlayerTable &&
      this.netplay.liveStreamPlayerTable.parentElement
    ) {
      const table = this.netplay.liveStreamPlayerTable.parentElement;
      table.style.display = "none";
    }

    // Show delay sync table
    if (
      this.netplay.delaySyncPlayerTable &&
      this.netplay.delaySyncPlayerTable.parentElement
    ) {
      const table = this.netplay.delaySyncPlayerTable.parentElement;
      table.style.display = "";
    }

    // CRITICAL: Set currentRoomType BEFORE updating player table
    // (netplayUpdatePlayerTable checks currentRoomType and will skip if not set)
    this.currentRoomType = "delaysync";

    // Bottom bar buttons for Delay Sync mode (this also sets currentRoomType, but we set it above to be safe)
    this.setupNetplayBottomBar("delaysync");

    // Initialize player list (host is always player 1)
    // Call after setting currentRoomType so the guard doesn't skip it
    this.netplayUpdatePlayerTable(this.netplay.joinedPlayers);

    // Also update after a short delay in case users-updated event arrives after this function completes
    // This ensures the table gets populated even if joinedPlayers is empty initially
    setTimeout(() => {
      if (this.netplay.joinedPlayers && this.netplay.joinedPlayers.length > 0) {
        console.log(
          "[NetplayMenu] Delayed delay sync player table update with",
          this.netplay.joinedPlayers.length,
          "players",
        );
        this.netplayUpdatePlayerTable(this.netplay.joinedPlayers);
      }
    }, 500);

    // Update ready and launch button states
    this.netplayUpdateReadyButton();
    this.netplayUpdateLaunchButton();

    // Also update buttons after a short delay to ensure player data has arrived
    // (users-updated event might arrive after this function completes)
    setTimeout(() => {
      this.netplayUpdateReadyButton();
      this.netplayUpdateLaunchButton();
    }, 500);

    this.isNetplay = true;
    // Set global EJS netplay state for GameManager.simulateInput()
    if (window.EJS) {
      window.EJS.isNetplay = true;
    }
  }

  // Create a centralized table management system
  createNetplayTable(tableType, container = null) {
    const tableConfigs = {
      listings: {
        headers: [
          { text: "Room Type", width: "100px" },
          { text: "Room Name", align: "center" },
          { text: "Players", width: "80px" },
          { text: "", width: "80px" },
        ],
        reference: "table",
      },
      livestream: {
        headers: [
          { text: "Player", width: "60px", align: "center" },
          { text: "Name", align: "center" },
          { text: "Status", width: "60px", align: "center" },
        ],
        reference: "liveStreamPlayerTable",
      },
      delaysync: {
        headers: [
          { text: "Player", width: "60px", align: "center" },
          { text: "Name", align: "center" },
          { text: "Status", width: "80px", align: "center" },
        ],
        reference: "delaySyncPlayerTable",
      },
    };

    const config = tableConfigs[tableType];
    if (!config) return null;

    // Create table
    const table = this.createElement("table");
    table.classList.add("ejs_netplay_table");
    table.style.width = "100%";
    table.setAttribute("cellspacing", "0");

    // Create header
    const thead = this.createElement("thead");
    const headerRow = this.createElement("tr");

    config.headers.forEach((header) => {
      const th = this.createElement("td");
      th.innerText = header.text;
      th.style.fontWeight = "bold";
      if (header.width) th.style.width = header.width;
      if (header.align) th.style.textAlign = header.align;
      headerRow.appendChild(th);
    });

    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Create body
    const tbody = this.createElement("tbody");
    this.netplay[config.reference] = tbody;
    table.appendChild(tbody);

    // Add to container if specified
    if (container) {
      container.appendChild(table);
    }

    return table;
  }

  setupNetplayBottomBar(roomType, popupBody = null) {
    this.currentRoomType = roomType;

    // Always hide the original emulator bottom bar
    if (this.emulator.elements.menu) {
      this.emulator.elements.menu.style.display = "none";
    }

    // Create our netplay bottom bar if it doesn't exist
    if (!this.netplayBottomBar) {
      this.netplayBottomBar = this.createElement("div");
      this.netplayBottomBar.classList.add("ejs_menu_bar"); // Same styling as original
      this.netplayBottomBar.classList.add("ejs_menu_bar_hidden"); // Start hidden like original

      // Copy positioning from original bottom bar
      const originalBar = this.emulator.elements.menu;
      if (originalBar && originalBar.parentElement) {
        originalBar.parentElement.appendChild(this.netplayBottomBar);
      }

      // Add the same background and styling, with mobile adjustments
      const isMobile = this.isMobileDevice();
      this.netplayBottomBar.style.background = "rgba(0,0,0,0.8)";
      this.netplayBottomBar.style.position = "absolute";
      this.netplayBottomBar.style.display = "flex";
      this.netplayBottomBar.style.justifyContent = "center";
      this.netplayBottomBar.style.alignItems = "center";
      this.netplayBottomBar.style.gap = isMobile ? "6px" : "10px";
      this.netplayBottomBar.style.bottom = "0";
      this.netplayBottomBar.style.left = "0";
      this.netplayBottomBar.style.right = "0";
      this.netplayBottomBar.style.zIndex = "10000";
      this.netplayBottomBar.style.padding = isMobile ? "6px 8px" : "10px 15px";
      this.netplayBottomBar.style.minHeight = isMobile ? "40px" : "50px";
    }

    // Always show the netplay bottom bar
    this.netplayBottomBar.classList.remove("ejs_menu_bar_hidden");
    this.netplayBottomBar.style.display = "";

    // Handle room-type-specific setup
    if (roomType === "listings") {
      // Start room list fetching for listings mode
      if (this.netplay && this.netplay.updateList) {
        this.netplay.updateList.start();
      }
    } else {
      // For room modes, clear any popup buttons (but keep popup visible for room interface)
      if (this.netplayMenu) {
        const popupContainer =
          this.netplayMenu.querySelector(".ejs_popup_body");
        if (popupContainer) {
          const buttons =
            popupContainer.parentElement.querySelectorAll(".ejs_button");
          buttons.forEach((button) => button.remove());
        }
      }

      // Set netplay state for actual game rooms
      this.isNetplay = true;
      // Set global EJS netplay state for GameManager.simulateInput()
      if (window.EJS) {
        window.EJS.isNetplay = true;
      }
    }

    // Create appropriate buttons for this room type
    this.createBottomBarButtons(roomType);
  }

  createBottomBarButtons(roomType) {
    // Clear existing buttons
    if (this.netplayBottomBar) {
      this.netplayBottomBar.innerHTML = "";
    }

    const bar = {}; // Button references

    const buttonConfigs = {
      // Listings-specific button
      createRoom: {
        text: "Create a Room",
        action: () => {
          if (!this.netplay || typeof this.netplay.updateList !== "function")
            this.defineNetplayFunctions();
          if (this.isNetplay) {
            this.emulator.netplay.engine.netplayLeaveRoom();
          } else {
            this.showOpenRoomDialog();
          }
        },
        appliesTo: (roomType) => roomType === "listings",
      },

      // Room-specific buttons
      syncReady: {
        text: "Ready",
        action: () => this.netplayToggleReady(),
        appliesTo: (roomType) => roomType.endsWith("sync"),
        property: "readyButton",
      },
      syncLaunch: {
        text: "Launch Game",
        action: () => this.netplayLaunchGame(),
        appliesTo: (roomType) => roomType.endsWith("sync"),
        property: "launchButton",
        disabled: true,
      },
      leaveRoom: {
        text: "Leave Room",
        action: async () => {
          try {
            // Use this.engine (NetplayMenu's reference) which persists even after cleanup
            // this.emulator.netplay.engine gets cleared during cleanup, but this.engine doesn't
            const engine = this.engine || this.emulator.netplay?.engine;
            if (!engine) {
              console.warn(
                "[NetplayMenu] Cannot leave room - engine not available",
              );
              return;
            }
            await engine.netplayLeaveRoom(); // ← Now awaited
          } catch (error) {
            console.error("[NetplayMenu] Error leaving room:", error);
          }
        },
        appliesTo: (roomType) => roomType !== "listings",
      },

      // Universal buttons
      settings: {
        text: "Settings",
        action: () => this.netplaySettingsMenu(),
        appliesTo: () => true,
        style: { backgroundColor: "#666" }, // Grey for passive button
      },
      closeMenu: {
        text: "Close Menu",
        action: () => this.hide(),
        appliesTo: () => true,
        style: { backgroundColor: "#666" }, // Grey for passive button
      },
    };

    this.netplayUpdateReadyButton();
    this.netplayUpdateLaunchButton();

    // Create applicable buttons
    Object.entries(buttonConfigs).forEach(([key, config]) => {
      if (config.appliesTo(roomType)) {
        this.ensureButtonExists(key, config, bar, this.netplayBottomBar);
      }
    });
  }

  // Restore normal bottom bar buttons (hide Delay Sync buttons)
  restoreNormalBottomBar() {
    // Stop room list fetching
    if (this.netplay && this.netplay.updateList) {
      this.netplay.updateList.stop();
    }

    // Hide our netplay bottom bar
    if (this.netplayBottomBar) {
      this.netplayBottomBar.style.display = "none";
    }

    // Show the original emulator bottom bar
    if (this.emulator.elements.menu) {
      this.emulator.elements.menu.style.display = "";
    }
  }

  // Helper method to ensure a button exists and is visible
  ensureButtonExists(key, config, bar, container) {
    const targetContainer = container || this.emulator.elements.menu;
    const isMobile = this.isMobileDevice();

    if (!bar[key]) {
      const btn = this.createElement("a");
      btn.classList.add("ejs_button");
      btn.innerText = config.text;
      btn.style.whiteSpace = "nowrap";

      // Apply mobile-specific button styling
      if (isMobile) {
        btn.style.fontSize = "0.85em";
        btn.style.padding = "6px 10px";
        btn.style.minWidth = "auto";
        btn.style.maxWidth = "120px";
      } else {
        btn.style.fontSize = "0.9em";
        btn.style.padding = "8px 15px";
      }

      if (config.disabled) btn.disabled = true;
      btn.onclick = config.action;

      // Apply custom styling if specified
      if (config.style) {
        Object.assign(btn.style, config.style);
      }

      targetContainer.appendChild(btn); // Add to our container
      bar[key] = [btn];

      if (config.property) {
        this.netplay[config.property] = btn;
      }
    } else {
      bar[key][0].style.display = "";
    }
  }

  // Netplay Settings Menu
  netplaySettingsMenu() {
    const popups = this.createSubPopup();
    const container = popups[0];
    const content = popups[1];
    const isMobile = this.isMobileDevice();

    // Add border styling - tighter for mobile
    content.style.border = "2px solid rgba(var(--ejs-primary-color), 0.3)";
    content.style.borderRadius = isMobile ? "6px" : "8px";
    content.style.padding = isMobile ? "6px" : "8px";
    content.style.maxWidth = isMobile ? "95%" : "100%";
    content.style.maxHeight = isMobile ? "80vh" : "auto";
    content.style.boxSizing = "border-box";
    content.style.overflowY = isMobile ? "auto" : "visible";
    content.classList.add("ejs_cheat_parent");

    // Title - more compact, especially for mobile
    const header = this.createElement("div");
    const title = this.createElement("h2");
    title.innerText = "Netplay Settings";
    title.classList.add("ejs_netplay_name_heading");
    title.style.margin = isMobile ? "0 0 6px 0" : "0 0 8px 0";
    title.style.fontSize = isMobile ? "1.1em" : "1.2em";
    header.appendChild(title);
    content.appendChild(header);

    // Settings container with table - mobile optimized
    const settingsContainer = this.createElement("div");
    settingsContainer.style.maxHeight = isMobile
      ? "calc(100vh - 150px)"
      : "calc(100vh - 200px)";
    settingsContainer.style.overflowY = "auto";
    settingsContainer.style.overflowX = "auto";
    settingsContainer.style.width = "100%";

    // Create table for settings - two columns layout, mobile optimized
    const settingsTable = this.createElement("table");
    settingsTable.style.width = "100%";
    settingsTable.style.borderCollapse = "collapse";
    settingsTable.style.fontSize = isMobile ? "0.85em" : "0.9em";
    settingsTable.style.marginBottom = isMobile ? "6px" : "8px";

    // Helper function to create a table cell for label
    const createLabelCell = (label) => {
      const cell = this.createElement("td");
      cell.innerText = label;
      cell.style.padding = "6px 8px";
      cell.style.fontWeight = "bold";
      cell.style.color = "#fff";
      cell.style.verticalAlign = "middle";
      cell.style.whiteSpace = "nowrap";
      cell.style.width = "25%";
      return cell;
    };

    // Helper function to create a table cell for control
    const createControlCell = (control) => {
      const cell = this.createElement("td");
      cell.style.padding = "4px 8px";
      cell.style.verticalAlign = "middle";
      cell.style.width = "25%";
      cell.appendChild(control);
      return cell;
    };

    // Helper function to create table row with two settings side by side
    const createTwoColumnRow = (label1, control1, label2, control2) => {
      const row = this.createElement("tr");
      row.style.borderBottom = "1px solid rgba(255,255,255,0.1)";

      row.appendChild(createLabelCell(label1));
      row.appendChild(createControlCell(control1));

      if (label2 && control2) {
        row.appendChild(createLabelCell(label2));
        row.appendChild(createControlCell(control2));
      } else {
        // If only one setting, span across two columns
        const emptyCell = this.createElement("td");
        emptyCell.colSpan = 2;
        row.appendChild(emptyCell);
      }

      return row;
    };

    // Helper function to create select dropdown - more compact for two-column layout
    const createSelect = (options, currentValue, onChange) => {
      const select = this.createElement("select");
      select.style.backgroundColor = "#333";
      select.style.color = "#fff";
      select.style.border = "1px solid #555";
      select.style.borderRadius = "4px";
      select.style.padding = "3px 6px";
      select.style.width = "100%";
      select.style.maxWidth = "100%";
      select.style.fontSize = "0.9em";
      select.style.boxSizing = "border-box";

      Object.entries(options).forEach(([value, label]) => {
        const option = this.createElement("option");
        option.value = value;
        option.innerText = label;
        if (value === currentValue) option.selected = true;
        select.appendChild(option);
      });

      if (onChange) {
        this.addEventListener(select, "change", () => onChange(select.value));
      }

      return select;
    };

    // Helper function to get current setting value
    const getSetting = (key, defaultValue) => {
      return (
        this.emulator.getSettingValue(key) || this.emulator[key] || defaultValue
      );
    };

    // Helper function to save setting
    const saveSetting = (key, value) => {
      this.emulator[key] = value;
      this.emulator.saveSettings();
    };

    // SVC with VP9 setting
    const normalizeVP9SVCMode = (v) => {
      const s = typeof v === "string" ? v.trim() : "";
      const sl = s.toLowerCase();
      if (sl === "l1t1") return "L1T1";
      if (sl === "l1t3") return "L1T3";
      if (sl === "l2t3") return "L2T3";
      return "L1T1";
    };

    const vp9SvcSelect = createSelect(
      {
        L1T1: "L1T1",
        L1T3: "L1T3",
        L2T3: "L2T3",
      },
      normalizeVP9SVCMode(getSetting("netplayVP9SVC", "L1T1")),
      (value) => saveSetting("netplayVP9SVC", value),
    );

    // Legacy Simulcast setting
    const simulcastSelect = createSelect(
      {
        enabled: "Enabled",
        disabled: "Disabled",
      },
      getSetting("netplaySimulcast", "disabled"),
      (value) => saveSetting("netplaySimulcast", value),
    );

    // Host Codec setting
    const normalizeHostCodec = (v) => {
      const s = typeof v === "string" ? v.trim().toLowerCase() : "";
      if (s === "vp9" || s === "h264" || s === "vp8" || s === "auto") return s;
      return "auto";
    };

    const hostCodecSelect = createSelect(
      {
        auto: "Auto",
        vp9: "VP9",
        h264: "H264",
        vp8: "VP8",
      },
      normalizeHostCodec(getSetting("netplayHostCodec", "auto")),
      (value) => saveSetting("netplayHostCodec", value),
    );

    // Client Simulcast Quality setting
    const normalizeSimulcastQuality = (v) => {
      const s = typeof v === "string" ? v.trim().toLowerCase() : "";
      if (s === "high" || s === "low") return s;
      if (s === "medium") return "low";
      if (s === "720p") return "high";
      if (s === "360p") return "low";
      if (s === "180p") return "low";
      return "high";
    };

    const clientQualitySelect = createSelect(
      {
        high: "High",
        low: "Low",
      },
      normalizeSimulcastQuality(
        getSetting("netplayClientSimulcastQuality", "high"),
      ),
      (value) => saveSetting("netplayClientSimulcastQuality", value),
    );

    // Retry Connection Timer setting
    const retryTimerSelect = createSelect(
      {
        0: "Disabled",
        1: "1 second",
        2: "2 seconds",
        3: "3 seconds",
        4: "4 seconds",
        5: "5 seconds",
      },
      String(getSetting("netplayRetryConnectionTimer", 3)),
      (value) => saveSetting("netplayRetryConnectionTimer", parseInt(value)),
    );

    // Unordered Retries setting
    const unorderedRetriesSelect = createSelect(
      {
        0: "0",
        1: "1",
        2: "2",
      },
      String(getSetting("netplayUnorderedRetries", 0)),
      (value) => saveSetting("netplayUnorderedRetries", parseInt(value)),
    );

    // Input Mode setting - shows current active mode
    const currentMode =
      this.engine?.dataChannelManager?.mode ||
      getSetting("netplayInputMode", "unorderedRelay");

    const inputModeSelect = createSelect(
      {
        unorderedRelay: "Unordered Relay",
        orderedRelay: "Ordered Relay",
        unorderedP2P: "Unordered P2P",
        orderedP2P: "Ordered P2P",
      },
      currentMode, // Use current active mode, not just saved setting
      (value) => {
        saveSetting("netplayInputMode", value);
        // Trigger immediate mode switch for dynamic transport changes
        if (this.engine?.dataChannelManager) {
          console.log(
            `[NetplayMenu] 🔄 User changed input mode to ${value}, applying immediately`,
          );

          // Show visual feedback during switching
          const selectedOption =
            inputModeSelect.options[inputModeSelect.selectedIndex];
          const originalText = selectedOption.text;
          selectedOption.text = `${originalText} (Switching...)`;
          inputModeSelect.disabled = true;

          this.netplayApplyInputMode("setting-change").finally(() => {
            // Re-enable dropdown and update to show actual current mode
            setTimeout(() => {
              inputModeSelect.disabled = false;
              selectedOption.text = originalText; // Restore original text

              // Update dropdown to reflect the actual active mode
              const activeMode = this.engine?.dataChannelManager?.mode;
              if (activeMode && activeMode !== inputModeSelect.value) {
                inputModeSelect.value = activeMode;
                console.log(
                  `[NetplayMenu] Updated dropdown to show active mode: ${activeMode}`,
                );
              }
            }, 1500); // Allow time for mode switch to complete
          });
        }
      },
    );

    // P2P Connectivity Test button - more compact for two-column layout
    const testButton = this.createElement("button");
    testButton.innerText = "Test P2P";
    testButton.className = "ejs_button";
    testButton.style.padding = "4px 8px";
    testButton.style.fontSize = "0.85em";
    testButton.style.width = "100%";
    testButton.style.maxWidth = "100%";
    testButton.onclick = () => {
      if (this.engine?.testP2PConnectivity) {
        console.log("[NetplayMenu] 🔬 Starting P2P connectivity test...");
        this.engine.testP2PConnectivity().catch((err) => {
          console.error("[NetplayMenu] P2P connectivity test failed:", err);
        });
      } else {
        console.warn(
          "[NetplayMenu] P2P connectivity test not available - engine not ready",
        );
      }
    };

    // ICE Server Configuration Test button - more compact for two-column layout
    const iceTestButton = this.createElement("button");
    iceTestButton.innerText = "Test ICE";
    iceTestButton.className = "ejs_button";
    iceTestButton.style.padding = "4px 8px";
    iceTestButton.style.fontSize = "0.85em";
    iceTestButton.style.width = "100%";
    iceTestButton.style.maxWidth = "100%";
    iceTestButton.onclick = () => {
      if (this.engine?.testIceServerConfiguration) {
        console.log(
          "[NetplayMenu] 🧊 Starting ICE server configuration test...",
        );
        this.engine
          .testIceServerConfiguration()
          .then((result) => {
            if (result) {
              console.log(
                "[NetplayMenu] ICE server test completed successfully:",
                result,
              );
            } else {
              console.warn(
                "[NetplayMenu] ICE server test failed or returned no results",
              );
            }
          })
          .catch((err) => {
            console.error(
              "[NetplayMenu] ICE server configuration test failed:",
              err,
            );
          });
      } else {
        console.warn(
          "[NetplayMenu] ICE server test not available - engine not ready",
        );
      }
    };

    // Add settings in two-column layout
    settingsTable.appendChild(
      createTwoColumnRow(
        "SVC with VP9",
        vp9SvcSelect,
        "Legacy Simulcast",
        simulcastSelect,
      ),
    );
    settingsTable.appendChild(
      createTwoColumnRow(
        "Host Codec",
        hostCodecSelect,
        "Client Simulcast Quality",
        clientQualitySelect,
      ),
    );
    settingsTable.appendChild(
      createTwoColumnRow(
        "Retry Connection Timer",
        retryTimerSelect,
        "Unordered Retries",
        unorderedRetriesSelect,
      ),
    );
    settingsTable.appendChild(
      createTwoColumnRow("Input Mode", inputModeSelect, null, null),
    );
    settingsTable.appendChild(
      createTwoColumnRow(
        "P2P Test",
        testButton,
        "ICE Config Test",
        iceTestButton,
      ),
    );

    settingsContainer.appendChild(settingsTable);
    content.appendChild(settingsContainer);

    // Close button - mobile optimized
    const closeBtn = this.createElement("button");
    closeBtn.classList.add("ejs_button_button");
    closeBtn.classList.add("ejs_popup_submit");
    closeBtn.style["background-color"] = "rgba(var(--ejs-primary-color),1)";
    closeBtn.style.marginTop = isMobile ? "6px" : "8px";
    closeBtn.style.padding = isMobile ? "5px 12px" : "6px 16px";
    closeBtn.style.fontSize = isMobile ? "0.85em" : "0.9em";
    closeBtn.style.width = isMobile ? "100%" : "auto";
    closeBtn.innerText = "Close";
    closeBtn.onclick = () => container.remove();

    content.appendChild(closeBtn);

    // Add to netplay menu
    if (this.netplayMenu) {
      this.netplayMenu.appendChild(container);
    }
  }

  // Initialize delay sync player table
  netplayInitializeDelaySyncPlayers(maxPlayers) {
    // Initialize ready states array for maxPlayers
    this.netplay.playerReadyStates = new Array(maxPlayers).fill(false);
    this.netplay.playerReadyStates[0] = true; // Host starts ready

    // Create fallback player data for host (will be replaced when server data arrives)
    const fallbackPlayers = [
      {
        id: this.getMyPlayerId() || "host",
        slot: 0,
        name: this.netplay.name || "Host",
        ready: true,
        role: "player",
      },
    ];

    // Use centralized table update mechanics
    this.netplayUpdatePlayerTable(fallbackPlayers);

    // If we have full player data (from netplayUpdatePlayerList), update the table with it
    // Otherwise, keep the fallback host-only display
    if (this.netplay.joinedPlayers && this.netplay.joinedPlayers.length > 0) {
      console.log(
        "[NetplayMenu] Updating delay sync table with full player data",
      );
      this.netplayUpdatePlayerTable(this.netplay.joinedPlayers);
    }
  }

  // Update player table - handles both individual players and bulk updates
  // Update player table - handles both individual players and bulk updates
  netplayUpdatePlayerTable(playersOrSlot) {
    // CRITICAL: Don't update player tables when showing listings (not in a room)
    const currentRoomTypeCheck = this.currentRoomType;
    if (currentRoomTypeCheck === "listings" || !currentRoomTypeCheck) {
      console.log(
        "[NetplayMenu] netplayUpdatePlayerTable skipped - not in a room (currentRoomType:",
        currentRoomTypeCheck,
        ")",
      );
      return;
    }

    // Determine which table type we're using based on current room type
    let tbody;
    let isDelaySync = false;

    // Use currentRoomType to determine which table to use (prevents using wrong table)
    const currentRoomType = this.currentRoomType;
    if (currentRoomType === "delaysync" && this.netplay.delaySyncPlayerTable) {
      tbody = this.netplay.delaySyncPlayerTable;
      isDelaySync = true;
    } else if (
      currentRoomType === "livestream" &&
      this.netplay.liveStreamPlayerTable
    ) {
      tbody = this.netplay.liveStreamPlayerTable;
      isDelaySync = false;
    } else if (this.netplay.delaySyncPlayerTable) {
      // Fallback: use delay sync table if it exists (but only if we're actually in a room)
      const engine = this.emulator.netplay?.engine;
      const isInRoom =
        engine?.sessionState?.roomName != null &&
        this.emulator.netplay?.currentRoom != null;
      if (isInRoom) {
        tbody = this.netplay.delaySyncPlayerTable;
        isDelaySync = true;
      } else {
        console.log(
          "[NetplayMenu] netplayUpdatePlayerTable skipped - fallback prevented (not in room)",
        );
        return;
      }
    } else if (this.netplay.liveStreamPlayerTable) {
      // Fallback: use live stream table if it exists (but only if we're actually in a room)
      const engine = this.emulator.netplay?.engine;
      const isInRoom =
        engine?.sessionState?.roomName != null &&
        this.emulator.netplay?.currentRoom != null;
      if (isInRoom) {
        tbody = this.netplay.liveStreamPlayerTable;
        isDelaySync = false;
      } else {
        console.log(
          "[NetplayMenu] netplayUpdatePlayerTable skipped - fallback prevented (not in room)",
        );
        return;
      }
    } else {
      return; // No table to update
    }

    // If no argument provided, use joinedPlayers array
    if (playersOrSlot === undefined || playersOrSlot === null) {
      if (
        this.netplay?.joinedPlayers &&
        Array.isArray(this.netplay.joinedPlayers)
      ) {
        playersOrSlot = this.netplay.joinedPlayers;
      } else {
        console.warn(
          "[NetplayMenu] netplayUpdatePlayerTable called without arguments and no joinedPlayers available",
        );
        return;
      }
    }

    // Handle array of players (bulk update)
    if (Array.isArray(playersOrSlot)) {
      const playersArray = playersOrSlot;
      console.log(
        `[NetplayMenu] Rebuilding ${isDelaySync ? "delay sync" : "live stream"} player table with`,
        playersArray.length,
        "players",
      );

      // Clear existing table
      console.log(
        "[NetplayMenu] Clearing existing table, had",
        tbody.children.length,
        "rows",
      );
      tbody.innerHTML = "";

      // Rebuild table with current players
      playersArray.forEach((player, index) => {
        // Skip invalid players
        if (!player || !player.id) {
          console.warn(
            `[NetplayMenu] Skipping invalid player at index ${index}:`,
            player,
          );
          return;
        }

        console.log(`[NetplayMenu] Adding player ${index}:`, player);

        const row = this.createElement("tr");
        // Add data attribute with player ID for reliable identification
        row.setAttribute("data-player-id", player.id);

        // Player column (use actual player slot, not array index)
        const playerCell = this.createElement("td");
        playerCell.innerText = this.getSlotDisplayText(player.slot);
        playerCell.style.textAlign = "center";
        row.appendChild(playerCell);

        // Name column
        const nameCell = this.createElement("td");
        nameCell.innerText = player.name;
        nameCell.style.textAlign = "center";
        row.appendChild(nameCell);

        // Third column - Status (validation + ready for delay sync, host status for live stream)
        const thirdCell = this.createElement("td");

        if (isDelaySync) {
          // Delay sync: Show validation status and ready status
          let statusText = "";
          let statusColor = "";

          if (
            player.validationStatus === "ok" ||
            player.validationStatus === undefined
          ) {
            // Validation passed or not yet validated (treat as valid)
            statusText = player.ready ? "✅" : "⏳";
            statusColor = player.ready ? "green" : "orange";
          } else if (player.validationStatus) {
            statusText = "❌";
            statusColor = "red";
            thirdCell.title = player.validationReason || "Validation failed";
          } else {
            statusText = "⏳";
            statusColor = "gray";
          }

          thirdCell.innerText = statusText;
          thirdCell.style.color = statusColor;
          thirdCell.style.textAlign = "center";
          thirdCell.classList.add("validation-status");
        } else {
          // Live stream: Status emoji
          thirdCell.innerText = this.getPlayerStatusEmoji(player);
          thirdCell.style.textAlign = "center";
        }

        row.appendChild(thirdCell);
        tbody.appendChild(row);
      });

      console.log(
        "[NetplayMenu] Table rebuild complete, now has",
        tbody.children.length,
        "rows",
      );

      // Log the content of each row for debugging
      for (let i = 0; i < tbody.children.length; i++) {
        const row = tbody.children[i];
        const cells = row.querySelectorAll("td");
        const cellTexts = Array.from(cells).map((cell) => cell.textContent);
        console.log(`[NetplayMenu] Row ${i} content:`, cellTexts);
      }

      // Also log the entire table HTML for debugging
      console.log("[NetplayMenu] Table HTML:", tbody.innerHTML);

      return;
    }

    // Handle individual slot (legacy behavior)
    const slot = playersOrSlot;
    if (!this.netplay?.joinedPlayers) return; // joinedPlayers not initialized yet
    const player = this.netplay.joinedPlayers.find((p) => p.slot === slot);

    // Guard: ensure player exists before accessing properties
    if (!player || !player.id) {
      console.warn(
        `[NetplayMenu] Player not found for slot ${slot} or player missing id`,
      );
      return;
    }

    // Check if a row for this player already exists
    const existingRow = tbody.querySelector(
      `tr[data-player-id="${player.id}"]`,
    );

    let row;
    if (existingRow) {
      // Update existing row instead of creating duplicate
      console.log(
        `[NetplayMenu] Updating existing row for player ${player.id} in slot ${slot}`,
      );
      row = existingRow;
      // Clear existing cells to rebuild them
      row.innerHTML = "";
    } else {
      // Create new row only if none exists
      console.log(
        `[NetplayMenu] Creating new row for player ${player.id} in slot ${slot}`,
      );
      row = this.createElement("tr");
    }

    // Add data attribute with player ID for reliable identification
    row.setAttribute("data-player-id", player.id);

    // Player column (same for both table types)
    const playerCell = this.createElement("td");
    playerCell.innerText = this.getSlotDisplayText(slot);
    playerCell.style.textAlign = "center";
    row.appendChild(playerCell);

    // Name column (same for both table types)
    const nameCell = this.createElement("td");
    nameCell.innerText = player.name;
    nameCell.style.textAlign = "center";
    row.appendChild(nameCell);

    // Third column - Ready for delay sync, Status for live stream
    const thirdCell = this.createElement("td");

    if (isDelaySync) {
      // Delay sync: Ready status with checkmarks
      thirdCell.innerText = player.ready ? "✅" : "⛔";
      thirdCell.style.textAlign = "right";
      thirdCell.classList.add("ready-status");
    } else {
      // Live stream: Status emoji
      thirdCell.innerText = this.getPlayerStatusEmoji(player);
      thirdCell.style.textAlign = "center";
    }

    row.appendChild(thirdCell);

    // Only append if this is a new row (not updating existing)
    if (!existingRow) {
      tbody.appendChild(row);
    }
  }

  netplaySetupSlotSelector() {
    // Remove existing slot selector if it exists
    if (this.netplay.slotSelect && this.netplay.slotSelect.parentElement) {
      const slotContainer = this.netplay.slotSelect.parentElement;
      if (slotContainer.parentElement) {
        slotContainer.parentElement.removeChild(slotContainer);
      }
    }

    // BEFORE creating the slot selector, ensure we have current player data
    // Get current players from the engine to know which slots are taken
    let currentPlayers = {};
    let hasPlayerData = false;

    if (this.netplay.engine?.playerManager) {
      try {
        currentPlayers =
          this.netplay.engine.playerManager.getPlayersObject() || {};
        hasPlayerData = Object.keys(currentPlayers).length > 0;
        console.log(
          "[NetplayMenu] Got current players for slot selector:",
          currentPlayers,
        );
      } catch (error) {
        console.warn("[NetplayMenu] Could not get current players:", error);
      }
    }

    // If we have player data, update takenSlots before creating selector
    if (hasPlayerData) {
      if (!this.netplay.takenSlots) {
        this.netplay.takenSlots = new Set();
      }
      this.netplay.takenSlots.clear();

      // Convert players object to array and track taken slots
      Object.entries(currentPlayers).forEach(([playerId, playerData]) => {
        const slot = playerData.slot || playerData.player_slot || 0;
        if (slot !== undefined && slot !== null && slot < 4) {
          this.netplay.takenSlots.add(slot);
        }
      });

      console.log(
        "[NetplayMenu] Updated taken slots from player data:",
        Array.from(this.netplay.takenSlots),
      );
    }

    // Create new slot selector with consistent styling
    const slotLabel = this.createElement("strong");
    slotLabel.innerText = "Player Select: ";

    const slotSelect = this.createElement("select");
    // Add basic styling to make it look like a proper dropdown
    slotSelect.style.backgroundColor = "#333";
    slotSelect.style.border = "1px solid #555";
    slotSelect.style.borderRadius = "4px";
    slotSelect.style.padding = "4px 8px";
    slotSelect.style.minWidth = "80px";
    slotSelect.style.cursor = "pointer";
    slotSelect.style.color = "#fff";

    // Use centralized slot selector options
    const myPlayerId = this.getMyPlayerId();
    const options = this.getSlotSelectorOptions(myPlayerId);

    // Add options to select element
    for (const option of options) {
      const opt = this.createElement("option");
      opt.value = String(option.value);
      opt.innerText = option.text;
      if (option.disabled) opt.disabled = true;
      if (option.selected) opt.selected = true;
      slotSelect.appendChild(opt);
    }

    // Store reference
    this.netplay.slotSelect = slotSelect;

    // Set up event listener (only if not already wired)
    if (!this.netplay._slotSelectWired) {
      this.netplay._slotSelectWired = true;
      this.addEventListener(slotSelect, "change", () => {
        const raw = parseInt(slotSelect.value, 10);
        const slot = isNaN(raw) ? 0 : Math.max(0, Math.min(8, raw)); // Allow 0-8 (Spectator)

        // Use centralized slot change system
        this.requestSlotChange(slot);

        // Update the slot selector UI after slot change
        this.netplayUpdateSlotSelector();

        // Reapply styling after update (since it clears innerHTML)
        const updatedSelect = this.netplay.slotSelect;
        if (updatedSelect) {
          updatedSelect.setAttribute(
            "style",
            "background-color: #333 !important; " +
              "border: 1px solid #555 !important; " +
              "border-radius: 4px !important; " +
              "padding: 4px 8px !important; " +
              "min-width: 80px !important; " +
              "cursor: pointer !important; " +
              "color: #fff !important;",
          );
        }

        // Save settings
        if (this.settings) {
          this.settings.netplayPreferredSlot = String(slot);
        }
        this.saveSettings();
      });
    }

    // Create container
    const slotContainer = this.createElement("div");
    slotContainer.style.display = "flex";
    slotContainer.style.justifyContent = "center";
    slotContainer.style.alignItems = "center";
    slotContainer.style.gap = "8px";
    slotContainer.style.marginTop = "10px";
    slotContainer.style.marginBottom = "10px";

    slotContainer.appendChild(slotLabel);
    slotContainer.appendChild(slotSelect);

    // Insert into the joined tab after the password element
    if (this.netplay.tabs && this.netplay.tabs[1]) {
      // Find the password element to insert after
      const passwordElement = this.netplay.tabs[1].querySelector(
        'input[type="password"], .ejs_netplay_password',
      );
      if (passwordElement && passwordElement.parentElement) {
        passwordElement.parentElement.parentElement.insertBefore(
          slotContainer,
          passwordElement.parentElement.nextSibling,
        );
      } else {
        // Fallback: insert at the beginning of the tab
        this.netplay.tabs[1].insertBefore(
          slotContainer,
          this.netplay.tabs[1].firstChild,
        );
      }
    }
  }

  netplayUpdateSlotSelector() {
    if (
      !this.netplay?.slotSelect ||
      !(this.netplay.slotSelect instanceof Element)
    ) {
      console.warn("[NetplayMenu] Slot selector not available for update");
      return;
    }

    const slotSelect = this.netplay.slotSelect;
    // Clear all options except Spectator
    const spectatorOption = slotSelect.querySelector('option[value="8"]');
    slotSelect.innerHTML = "";

    // Use centralized slot selector options logic
    const myPlayerId = this.getMyPlayerId();

    if (myPlayerId) {
      const options = this.getSlotSelectorOptions(myPlayerId);

      // Apply options to the select element
      for (const option of options) {
        const opt = this.createElement("option");
        opt.value = String(option.value);
        opt.innerText = option.text;
        if (option.disabled) {
          opt.disabled = true;
        }
        if (option.selected) {
          opt.selected = true;
        }
        slotSelect.appendChild(opt);
      }
    } else {
      console.warn("[NetplayMenu] Cannot update slot selector: no player ID");
    }

    // The slot selector options are already configured with the correct selected option
    // by getSlotSelectorOptions. No need to manually set the value here.
  }

  // Get the lowest available player slot
  netplayGetLowestAvailableSlot() {
    if (!this.netplay.takenSlots) {
      this.netplay.takenSlots = new Set();
    }
    for (let i = 0; i < 4; i++) {
      if (!this.netplay.takenSlots.has(i)) {
        return i;
      }
    }
    return -1; // No slots available
  }

  // Add a joining player with auto-assigned slot
  netplayAddJoiningPlayer(name) {
    const availableSlot = this.netplayGetLowestAvailableSlot();
    if (availableSlot === -1) return null; // No slots available

    const newPlayer = {
      slot: availableSlot,
      name: name,
      ready: false,
    };

    if (!this.netplay.joinedPlayers) {
      this.netplay.joinedPlayers = [];
    }
    this.netplay.joinedPlayers.push(newPlayer);
    this.netplay.takenSlots.add(availableSlot);

    // Add to Delay Sync table if it exists
    if (this.netplay.delaySyncPlayerTable) {
      this.netplayUpdatePlayerTable(availableSlot);
      // Update ready states array
      if (
        this.netplay.playerReadyStates &&
        availableSlot < this.netplay.playerReadyStates.length
      ) {
        this.netplay.playerReadyStates[availableSlot] = false;
      }
    }

    // Update slot selector to remove the taken slot
    this.netplayUpdateSlotSelector();

    return newPlayer;
  }

  // Remove a player (when they leave)
  netplayRemovePlayer(slot) {
    if (!this.netplay.joinedPlayers) return;

    // Remove from joined players
    this.netplay.joinedPlayers = this.netplay.joinedPlayers.filter(
      (p) => p.slot !== slot,
    );

    // Free up the slot
    if (this.netplay.takenSlots) {
      this.netplay.takenSlots.delete(slot);
    }

    // Remove from Delay Sync table
    if (this.netplay.delaySyncPlayerTable) {
      // Re-render the entire table
      this.netplayUpdatePlayerTable(this.netplay.joinedPlayers); // Uses real data
    }

    // Update slot selector to remove the taken slot
    this.netplayUpdateSlotSelector();
  }

  // Toggle ready status
  async netplayToggleReady() {
    console.log("[NetplayMenu] netplayToggleReady called");

    if (!this.netplay.readyButton) {
      console.log("[NetplayMenu] Ready button not found, returning");
      return;
    }

    // Get room name from currentRoomId or currentRoom properties
    const roomName =
      this.emulator.netplay.currentRoomId ||
      this.emulator.netplay.currentRoom?.room_name ||
      this.emulator.netplay.currentRoom?.name;
    if (!roomName) {
      console.log("[NetplayMenu] No room name found, returning");
      console.log(
        "[NetplayMenu] currentRoomId:",
        this.emulator.netplay.currentRoomId,
      );
      console.log(
        "[NetplayMenu] currentRoom:",
        this.emulator.netplay.currentRoom,
      );
      return;
    }

    // Use this.engine (NetplayMenu's persistent reference) which persists even after cleanup
    // this.emulator.netplay.engine gets cleared during cleanup, but this.engine doesn't
    const engine = this.engine || this.emulator.netplay?.engine;
    if (!engine || !engine.sessionState) {
      console.error(
        "[NetplayMenu] Cannot toggle ready - engine or sessionState not available",
      );
      alert("Cannot toggle ready - engine not available. Please try again.");
      return;
    }

    if (!engine.roomManager) {
      console.error(
        "[NetplayMenu] Cannot toggle ready - roomManager not available",
      );
      alert(
        "Cannot toggle ready - room manager not available. Please try again.",
      );
      return;
    }

    // Find local player
    const localPlayerId = engine.sessionState?.localPlayerId;
    const localPlayer = this.netplay.joinedPlayers?.find(
      (p) => p.id === localPlayerId,
    );

    console.log("[NetplayMenu] Toggle ready check:", {
      roomName,
      localPlayerId,
      localPlayerFound: !!localPlayer,
      playerSlot: localPlayer?.slot,
      playerRole: localPlayer?.role,
      buttonDisabled: this.netplay.readyButton.disabled,
    });

    // Block spectators from using ready button
    if (
      localPlayer &&
      (localPlayer.slot === 8 || localPlayer.role === "spectator")
    ) {
      console.log("[NetplayMenu] Spectators cannot toggle ready status");
      return;
    }

    // Block if button is disabled (e.g., validation failed)
    if (this.netplay.readyButton.disabled) {
      console.log("[NetplayMenu] Ready button is disabled, returning");
      return;
    }

    console.log("[NetplayMenu] Calling roomManager.toggleReady");
    try {
      await engine.roomManager.toggleReady(roomName);
      console.log("[NetplayMenu] Ready state toggled successfully");
      // Don't update button here - wait for player-ready-updated event
      // The event handler (netplayUpdatePlayerReady) will update the button
    } catch (error) {
      console.error("[NetplayMenu] Failed to toggle ready state:", error);
      alert(`Failed to toggle ready: ${error.message}`);
    }
  }

  // DELAY_SYNC: Update player validation status
  netplayUpdatePlayerValidation(playerId, validationStatus, validationReason) {
    console.log(
      `[NetplayMenu] Updating validation for player ${playerId}: ${validationStatus}`,
    );

    // Update the player in joinedPlayers
    if (this.netplay.joinedPlayers) {
      const player = this.netplay.joinedPlayers.find((p) => p.id === playerId);
      if (player) {
        player.validationStatus = validationStatus;
        player.validationReason = validationReason;
      }
    }

    // Update UI
    this.netplayUpdatePlayerTable();

    // Update ready button state (may be disabled due to validation)
    this.netplayUpdateReadyButton();
  }

  // DELAY_SYNC: Update player ready state
  netplayUpdatePlayerReady(playerId, ready) {
    console.log(
      `[NetplayMenu] Updating ready state for player ${playerId}: ${ready}`,
    );

    // Update the player in joinedPlayers
    if (this.netplay.joinedPlayers) {
      const player = this.netplay.joinedPlayers.find((p) => p.id === playerId);
      if (player) {
        player.ready = ready;
      }
    }

    // Update UI
    this.netplayUpdatePlayerTable();

    // Update ready and launch button states
    this.netplayUpdateReadyButton();
    this.netplayUpdateLaunchButton();
  }

  // DELAY_SYNC: Handle prepare start
  async netplayHandlePrepareStart(data) {
    console.log("[NetplayMenu] Handling prepare start:", data);

    // Update room phase
    if (this.emulator.netplay.currentRoom) {
      this.emulator.netplay.currentRoom.room_phase = "prepare";
    }

    // Prepare phase: Reset emulator, load ROM, run to frame 1, then pause
    try {
      console.log("[NetplayMenu] Starting prepare phase...");

      // Reset emulator if possible
      if (this.emulator.reset) {
        this.emulator.reset();
        console.log("[NetplayMenu] Emulator reset");
      }

      // Wait a bit for reset to complete
      await new Promise((resolve) => setTimeout(resolve, 100));

      // Start emulator (it should load the ROM automatically)
      if (this.emulator.start) {
        this.emulator.start();
        console.log("[NetplayMenu] Emulator started for prepare phase");
      }

      // Wait for emulator to be ready and reach frame 1
      // This is a simplified implementation - in a real system you'd need
      // to wait for the emulator to actually reach frame 1
      await new Promise((resolve) => setTimeout(resolve, 500));

      // Pause emulator at frame 1
      if (this.emulator.pause) {
        this.emulator.pause();
        console.log("[NetplayMenu] Emulator paused at frame 1");
      }

      // Send ready-at-frame-1 to server
      const roomName = this.emulator.netplay.currentRoom?.room_name;
      if (roomName) {
        await this.emulator.netplay.engine.roomManager.sendReadyAtFrame1(
          roomName,
          1,
        );
        console.log("[NetplayMenu] Sent ready-at-frame-1 to server");
      }
    } catch (error) {
      console.error("[NetplayMenu] Error in prepare phase:", error);
    }
  }

  // DELAY_SYNC: Handle synchronized game start
  netplayHandleGameStart(data) {
    console.log("[NetplayMenu] Handling synchronized game start:", data);

    // Update room phase
    if (this.emulator.netplay.currentRoom) {
      this.emulator.netplay.currentRoom.room_phase = "running";
    }

    const { start_time, frame } = data;
    const now = Date.now();
    const delay = start_time - now;

    if (delay > 0) {
      console.log(`[NetplayMenu] Waiting ${delay}ms until start time`);
      setTimeout(() => {
        this.startSynchronizedGame(frame);
      }, delay);
    } else {
      console.log(
        "[NetplayMenu] Start time already passed, starting immediately",
      );
      this.startSynchronizedGame(frame);
    }
  }

  // Start the synchronized game
  startSynchronizedGame(frame) {
    console.log(`[NetplayMenu] Starting synchronized game at frame ${frame}`);

    // Unpause emulator
    if (this.emulator.unpause || this.emulator.resume) {
      const unpauseMethod = this.emulator.unpause || this.emulator.resume;
      unpauseMethod.call(this.emulator);
      console.log("[NetplayMenu] Emulator unpaused");
    }

    // Set up input buffering for frame + delay
    // This would need to be implemented in the InputSync system
    console.log("[NetplayMenu] Input buffering setup would go here");

    // Hide the menu
    this.hide();
  }

  // Update ready button state
  netplayUpdateReadyButton() {
    if (!this.netplay.readyButton) {
      console.log("[NetplayMenu] Ready button not found");
      return;
    }

    const room = this.emulator.netplay.currentRoom;
    if (!room || room.netplay_mode !== "delay_sync") {
      console.log(
        "[NetplayMenu] Not in delay_sync room, skipping ready button update",
      );
      return;
    }

    // Find local player
    const localPlayerId =
      this.emulator.netplay.engine.sessionState?.localPlayerId;
    const localPlayer = this.netplay.joinedPlayers?.find(
      (p) => p.id === localPlayerId,
    );

    console.log("[NetplayMenu] Updating ready button:", {
      localPlayerId,
      localPlayerFound: !!localPlayer,
      joinedPlayersCount: this.netplay.joinedPlayers?.length || 0,
      playerReady: localPlayer?.ready,
      playerSlot: localPlayer?.slot,
    });

    if (!localPlayer) {
      console.warn(
        "[NetplayMenu] Local player not found in joinedPlayers, enabling button anyway",
      );
      // Enable button and set action even if player not found yet
      // (player might be added to joinedPlayers after button is created)
      this.netplay.readyButton.disabled = false;
      this.netplay.readyButton.style.cursor = "pointer";
      this.netplay.readyButton.title = "";
      this.netplay.readyButton.onclick = () => {
        this.netplayToggleReady();
      };
      this.netplay.readyButton.innerText = "Ready";
      this.netplay.readyButton.style.backgroundColor = "#4caf50"; // Green
      this.netplay.readyButton.style.opacity = "1";
      return;
    }

    // Check if spectator (slot 8)
    const isSpectator =
      localPlayer.slot === 8 || localPlayer.role === "spectator";

    if (isSpectator) {
      // Spectator: disabled, transparent, always shows "Ready"
      console.log("[NetplayMenu] Player is spectator, disabling ready button");
      this.netplay.readyButton.disabled = true;
      this.netplay.readyButton.innerText = "Ready";
      this.netplay.readyButton.style.backgroundColor = "#4caf50"; // Green
      this.netplay.readyButton.style.opacity = "0.3";
      this.netplay.readyButton.style.cursor = "not-allowed";
      this.netplay.readyButton.title = "Spectators cannot toggle ready status";
      this.netplay.readyButton.onclick = null; // Remove action for spectators
      return;
    }
    // Regular players: button state based on ready status
    console.log(
      "[NetplayMenu] Updating ready button for regular player, ready:",
      localPlayer.ready,
    );
    this.netplay.readyButton.disabled = false;
    this.netplay.readyButton.style.cursor = "pointer";
    this.netplay.readyButton.title = "";
    // Ensure button is visible (not hidden)
    this.netplay.readyButton.style.display = "";
    // Set action to toggle ready status
    this.netplay.readyButton.onclick = () => {
      console.log("[NetplayMenu] Ready button clicked");
      this.netplayToggleReady();
    };

    // Update button text and color based on ready state
    if (localPlayer.ready) {
      // Ready = true: shows "Not Ready", grey (clicking will set ready to false)
      this.netplay.readyButton.innerText = "Not Ready";
      this.netplay.readyButton.style.backgroundColor = "#666"; // Grey
      this.netplay.readyButton.style.opacity = "1";
      console.log("[NetplayMenu] Button set to 'Not Ready' (grey)");
    } else {
      // Ready = false: shows "Ready", green (clicking will set ready to true)
      this.netplay.readyButton.innerText = "Ready";
      this.netplay.readyButton.style.backgroundColor = "#4caf50"; // Green
      this.netplay.readyButton.style.opacity = "1";
      console.log("[NetplayMenu] Button set to 'Ready' (green)");
    }
  }

  // Update launch game button state
  netplayUpdateLaunchButton() {
    if (!this.netplay.launchButton || !this.netplay.joinedPlayers) return;

    // Check if we're in a delay_sync room
    const room = this.emulator.netplay?.currentRoom;
    if (!room || room.netplay_mode !== "delay_sync") {
      console.log(
        "[NetplayMenu] Not in delay_sync room, skipping launch button update",
      );
      return;
    }

    // Check if engine exists (it might be null after leaving a room)
    const engine = this.netplay?.engine || this.emulator.netplay?.engine;
    if (!engine || !engine.sessionState) {
      console.log(
        "[NetplayMenu] Engine or sessionState not available, skipping launch button update",
      );
      return;
    }

    // Check if local player is host (check multiple sources)
    const isHostFromSessionState = engine.sessionState?.isHostRole() || false;
    const localPlayerId = engine.sessionState?.localPlayerId;
    const localPlayer = this.netplay.joinedPlayers?.find(
      (p) => p.id === localPlayerId,
    );
    const isHostFromPlayer = localPlayer?.is_host || false;
    const isHost = isHostFromSessionState || isHostFromPlayer;

    console.log("[NetplayMenu] Updating launch button:", {
      localPlayerId,
      localPlayerFound: !!localPlayer,
      isHostFromSessionState,
      isHostFromPlayer,
      isHost,
      playerIsHost: localPlayer?.is_host,
    });

    // Check if player is spectator (slot 8)
    const isSpectator =
      localPlayer &&
      (localPlayer.slot === 8 || localPlayer.role === "spectator");

    // Launch button is only for hosts (not guests/spectators)
    if (!isHost) {
      // Guests/spectators: green but transparent and disabled
      console.log("[NetplayMenu] Launch button: Not host, making transparent");
      this.netplay.launchButton.disabled = true;
      this.netplay.launchButton.style.backgroundColor = "#4caf50"; // Green
      this.netplay.launchButton.style.opacity = "0.3";
      this.netplay.launchButton.style.cursor = "not-allowed";
      // Ensure button is visible (not hidden)
      this.netplay.launchButton.style.display = "";
    } else {
      // Host: check if all players are ready
      console.log("[NetplayMenu] Launch button: Host, checking ready status");
      const allReady = this.netplay.joinedPlayers.every(
        (player) => player.ready,
      );
      this.netplay.launchButton.disabled = !allReady;
      this.netplay.launchButton.style.backgroundColor = "#4caf50"; // Green
      this.netplay.launchButton.style.opacity = allReady ? "1" : "0.6";
      this.netplay.launchButton.style.cursor = allReady
        ? "pointer"
        : "not-allowed";
      // Ensure button is visible
      this.netplay.launchButton.style.display = "";
      console.log("[NetplayMenu] Launch button: Host, allReady:", allReady);
    }
  }

  // Launch game (host only)
  async netplayLaunchGame() {
    const roomName = this.emulator.netplay?.currentRoom?.room_name;
    if (!roomName) {
      console.warn("[NetplayMenu] Cannot launch game - no room name");
      return;
    }

    // Use this.engine (NetplayMenu's persistent reference) which persists even after cleanup
    // this.emulator.netplay.engine gets cleared during cleanup, but this.engine doesn't
    const engine = this.engine || this.emulator.netplay?.engine;
    if (!engine) {
      console.error("[NetplayMenu] Cannot launch game - engine not available");
      alert("Cannot launch game - engine not available. Please try again.");
      return;
    }

    if (!engine.roomManager) {
      console.error(
        "[NetplayMenu] Cannot launch game - roomManager not available",
      );
      alert(
        "Cannot launch game - room manager not available. Please try again.",
      );
      return;
    }

    try {
      await engine.roomManager.startGame(roomName);
      console.log("[NetplayMenu] Game start initiated successfully");
    } catch (error) {
      console.error("[NetplayMenu] Failed to start game:", error);
      alert(`Failed to start game: ${error.message}`);
    }
  }

  // Helper method to update the room table UI
  netplayUpdateRoomTable(rooms) {
    if (!this.netplay || !this.netplay.table) return;

    // Debug: log received room data with source indicator
    const source = new Error().stack?.includes("Socket.IO")
      ? "Socket.IO"
      : "HTTP";
    console.log(
      `[NetplayMenu] 📊 Updating room table (source: ${source}) with`,
      rooms.length,
      "rooms",
    );
    if (rooms.length > 0) {
      console.log(`[NetplayMenu] 📊 First room data (source: ${source}):`, {
        id: rooms[0].id,
        name: rooms[0].name,
        netplay_mode: rooms[0].netplay_mode,
        typeof_netplay_mode: typeof rooms[0].netplay_mode,
        rom_name: rooms[0].rom_name,
        rom_hash: rooms[0].rom_hash,
        core_type: rooms[0].core_type,
        coreId: rooms[0].coreId,
        allKeys: Object.keys(rooms[0]),
        fullObject: rooms[0], // Include full object for inspection
      });
    }

    const tbody = this.netplay.table;
    tbody.innerHTML = ""; // Clear existing rows

    // Filter out empty rooms (client-side backup - server should already filter, but this ensures clean UI)
    const filteredRooms = rooms.filter((room) => {
      // Keep rooms with at least 1 player
      const currentPlayers = room.current || 0;
      if (currentPlayers > 0) {
        return true;
      }
      // Log filtered empty rooms for debugging
      console.log(
        `[NetplayMenu] Filtering out empty room: ${room.name || room.id} (${currentPlayers} players)`,
      );
      return false;
    });

    if (filteredRooms.length === 0) {
      const row = this.createElement("tr");
      const cell = this.createElement("td");
      cell.colSpan = 4;
      cell.style.textAlign = "center";
      cell.style.padding = "20px";
      cell.innerText = "No rooms available";
      row.appendChild(cell);
      tbody.appendChild(row);
      return;
    }

    filteredRooms.forEach((room) => {
      // Normalize netplay_mode (handle both string and numeric formats)
      const netplayMode =
        room.netplay_mode === "delay_sync" || room.netplay_mode === 1
          ? "delay_sync"
          : "live_stream";

      // Main row
      const row = this.createElement("tr");
      row.style.cursor = "pointer";
      row.classList.add("ejs_netplay_room_row");

      // Room type cell
      const typeCell = this.createElement("td");
      typeCell.innerText =
        netplayMode === "delay_sync" ? "Delay Sync" : "Live Stream";
      typeCell.style.textAlign = "center";
      typeCell.style.fontSize = "12px";
      typeCell.style.fontWeight = "bold";
      row.appendChild(typeCell);

      // Room name cell
      const nameCell = this.createElement("td");
      nameCell.innerText = room.name + (room.hasPassword ? " 🔐" : "");
      nameCell.style.textAlign = "center";
      row.appendChild(nameCell);

      // Players cell
      const playersCell = this.createElement("td");
      playersCell.innerText = `${room.current}/${room.max}`;
      playersCell.style.textAlign = "center";
      row.appendChild(playersCell);

      // Join button cell
      const joinCell = this.createElement("td");
      joinCell.style.textAlign = "center";

      const joinBtn = this.createElement("button");
      joinBtn.classList.add("ejs_button_button");
      joinBtn.innerText = room.hasPassword ? "Join (PW)" : "Join";
      joinBtn.onclick = async (e) => {
        e.stopPropagation(); // Don't trigger row expansion

        try {
          await this.engine.netplayJoinRoom(
            room.id,
            room.hasPassword,
            room.netplay_mode,
          );
        } catch (error) {
          console.error("[NetplayMenu] Failed to join room:", error);

          // Handle all compatibility errors (delay sync and general ROM/core mismatches)
          if (
            (error.details &&
              (error.details.error === "delay_sync_incompatible" ||
                error.details.error === "delay_sync_requirements_not_met" ||
                error.details.error === "incompatible_game")) ||
            error.message.includes("delay_sync_incompatible") ||
            error.message.includes("delay_sync_requirements_not_met") ||
            error.message.includes("incompatible_game") ||
            error.message.includes("ROM or emulator core doesn't match")
          ) {
            // Format incompatible_game errors for the dialog
            if (error.details && error.details.error === "incompatible_game") {
              // Enhance error details with compatibility issues if not present
              if (!error.details.compatibilityIssues) {
                error.details.compatibilityIssues = [];
                if (error.details.requiredRomHash) {
                  error.details.compatibilityIssues.push(
                    `ROM hash mismatch: room requires '${error.details.requiredRomHash}'`,
                  );
                }
                if (error.details.requiredCoreType) {
                  error.details.compatibilityIssues.push(
                    `Emulator core mismatch: room requires '${error.details.requiredCoreType}'`,
                  );
                }
              }
              if (!error.details.requiredMetadata) {
                error.details.requiredMetadata = {};
                if (error.details.requiredRomHash) {
                  error.details.requiredMetadata.rom_hash =
                    error.details.requiredRomHash;
                }
                if (error.details.requiredCoreType) {
                  error.details.requiredMetadata.core_type =
                    error.details.requiredCoreType;
                }
              }
            }
            const errorDetails = this.parseCompatibilityError(error);
            this.showCompatibilityErrorDialog(errorDetails);
            return;
          }

          // Generic error fallback
          alert(`Failed to join room: ${error.message || "Unknown error"}`);
        }
      };

      joinCell.appendChild(joinBtn);
      row.appendChild(joinCell);

      tbody.appendChild(row);

      // Expandable details row (initially hidden)
      const detailsRow = this.createElement("tr");
      detailsRow.style.display = "none";
      detailsRow.classList.add("ejs_netplay_room_details");

      const detailsCell = this.createElement("td");
      detailsCell.colSpan = 4;
      detailsCell.style.padding = "10px";
      detailsCell.style.backgroundColor = "rgba(0,0,0,0.1)";

      // Split details into two columns
      const detailsContainer = this.createElement("div");
      detailsContainer.style.display = "flex";
      detailsContainer.style.justifyContent = "space-between";

      const leftCol = this.createElement("div");
      leftCol.innerText = `Core: ${room.core_type || room.coreId || "Unknown"}`;
      leftCol.style.fontSize = "14px";

      const rightCol = this.createElement("div");
      rightCol.innerText = `ROM: ${room.rom_name || (room.rom_hash ? room.rom_hash.substring(0, 16) + "..." : "Unknown")}`;
      rightCol.style.fontSize = "14px";
      rightCol.style.textAlign = "right";

      detailsContainer.appendChild(leftCol);
      detailsContainer.appendChild(rightCol);
      detailsCell.appendChild(detailsContainer);
      detailsRow.appendChild(detailsCell);

      tbody.appendChild(detailsRow);

      // Make row clickable to toggle details
      row.addEventListener("click", () => {
        const isExpanded = detailsRow.style.display !== "none";
        detailsRow.style.display = isExpanded ? "none" : "";
      });
    });
  }

  netplayRestoreMenu() {
    this.netplay.isInDelaySyncLobby = false;

    // Remove debug buttons when leaving lobby
    const pingButton = document.getElementById("ejs-netplay-ping-test");
    if (pingButton) {
      pingButton.remove();
      console.log("[NetplayMenu] Removed ping test button");
    }

    const orderedButton = document.getElementById("ejs-netplay-ordered-test");
    if (orderedButton) {
      orderedButton.remove();
      console.log("[NetplayMenu] Removed ordered mode test button");
    }
  }

  defineNetplayFunctions() {
    const EJS_INSTANCE = this;

    // Initialize NetplayEngine if modules are available
    // Note: This will only work after netplay modules are loaded/included
    // Check both global scope and window object for compatibility
    const NetplayEngineClass =
      typeof NetplayEngine !== "undefined"
        ? NetplayEngine
        : typeof window !== "undefined" && window.NetplayEngine
          ? window.NetplayEngine
          : undefined;
    const EmulatorJSAdapterClass =
      typeof EmulatorJSAdapter !== "undefined"
        ? EmulatorJSAdapter
        : typeof window !== "undefined" && window.EmulatorJSAdapter
          ? window.EmulatorJSAdapter
          : undefined;

    // Initialize this.netplay if it doesn't exist
    if (!this.netplay) {
      this.netplay = {};
    }

    // Define reset function
    if (!this.netplay.reset) {
      this.netplay.reset = () => {
        console.log("[Netplay] Resetting netplay state");
        // Stop room list updates
        if (this.netplay.updateList) {
          this.netplay.updateList.stop();
        }
        // Reset netplay state
        this.isNetplay = false;
        // Reset global EJS netplay state
        if (window.EJS) {
          window.EJS.isNetplay = false;
        }
        // TODO: Add more reset logic as needed
      };
    }

    // Replace the current polling mechanism with Socket.IO listener
    this.netplay.updateList = {
      start: () => {
        // Stop any existing operations
        this.netplay.updateList.stop();

        // Set up real-time Socket.IO listener for room updates
        this.netplay.updateList.setupSocketListener();

        // Initial fetch as fallback
        this.netplay.updateList.doInitialFetch();
      },
      setupSocketListener: () => {
        // Clean up any existing listener and timeout
        this.netplay.updateList.removeSocketListener();

        // Check if socket transport exists and is connected
        // Check if socket transport exists and is connected
        const socketTransport = this.emulator?.netplay?.engine?.socketTransport;
        console.log(
          `[Netplay] setupSocketListener: socketTransport exists: ${!!socketTransport}, isConnected: ${socketTransport?.isConnected()}`,
        );

        if (socketTransport?.isConnected()) {
          console.log(
            `[Netplay] Setting up rooms-updated listener on socket ${socketTransport.getSocketId()}`,
          );
          socketTransport.on("rooms-updated", (rooms) => {
            console.log(
              `[Netplay] 🔔 rooms-updated event callback triggered! Received ${rooms?.length || 0} rooms`,
            );
            if (!this.netplay || !this.netplay.table) {
              console.warn(
                "[Netplay] Socket.IO rooms-updated received but table not ready",
              );
              return;
            }
            console.log(
              "[Netplay] ✅ Socket.IO rooms-updated event received:",
              rooms.length,
              "rooms",
            );
            // Debug: log full first room data structure
            if (rooms.length > 0) {
              console.log(
                "[Netplay] ✅ Full first room object from Socket.IO:",
                JSON.stringify(rooms[0], null, 2),
              );
              console.log("[Netplay] ✅ First room metadata:", {
                id: rooms[0].id,
                name: rooms[0].name,
                netplay_mode: rooms[0].netplay_mode,
                typeof_netplay_mode: typeof rooms[0].netplay_mode,
                rom_name: rooms[0].rom_name,
                rom_hash: rooms[0].rom_hash,
                core_type: rooms[0].core_type,
                coreId: rooms[0].coreId,
                allKeys: Object.keys(rooms[0]),
              });
            } else {
              console.log("[Netplay] ⚠️ Socket.IO sent empty room list");
            }
            this.netplayUpdateRoomTable(rooms);
          });
          console.log(
            "[Netplay] Socket.IO listener for rooms-updated established",
          );

          // Clear any pending timeouts
          if (this.netplay.updateList.socketListenerTimeout) {
            clearTimeout(this.netplay.updateList.socketListenerTimeout);
            this.netplay.updateList.socketListenerTimeout = null;
          }
          if (this.netplay.updateList.fallbackTimeout) {
            clearTimeout(this.netplay.updateList.fallbackTimeout);
            this.netplay.updateList.fallbackTimeout = null;
          }
        } else {
          console.log(
            "[Netplay] Socket not connected, will retry listener setup",
          );
          // Retry after a short delay if socket isn't ready yet
          this.netplay.updateList.socketListenerTimeout = setTimeout(
            () => this.netplay.updateList.setupSocketListener(),
            1000,
          );

          // Set a fallback timeout to enable HTTP polling if Socket.IO completely fails
          if (!this.netplay.updateList.fallbackTimeout) {
            this.netplay.updateList.fallbackTimeout = setTimeout(() => {
              console.log(
                "[Netplay] Socket.IO setup timeout, falling back to HTTP polling",
              );
              this.netplayUpdateRoomTable([]);
            }, 30000); // 30 second timeout
          }
        }
      },
      enableHttpPolling: () => {
        // Fallback to HTTP polling if Socket.IO fails completely
        console.log("[Netplay] Enabling HTTP polling fallback");
        const pollRooms = async () => {
          if (!this.netplay || !this.netplay.table) return;

          try {
            const rooms = await this.engine.netplayGetRoomList();
            this.netplayUpdateRoomTable(rooms);
          } catch (error) {
            console.error("[Netplay] HTTP polling failed:", error);
          }
        };

        // Initial poll
        pollRooms();
        // Set up periodic polling
        this.netplay.updateList.httpPollingInterval = setInterval(
          pollRooms,
          5000,
        );
      },
      removeSocketListener: () => {
        if (this.emulator?.netplay?.engine?.socketTransport) {
          this.emulator.netplay.engine.socketTransport.off("rooms-updated");
        }
        if (this.netplay.updateList.socketListenerTimeout) {
          clearTimeout(this.netplay.updateList.socketListenerTimeout);
          this.netplay.updateList.socketListenerTimeout = null;
        }
        if (this.netplay.updateList.fallbackTimeout) {
          clearTimeout(this.netplay.updateList.fallbackTimeout);
          this.netplay.updateList.fallbackTimeout = null;
        }
        if (this.netplay.updateList.httpPollingInterval) {
          clearInterval(this.netplay.updateList.httpPollingInterval);
          this.netplay.updateList.httpPollingInterval = null;
        }
      },
      doInitialFetch: async () => {
        // Request room list via Socket.IO instead of HTTP
        if (!this.netplay || !this.netplay.table) return;

        // Get engine reference (consistent with setupSocketListener)
        const engine = this.emulator?.netplay?.engine || this.engine;

        // Ensure engine is initialized (this creates the socket connection)
        if (!engine || !engine.socketTransport) {
          console.log("[Netplay] Engine not initialized, initializing now...");
          try {
            if (!engine) {
              // Engine doesn't exist yet, wait for it to be created
              console.log("[Netplay] Waiting for engine to be created...");
              return;
            }
            await engine.initialize();
            console.log("[Netplay] Engine initialized successfully");
          } catch (error) {
            console.error("[Netplay] Failed to initialize engine:", error);
            // Fallback to HTTP if socket initialization fails
            try {
              const rooms = await engine.netplayGetRoomList();
              this.netplayUpdateRoomTable(rooms);
            } catch (httpError) {
              console.error("[Netplay] HTTP fallback also failed:", httpError);
            }
            return;
          }
        }

        // Wait for Socket.IO connection, set up listener, then request room list
        let retryCount = 0;
        const maxRetries = 20; // 10 seconds max wait
        const requestRoomList = () => {
          const socketTransport = engine?.socketTransport;
          if (socketTransport?.isConnected()) {
            // Ensure listener is set up before requesting
            this.netplay.updateList.setupSocketListener();
            console.log("[Netplay] Requesting room list via Socket.IO");
            console.log(
              `[Netplay] Socket ID: ${socketTransport.getSocketId()}, Connected: ${socketTransport.isConnected()}`,
            );
            socketTransport.emit("request-room-list", {});
            // The rooms-updated event will be received by setupSocketListener
          } else {
            retryCount++;
            if (retryCount >= maxRetries) {
              console.warn(
                "[Netplay] Socket connection timeout, falling back to HTTP",
              );
              // Fallback to HTTP after timeout
              engine
                .netplayGetRoomList()
                .then((rooms) => this.netplayUpdateRoomTable(rooms))
                .catch((error) =>
                  console.error("[Netplay] HTTP fallback failed:", error),
                );
              return;
            }
            // Retry after a short delay if socket isn't ready yet
            setTimeout(requestRoomList, 500);
          }
        };

        // Start requesting once socket is ready
        requestRoomList();
      },
      stop: () => {
        // cleanup Socket.IO Listener, timeouts, and intervals
        this.netplay.updateList.removeSocketListener();
      },
    };
  }
  // Clean up socket connection monitoring
  removeSocketConnectionMonitoring() {
    if (this.emulator?.netplay?.engine?.socketTransport) {
      const socketTransport = this.emulator.netplay.engine.socketTransport;
      socketTransport.off("connect");
      socketTransport.off("disconnect");
      socketTransport.off("connect_error");
    }
  }

  // Parse detailed compatibility error from SFU
  parseCompatibilityError(error) {
    // Check if error has structured details preserved
    if (error.details && typeof error.details === "object") {
      return {
        type: error.details.error || "unknown",
        message: error.details.message || error.message,
        canJoinAsSpectator: error.details.canJoinAsSpectator || false,
        compatibilityIssues: error.details.compatibilityIssues || [],
        requiredMetadata: error.details.requiredMetadata || {},
      };
    }

    // Fallback: try to parse error message as JSON
    const errorMessage = error.message || error.toString();
    try {
      const errorObj = JSON.parse(errorMessage);
      return {
        type: errorObj.error || "unknown",
        message: errorObj.message || errorMessage,
        canJoinAsSpectator: errorObj.canJoinAsSpectator || false,
        compatibilityIssues: errorObj.compatibilityIssues || [],
        requiredMetadata: errorObj.requiredMetadata || {},
      };
    } catch (e) {
      // Final fallback for plain text errors
      return {
        type: "unknown",
        message: errorMessage,
        canJoinAsSpectator: false,
        compatibilityIssues: [],
        requiredMetadata: {},
      };
    }
  }

  // Show detailed compatibility error dialog
  // Show detailed compatibility error dialog
  showCompatibilityErrorDialog(errorDetails) {
    const popups = this.createSubPopup();
    const container = popups[0];
    const content = popups[1];

    // Style the content container
    content.style.padding = "20px";
    content.style.maxWidth = "500px";
    content.style.textAlign = "center";
    content.classList.add("ejs_cheat_parent");

    // Add title
    const header = this.createElement("div");
    const title = this.createElement("h2");
    title.innerText = "Compatibility Issues";
    title.style.color = "#ff6b6b";
    header.appendChild(title);
    content.appendChild(header);

    // Add main message
    const message = this.createElement("p");
    message.innerText = errorDetails.message;
    message.style.marginBottom = "15px";
    content.appendChild(message);

    // Add compatibility issues list
    if (errorDetails.compatibilityIssues.length > 0) {
      const issuesTitle = this.createElement("h3");
      issuesTitle.innerText = "Specific Issues:";
      issuesTitle.style.marginBottom = "10px";
      content.appendChild(issuesTitle);

      const issuesList = this.createElement("ul");
      issuesList.style.textAlign = "left";
      issuesList.style.marginBottom = "15px";

      errorDetails.compatibilityIssues.forEach((issue) => {
        const listItem = this.createElement("li");
        listItem.innerText = issue;
        listItem.style.marginBottom = "5px";
        issuesList.appendChild(listItem);
      });

      content.appendChild(issuesList);
    }

    // Add required metadata info
    if (Object.keys(errorDetails.requiredMetadata).length > 0) {
      const requiredTitle = this.createElement("h3");
      requiredTitle.innerText = "Room Requirements:";
      requiredTitle.style.marginBottom = "10px";
      content.appendChild(requiredTitle);

      const metadataDiv = this.createElement("div");
      metadataDiv.style.textAlign = "left";
      metadataDiv.style.backgroundColor = "rgba(0,0,0,0.1)";
      metadataDiv.style.padding = "10px";
      metadataDiv.style.borderRadius = "5px";
      metadataDiv.style.marginBottom = "15px";

      Object.entries(errorDetails.requiredMetadata).forEach(([key, value]) => {
        const metaItem = this.createElement("div");
        metaItem.innerText = `${key}: ${value}`;
        metaItem.style.marginBottom = "3px";
        metadataDiv.appendChild(metaItem);
      });

      content.appendChild(metadataDiv);
    }

    // Add buttons
    const buttonContainer = this.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.justifyContent = "center";

    // Close button
    const closeBtn = this.createElement("button");
    closeBtn.classList.add("ejs_button_button");
    closeBtn.innerText = "Close";
    closeBtn.onclick = () => container.remove();
    buttonContainer.appendChild(closeBtn);

    // Spectator join button (if available)
    if (errorDetails.canJoinAsSpectator) {
      const spectatorBtn = this.createElement("button");
      spectatorBtn.classList.add("ejs_button_button");
      spectatorBtn.innerText = "Join as Spectator";
      spectatorBtn.style.backgroundColor = "rgba(255, 193, 7, 0.8)";
      spectatorBtn.onclick = () => {
        container.remove();
        // TODO: Implement spectator join functionality
        alert("Spectator join not yet implemented");
      };
      buttonContainer.appendChild(spectatorBtn);
    }

    content.appendChild(buttonContainer);

    // ✅ CRITICAL: Append container to DOM so it's visible
    if (this.netplayMenu) {
      this.netplayMenu.appendChild(container);
    } else {
      console.error(
        "[NetplayMenu] Cannot show compatibility dialog: netplayMenu not found",
      );
    }
  }

  showOpenRoomDialog = () => {
    // Create a sub-popup within the netplay menu (like "Set Player Name")
    const popups = this.createSubPopup();
    const container = popups[0];
    const content = popups[1];

    // Use the same styling class as "Set Player Name" popup
    content.classList.add("ejs_cheat_parent");

    // Add title to the dialog using proper CSS class
    const header = this.createElement("div");
    const title = this.createElement("h2");
    title.innerText = "Create Room";
    title.classList.add("ejs_netplay_name_heading");
    header.appendChild(title);
    content.appendChild(header);

    // Create form content using proper CSS classes
    const form = this.createElement("form");
    form.classList.add("ejs_netplay_header");

    // Room name input
    const nameHead = this.createElement("strong");
    nameHead.innerText = "Room Name";
    const nameInput = this.createElement("input");
    nameInput.type = "text";
    nameInput.name = "roomName";
    nameInput.setAttribute("maxlength", 50);
    nameInput.placeholder = "Enter room name...";

    // Max players input
    const maxHead = this.createElement("strong");
    maxHead.innerText = "Max Players";
    const maxSelect = this.createElement("select");
    maxSelect.name = "maxPlayers";
    for (let i = 1; i <= 4; i++) {
      const option = this.createElement("option");
      option.value = String(i);
      option.innerText = String(i);
      if (i === 4) option.selected = true;
      maxSelect.appendChild(option);
    }

    // Password input (optional)
    const passHead = this.createElement("strong");
    passHead.innerText = "Password (Optional)";
    const passInput = this.createElement("input");
    passInput.type = "password";
    passInput.name = "password";
    passInput.placeholder = "Leave empty for public room";
    passInput.autocomplete = "off";

    // Spectators
    const spectatorHead = this.createElement("strong");
    spectatorHead.innerText = "Allow Spectators";
    const spectatorSelect = this.createElement("select");
    spectatorSelect.name = "spectators";
    ["Yes", "No"].forEach((val) => {
      const option = this.createElement("option");
      option.value = val.toLowerCase();
      option.innerText = val;
      spectatorSelect.appendChild(option);
    });

    // Room type
    const roomTypeHead = this.createElement("strong");
    roomTypeHead.innerText = "Room Type";
    const roomTypeSelect = this.createElement("select");
    roomTypeSelect.name = "roomType";
    ["Live Stream", "Delay Sync"].forEach((val) => {
      const option = this.createElement("option");
      option.value = val.toLowerCase().replace(" ", "_");
      option.innerText = val;
      roomTypeSelect.appendChild(option);
    });

    // Delay sync options (initially hidden)
    const delaySyncOptions = this.createElement("div");
    delaySyncOptions.style.display = "none";

    const frameDelayHead = this.createElement("strong");
    frameDelayHead.innerText = "Frame Delay";
    const frameDelaySelect = this.createElement("select");
    frameDelaySelect.name = "frameDelay";
    for (let i = 1; i <= 10; i++) {
      const option = this.createElement("option");
      option.value = String(i);
      option.innerText = String(i);
      if (i === 2) option.selected = true;
      frameDelaySelect.appendChild(option);
    }

    const syncModeHead = this.createElement("strong");
    syncModeHead.innerText = "Sync Mode";
    const syncModeSelect = this.createElement("select");
    syncModeSelect.name = "syncMode";
    ["Timeout + Last Known", "Strict Sync"].forEach((val) => {
      const option = this.createElement("option");
      option.value = val === "Timeout + Last Known" ? "timeout" : "strict";
      option.innerText = val;
      syncModeSelect.appendChild(option);
    });

    // Add Frame Delay field with consistent spacing
    const frameDelayContainer = this.createElement("div");
    frameDelayContainer.style.marginBottom = "8px";
    frameDelayContainer.appendChild(frameDelayHead);
    frameDelayContainer.appendChild(this.createElement("br"));
    frameDelayContainer.appendChild(frameDelaySelect);
    delaySyncOptions.appendChild(frameDelayContainer);

    // Add Sync Mode field with consistent spacing
    const syncModeContainer = this.createElement("div");
    syncModeContainer.style.marginBottom = "8px";
    syncModeContainer.appendChild(syncModeHead);
    syncModeContainer.appendChild(this.createElement("br"));
    syncModeContainer.appendChild(syncModeSelect);
    delaySyncOptions.appendChild(syncModeContainer);

    // Add form elements with tighter spacing
    const addField = (label, element) => {
      const fieldContainer = this.createElement("div");
      fieldContainer.style.marginBottom = "8px"; // Tighter spacing between fields
      fieldContainer.appendChild(label);
      fieldContainer.appendChild(this.createElement("br"));
      fieldContainer.appendChild(element);
      form.appendChild(fieldContainer);
    };

    addField(nameHead, nameInput);
    addField(maxHead, maxSelect);
    addField(passHead, passInput);
    addField(spectatorHead, spectatorSelect);
    addField(roomTypeHead, roomTypeSelect);
    form.appendChild(delaySyncOptions);

    content.appendChild(form);

    // Add buttons at the bottom with proper spacing (like other netplay menus)
    content.appendChild(this.createElement("br"));
    const buttonContainer = this.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px"; // Match spacing used in netplay menus
    buttonContainer.style.justifyContent = "center";

    const createBtn = this.createElement("button");
    createBtn.classList.add("ejs_button_button");
    createBtn.classList.add("ejs_popup_submit");
    createBtn.style["background-color"] = "rgba(var(--ejs-primary-color),1)";
    createBtn.innerText = "Create";
    createBtn.onclick = async () => {
      const roomName = nameInput.value.trim();
      const maxPlayers = parseInt(maxSelect.value, 10);
      const password = passInput ? passInput.value.trim() || null : null;
      const allowSpectators = spectatorSelect
        ? spectatorSelect.value === "yes"
        : true;
      const roomType = roomTypeSelect.value;
      const frameDelay = frameDelaySelect
        ? parseInt(frameDelaySelect.value, 10)
        : 2;
      const syncMode = syncModeSelect ? syncModeSelect.value : "timeout";

      if (!roomName) {
        alert("Please enter a room name");
        return;
      }

      try {
        container.remove(); // Remove the popup
        await this.engine.netplayCreateRoom(
          roomName,
          maxPlayers,
          password,
          allowSpectators,
          roomType,
          frameDelay,
          syncMode,
        );
      } catch (error) {
        console.error("[Netplay] Failed to create room:", error);
        alert("Failed to create room: " + error.message);
      }
    };

    const cancelBtn = this.createElement("button");
    cancelBtn.classList.add("ejs_button_button");
    cancelBtn.innerText = "Cancel";
    cancelBtn.onclick = () => {
      container.remove(); // Remove the popup
    };

    buttonContainer.appendChild(createBtn);
    buttonContainer.appendChild(cancelBtn);
    content.appendChild(buttonContainer);

    // Show/hide delay sync options based on room type
    roomTypeSelect.addEventListener("change", () => {
      delaySyncOptions.style.display =
        roomTypeSelect.value === "delay_sync" ? "" : "none";
    });

    // Add the popup to the netplay menu (like "Set Player Name")
    if (this.netplayMenu) {
      this.netplayMenu.appendChild(container);
    }

    // Focus on room name input
    setTimeout(() => nameInput.focus(), 100);
  };

  updateNetplayUI(isJoining) {
    if (!this.emulator.elements.bottomBar) return;

    const bar = this.emulator.elements.bottomBar;
    const isClient = !this.netplay.owner;
    const shouldHideButtons = isJoining && isClient;
    const elementsToToggle = [
      ...(bar.playPause || []),
      ...(bar.restart || []),
      ...(bar.saveState || []),
      ...(bar.loadState || []),
      ...(bar.cheat || []),
      ...(bar.saveSavFiles || []),
      ...(bar.loadSavFiles || []),
      ...(bar.exit || []),
      ...(bar.contextMenu || []),
      ...(bar.cacheManager || []),
    ];

    // Add the parent containers to the same logic
    if (
      bar.settings &&
      bar.settings.length > 0 &&
      bar.settings[0].parentElement
    ) {
      elementsToToggle.push(bar.settings[0].parentElement);
    }
    if (this.diskParent) {
      elementsToToggle.push(this.diskParent);
    }

    elementsToToggle.forEach((el) => {
      if (el) {
        el.classList.toggle("netplay-hidden", shouldHideButtons);
      }
    });
  }

  createNetplayMenu() {
    // Check if menu already exists
    const menuExists = !!this.netplayMenu;

    // Extract player name from JWT token
    let playerName = "Player"; // Default fallback

    try {
      // Get token from window.EJS_netplayToken or token cookie
      let token = window.EJS_netplayToken;
      if (!token) {
        // Try to get token from cookie
        const cookies = document.cookie.split(";");
        for (const cookie of cookies) {
          const [name, value] = cookie.trim().split("=");
          if (name === "romm_sfu_token" || name === "sfu_token") {
            token = decodeURIComponent(value);
            break;
          }
        }
      }

      if (token) {
        // Decode JWT payload to get netplay ID from 'sub' field
        // JWT uses base64url encoding, not standard base64, so we need to convert
        const base64UrlDecode = (str) => {
          // Convert base64url to base64 by replacing chars and adding padding
          let base64 = str.replace(/-/g, "+").replace(/_/g, "/");
          while (base64.length % 4) {
            base64 += "=";
          }

          // Decode base64 to binary string, then convert to proper UTF-8
          const binaryString = atob(base64);

          // Convert binary string to UTF-8 using TextDecoder if available, otherwise fallback
          if (typeof TextDecoder !== "undefined") {
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
            return new TextDecoder("utf-8").decode(bytes);
          } else {
            // Fallback for older browsers: this may not handle all UTF-8 correctly
            return decodeURIComponent(escape(binaryString));
          }
        };

        try {
          const payloadStr = base64UrlDecode(token.split(".")[1]);
          const payload = JSON.parse(payloadStr);

          if (payload.sub) {
            // Use the netplay ID as player name, truncate if too long (Unicode-safe)
            playerName = Array.from(payload.sub).slice(0, 20).join("");
          }
        } catch (parseError) {
          console.error(
            "[NetplayMenu] Failed to parse JWT payload:",
            parseError,
          );
        }
      }
    } catch (e) {
      console.warn(
        "[NetplayMenu] Failed to extract player name from token:",
        e,
      );
    }

    if (!menuExists) {
      // Create popup first, but pass empty buttons array for setup by createBottomBarButtons
      const body = this.createPopup("Netplay Listings", {}, true);

      // Set netplayMenu
      this.netplayMenu = body.parentElement;
      const rooms = this.createElement("div");
      this.defineNetplayFunctions();
      const table = this.createNetplayTable("listings", rooms);
      const joined = this.createElement("div");
      const title2 = this.createElement("strong");
      title2.innerText = "{roomname}";
      const password = this.createElement("div");
      password.innerText = "Password: ";

      // Joined-room controls (shown only after join/create)
      const joinedControls = this.createElement("div");
      joinedControls.classList.add("ejs_netplay_header");
      joinedControls.style.display = "flex";
      joinedControls.style.alignItems = "center";
      joinedControls.style.gap = "10px";
      joinedControls.style.margin = "10px 0";
      joinedControls.style.justifyContent = "flex-start";

      const slotLabel = this.createElement("strong");
      slotLabel.innerText = this.localization("Player Slot") || "Player Slot";
      const slotSelect = this.createElement("select");
      for (let i = 0; i < 4; i++) {
        const opt = this.createElement("option");
        opt.value = String(i);
        opt.innerText = "P" + (i + 1);
        slotSelect.appendChild(opt);
      }
      joinedControls.appendChild(slotLabel);
      joinedControls.appendChild(slotSelect);

      joined.appendChild(title2);
      joined.appendChild(password);
      joined.appendChild(joinedControls);

      joined.style.display = "none";
      body.appendChild(rooms);
      body.appendChild(joined);

      // Extract player name from RomM netplay ID token
      let playerName = "Player"; // Default fallback

      try {
        // Get token from window.EJS_netplayToken or token cookie
        let token = window.EJS_netplayToken;
        if (!token) {
          // Try to get token from cookie (same logic as NetplayEngine)
          const cookies = document.cookie.split(";");
          for (const cookie of cookies) {
            const [name, value] = cookie.trim().split("=");
            if (name === "romm_sfu_token" || name === "sfu_token") {
              token = decodeURIComponent(value);
              break;
            }
          }
        }

        if (token) {
          // Decode JWT payload to get netplay ID from 'sub' field
          // JWT uses base64url encoding, not standard base64, so we need to convert
          const base64UrlDecode = (str) => {
            // Convert base64url to base64 by replacing chars and adding padding
            let base64 = str.replace(/-/g, "+").replace(/_/g, "/");
            while (base64.length % 4) {
              base64 += "=";
            }

            // Decode base64 to binary string, then convert to proper UTF-8
            const binaryString = atob(base64);

            // Convert binary string to UTF-8 using TextDecoder if available, otherwise fallback
            if (typeof TextDecoder !== "undefined") {
              const bytes = new Uint8Array(binaryString.length);
              for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
              }
              return new TextDecoder("utf-8").decode(bytes);
            } else {
              // Fallback for older browsers: this may not handle all UTF-8 correctly
              return decodeURIComponent(escape(binaryString));
            }
          };

          try {
            const payloadStr = base64UrlDecode(token.split(".")[1]);
            console.log("[EmulatorJS] Raw JWT payload:", payloadStr);
            const payload = JSON.parse(payloadStr);
            console.log("[EmulatorJS] Parsed JWT payload:", payload);

            if (payload.sub) {
              console.log("[EmulatorJS] Original sub field:", payload.sub);
              // Use the netplay ID as player name, truncate if too long (Unicode-safe)
              playerName = Array.from(payload.sub).slice(0, 20).join("");
              console.log("[EmulatorJS] Extracted player name:", playerName);
              console.log(
                "[EmulatorJS] Player name char codes:",
                Array.from(playerName).map((c) => c.charCodeAt(0)),
              );
            }
          } catch (parseError) {
            console.error(
              "[EmulatorJS] Failed to parse JWT payload:",
              parseError,
            );
          }
        }
      } catch (e) {
        console.warn(
          "[EmulatorJS] Failed to extract player name from token:",
          e,
        );
      }

      // Create the netplay object after extracting the player name
      this.emulator.netplay = {
        name: playerName,
        engine: this.engine,
        passwordElem: password,
        roomNameElem: title2,
        createButton: this.leaveCreateButton,
        tabs: [rooms, joined],
        slotSelect: slotSelect,
        // Single source of truth for netplay ID - prioritizes session state over fallbacks
        getNetplayId: function () {
          // Priority order: session state (authenticated) > name > "local"
          return (
            this.engine?.sessionState?.localPlayerId || this.name || "local"
          );
        },
        ...this.emulator.netplay,
      };

      // Update existing player data if player table was already created
      if (this.emulator.netplay.joinedPlayers) {
        // Update the local player's name in joinedPlayers
        const localPlayer = this.emulator.netplay.joinedPlayers.find(
          (p) =>
            p.name === "local" ||
            p.name ===
              this.emulator.netplay.engine?.sessionState?.localPlayerId,
        );
        if (localPlayer) {
          localPlayer.name = playerName;
        }

        // Refresh the delay sync player table if it exists
        if (this.emulator.netplay.delaySyncPlayerTable) {
          // Clear and recreate the table with updated names
          this.emulator.netplay.delaySyncPlayerTable.innerHTML = "";
          this.emulator.netplay.joinedPlayers.forEach((player) => {
            this.netplayUpdatePlayerTable(player.slot);
          });
        }
      }

      if (this.netplayShowTurnWarning && !this.netplayWarningShown) {
        const warningDiv = this.createElement("div");
        warningDiv.className = "ejs_netplay_warning";
        warningDiv.innerText =
          "Warning: No TURN server configured. Netplay connections may fail.";
        const menuBody = this.netplayMenu.querySelector(".ejs_popup_body");
        if (menuBody) {
          menuBody.prepend(warningDiv);
          this.netplayWarningShown = true;
        }
      }
    }

    // Setup correct UI based on current room state before showing
    // Use engine's sessionState as single source of truth (most reliable)
    // IMPORTANT: Check both engine existence AND room state to avoid stale data after leaving
    const engine = this.emulator.netplay?.engine;
    const hasEngine = engine != null;
    const hasSessionState = engine?.sessionState != null;
    const hasRoomName = engine?.sessionState?.roomName != null;
    const hasCurrentRoom = this.emulator.netplay?.currentRoom != null;

    // Only consider ourselves "in room" if ALL conditions are met:
    // 1. Engine exists (not cleared after leaving)
    // 2. SessionState exists
    // 3. Room name is set in session state
    // 4. CurrentRoom object exists
    // This prevents showing room UI when we've left but cleanup hasn't completed
    const isInRoom =
      hasEngine && hasSessionState && hasRoomName && hasCurrentRoom;

    console.log("[NetplayMenu] createNetplayMenu state check:", {
      hasEngine,
      hasSessionState,
      hasRoomName,
      hasCurrentRoom,
      isInRoom,
      roomName: engine?.sessionState?.roomName,
      currentRoomId: this.emulator.netplay?.currentRoomId,
    });

    if (this.emulator.netplay && isInRoom) {
      // User is in a room, setup room UI
      // Get room type from currentRoom if available, otherwise default to livestream
      const netplayMode = this.emulator.netplay.currentRoom?.netplay_mode;
      const roomType =
        netplayMode === "delay_sync" || netplayMode === 1
          ? "delaysync"
          : "livestream";
      // Ensure room UI elements exist (they might not if menu was created before joining room)
      if (roomType === "livestream" && !this.netplay.liveStreamPlayerTable) {
        // Set up the player slot selector first
        const slotSelect = this.createSlotSelector();
        this.netplay.slotSelect = slotSelect;

        // Add slot selector to the joined tab
        if (this.netplay.tabs && this.netplay.tabs[1]) {
          this.netplay.tabs[1].appendChild(slotSelect);
        }

        // Create the player table
        const table = this.createNetplayTable("livestream");

        // Insert table after the slot selector (as sibling of slot selector's parent container)
        if (this.netplay.slotSelect && this.netplay.slotSelect.parentElement) {
          this.netplay.slotSelect.parentElement.parentElement.insertBefore(
            table,
            this.netplay.slotSelect.parentElement.nextSibling,
          );
        }

        // This populates and updates the table.
        this.netplayUpdatePlayerTable(this.netplay.joinedPlayers); // Uses real data
      } else if (
        roomType === "delaysync" &&
        !this.netplay.delaySyncPlayerTable
      ) {
        // Set up the player slot selector first
        const slotSelect = this.createSlotSelector();
        this.netplay.slotSelect = slotSelect;

        // Add slot selector to the joined tab
        if (this.netplay.tabs && this.netplay.tabs[1]) {
          this.netplay.tabs[1].appendChild(slotSelect);
        }

        // Create the player table
        const table = this.createNetplayTable("delaysync");

        // Insert table after the slot selector (as sibling of slot selector's parent container)
        if (this.netplay.slotSelect && this.netplay.slotSelect.parentElement) {
          this.netplay.slotSelect.parentElement.parentElement.insertBefore(
            table,
            this.netplay.slotSelect.parentElement.nextSibling,
          );
        }

        // Initialize player list (host is always player 1)
        this.netplayUpdatePlayerTable(this.netplay.joinedPlayers);
      }

      // Hide/show the correct table based on room type
      if (roomType === "livestream") {
        // Hide delay sync table if it exists
        if (
          this.netplay.delaySyncPlayerTable &&
          this.netplay.delaySyncPlayerTable.parentElement
        ) {
          const table = this.netplay.delaySyncPlayerTable.parentElement;
          table.style.display = "none";
        }
        // Show live stream table if it exists
        if (
          this.netplay.liveStreamPlayerTable &&
          this.netplay.liveStreamPlayerTable.parentElement
        ) {
          const table = this.netplay.liveStreamPlayerTable.parentElement;
          table.style.display = "";
        }
      } else if (roomType === "delaysync") {
        // Hide live stream table if it exists
        if (
          this.netplay.liveStreamPlayerTable &&
          this.netplay.liveStreamPlayerTable.parentElement
        ) {
          const table = this.netplay.liveStreamPlayerTable.parentElement;
          table.style.display = "none";
        }
        // Show delay sync table if it exists
        if (
          this.netplay.delaySyncPlayerTable &&
          this.netplay.delaySyncPlayerTable.parentElement
        ) {
          const table = this.netplay.delaySyncPlayerTable.parentElement;
          table.style.display = "";
        }
      }

      // Switch to joined tab for room view
      if (this.netplay.tabs && this.netplay.tabs[0] && this.netplay.tabs[1]) {
        this.netplay.tabs[0].style.display = "none"; // Hide rooms tab
        this.netplay.tabs[1].style.display = ""; // Show joined tab
      }

      // Update title based on room type
      const titleElement = this.netplayMenu.querySelector("h4");
      if (titleElement) {
        titleElement.innerText =
          roomType === "delaysync" ? "Delay Sync Room" : "Live Stream Room";
      }

      // Setup bottom bar for room type
      this.setupNetplayBottomBar(roomType);

      // Update room info display
      if (this.netplay.roomNameElem) {
        this.netplay.roomNameElem.innerText =
          this.emulator.netplay.currentRoom?.name ||
          this.emulator.netplay.currentRoomId;
      }
      if (this.netplay.passwordElem) {
        const hasPassword = this.emulator.netplay.currentRoom?.password;
        this.netplay.passwordElem.innerText = hasPassword
          ? `Password: ${"*".repeat(hasPassword.length)}`
          : "";
        this.netplay.passwordElem.style.display = hasPassword ? "" : "none";
      }
    } else {
      // User is not in a room, setup listings UI
      // IMPORTANT: Clear any stale room state to prevent showing old player tables
      console.log(
        "[NetplayMenu] Not in room - clearing stale state and showing listings",
      );

      // Clear stale room type to prevent using wrong player table
      this.currentRoomType = "listings";

      // Clear stale player data that might persist after leaving
      if (this.netplay) {
        // Clear joined players array if it exists
        if (
          this.netplay.joinedPlayers &&
          Array.isArray(this.netplay.joinedPlayers)
        ) {
          this.netplay.joinedPlayers = [];
        }
        // Clear player table references (but keep DOM elements for reuse)
        // The tables themselves will be hidden below
      }

      this.setupNetplayBottomBar("listings");

      // Reset title to listings
      const titleElement = this.netplayMenu.querySelector("h4");
      if (titleElement) {
        titleElement.innerText = "Netplay Listings";
      }

      // Hide both player tables when showing listings (they might be visible from previous room)
      // This is critical - ensure tables are hidden AND cleared even if they contain stale data
      if (
        this.netplay?.liveStreamPlayerTable &&
        this.netplay.liveStreamPlayerTable.parentElement
      ) {
        // Clear the table content to remove stale player data
        this.netplay.liveStreamPlayerTable.innerHTML = "";
        const table = this.netplay.liveStreamPlayerTable.parentElement;
        table.style.display = "none";
        console.log("[NetplayMenu] Cleared and hid liveStreamPlayerTable");
      }
      if (
        this.netplay?.delaySyncPlayerTable &&
        this.netplay.delaySyncPlayerTable.parentElement
      ) {
        // Clear the table content to remove stale player data
        this.netplay.delaySyncPlayerTable.innerHTML = "";
        const table = this.netplay.delaySyncPlayerTable.parentElement;
        table.style.display = "none";
        console.log("[NetplayMenu] Cleared and hid delaySyncPlayerTable");
      }

      // Switch to rooms tab when showing listings
      if (this.netplay.tabs && this.netplay.tabs[0] && this.netplay.tabs[1]) {
        this.netplay.tabs[0].style.display = ""; // Show rooms tab
        this.netplay.tabs[1].style.display = "none"; // Hide joined tab
        console.log("[NetplayMenu] Switched to rooms tab (listings view)");
      }

      // Ensure room list container is visible (in case it was hidden)
      const roomsContainer = this.netplayMenu?.querySelector(
        ".ejs_popup_body > div:first-child",
      );
      if (roomsContainer) {
        roomsContainer.style.display = "";
      }

      // Aggressively hide all room UI elements when showing listings
      // Hide slot selector and its container
      if (this.netplay.slotSelect) {
        if (this.netplay.slotSelect.parentElement) {
          this.netplay.slotSelect.parentElement.style.display = "none";
        }
        this.netplay.slotSelect.style.display = "none";
      }

      // Clear and hide room name
      if (this.netplay.roomNameElem) {
        this.netplay.roomNameElem.innerText = "";
        this.netplay.roomNameElem.style.display = "none";
      }

      // Clear and hide password
      if (this.netplay.passwordElem) {
        this.netplay.passwordElem.innerText = "";
        this.netplay.passwordElem.style.display = "none";
      }

      // Ensure joined tab is completely hidden
      if (this.netplay.tabs && this.netplay.tabs[1]) {
        this.netplay.tabs[1].style.display = "none";
      }
    }

    // Show netplay menu
    this.netplayMenu.style.display = "block";

    // Hide player slot selector in lobby view (only for new menus)
    if (
      !menuExists &&
      this.netplay &&
      this.netplay.slotSelect &&
      this.netplay.slotSelect.parentElement
    ) {
      this.netplay.slotSelect.parentElement.style.display = "none";
    }

    // Show player name popup only if no valid name was extracted from token AND this is a new menu
    if (!menuExists && (!playerName || playerName === "Player")) {
      this.netplay = {
        passwordElem: password,
        roomNameElem: title2,
        createButton: this.leaveCreateButton,
        tabs: [rooms, joined],
        slotSelect: slotSelect,
        ...this.netplay,
      };
      const popups = this.createSubPopup();
      this.netplayMenu.appendChild(popups[0]);
      popups[1].classList.add("ejs_cheat_parent");
      const popup = popups[1];

      const header = this.createElement("div");
      const title = this.createElement("h2");
      title.innerText = this.localization("Set Player Name");
      title.classList.add("ejs_netplay_name_heading");
      header.appendChild(title);
      popup.appendChild(header);

      const main = this.createElement("div");
      main.classList.add("ejs_netplay_header");
      const head = this.createElement("strong");
      head.innerText = this.localization("Player Name");
      const input = this.createElement("input");
      input.type = "text";
      input.setAttribute("maxlength", 20);

      main.appendChild(head);
      main.appendChild(this.createElement("br"));
      main.appendChild(input);
      popup.appendChild(main);

      popup.appendChild(this.createElement("br"));
      const submit = this.createElement("button");
      submit.classList.add("ejs_button_button");
      submit.classList.add("ejs_popup_submit");
      submit.style["background-color"] = "rgba(var(--ejs-primary-color),1)";
      submit.innerText = this.localization("Submit");
      popup.appendChild(submit);
      this.addEventListener(submit, "click", (e) => {
        if (!input.value.trim()) return;
        const enteredName = input.value.trim();
        this.netplay.name = enteredName;
        this.emulator.netplay.name = enteredName; // Also update the emulator netplay object
        popups[0].remove();
      });
    }
    // Only setup listings bottom bar if we're not in a room
    // (if we're in a room, it was already set up above)
    if (!isInRoom) {
      this.setupNetplayBottomBar("listings");
      if (this.netplay?.updateList) {
        this.netplay.updateList.start();
      }
    } else if (this.netplay.readyButton && this.netplay.launchButton) {
      this.netplayUpdateLaunchButton();
      this.netplayUpdateReadyButton();
    }
  }

  // Create a a slot slector with styling and listener to update input slot and player table
  createSlotSelector(container = null, position = "append") {
    // If a slot selector already exists and we're adding to a container, remove the old one first
    if (
      container &&
      this.netplay?.slotSelect &&
      this.netplay.slotSelect.parentElement
    ) {
      const oldSelector = this.netplay.slotSelect;
      const oldParent = oldSelector.parentElement;

      // Find and remove the label that comes before the selector
      const oldLabel = Array.from(oldParent.childNodes).find(
        (node) =>
          node.nodeType === Node.ELEMENT_NODE &&
          node.tagName === "STRONG" &&
          (node.innerText.includes("Player Select") ||
            node.innerText.includes("Player Slot")),
      );
      if (oldLabel) {
        oldLabel.remove();
      }
      oldSelector.remove();
      console.log(
        "[NetplayMenu] Removed existing slot selector before creating new one",
      );
    }

    const slotSelect = this.createElement("select");
    // Add basic styling to make it look like a proper dropdown
    slotSelect.style.backgroundColor = "#333";
    slotSelect.style.border = "1px solid #555";
    slotSelect.style.borderRadius = "4px";
    slotSelect.style.padding = "4px 8px";
    slotSelect.style.minWidth = "80px";
    slotSelect.style.cursor = "pointer";
    slotSelect.style.color = "#fff";

    // Add options to select element
    for (let i = 0; i < 4; i++) {
      const opt = this.createElement("option");
      opt.value = String(i);
      opt.innerText = "P" + (i + 1);
      slotSelect.appendChild(opt);
    }

    // Add spectator option
    const spectatorOpt = this.createElement("option");
    spectatorOpt.value = "4";
    spectatorOpt.innerText = "Spectator";
    slotSelect.appendChild(spectatorOpt);

    // Determine current player's slot (prioritize localSlot, then find by name/ID)
    let currentPlayerSlot = this.netplay.localSlot;
    if (currentPlayerSlot === undefined || currentPlayerSlot === null) {
      // Try to find current player in joined players
      const localPlayerId = this.netplay.engine?.sessionState?.localPlayerId;
      const localPlayerName = this.netplay.name;
      const localPlayer = this.netplay.joinedPlayers?.find(
        (p) =>
          (localPlayerId && p.id === localPlayerId) ||
          (localPlayerName && p.name === localPlayerName),
      );
      if (localPlayer) {
        currentPlayerSlot = localPlayer.slot;
        // Update localSlot to match
        this.netplay.localSlot = currentPlayerSlot;
      }
    }

    // Get current value (preference or previously selected)
    const currentValue =
      this.netplayPreferredSlot ||
      (typeof window !== "undefined"
        ? window.EJS_NETPLAY_PREFERRED_SLOT
        : null) ||
      null;

    // Set the current selection to the player's assigned slot, or first available
    if (
      currentPlayerSlot !== undefined &&
      currentPlayerSlot !== null &&
      slotSelect.querySelector(`option[value="${currentPlayerSlot}"]`)
    ) {
      // Player has an assigned slot and it's available in the dropdown, select it
      slotSelect.value = String(currentPlayerSlot);
      console.log(
        `[NetplayMenu] Set slot selector to current player slot: ${currentPlayerSlot}`,
      );
    } else if (slotSelect.querySelector(`option[value="${currentValue}"]`)) {
      // Restore previous selection if valid
      slotSelect.value = currentValue;
    } else if (slotSelect.options.length > 0) {
      // Select first available option
      slotSelect.value = slotSelect.options[0].value;
      console.log(
        `[NetplayMenu] Set slot selector to first available: ${slotSelect.value}`,
      );
    }
    // Attach event listener immediately
    this.addEventListener(slotSelect, "change", async () => {
      const raw = parseInt(slotSelect.value, 10);
      const slot = isNaN(raw) ? 0 : Math.max(0, Math.min(8, raw));
      console.log("[NetplayMenu] Slot selector changed to:", slot);

      try {
        await this.requestSlotChange(slot);

        // Only save settings if server accepted the change
        if (this.settings) {
          this.settings.netplayPreferredSlot = String(slot);
        }
        this.saveSettings();
      } catch (error) {
        console.error(
          "[NetplayMenu] Slot change rejected by server:",
          error.message,
        );

        // Revert the slot selector to its previous value
        const previousValue =
          this.netplay.localSlot !== undefined ? this.netplay.localSlot : 0;
        slotSelect.value = String(previousValue);

        // Show user feedback about why the change was rejected
        alert(`Cannot change to slot ${slot}: ${error.message}`);
      }
    });
    // If container provided, insert into DOM
    if (container) {
      const slotLabel = this.createElement("strong");
      slotLabel.innerText =
        this.localization("Player Select: ") || "Player Select: ";
      slotLabel.marginRight = "10px"; // some spacing

      if (position === "append") {
        container.appendChild(slotLabel);
        container.appendChild(slotSelect);
      } else if (position === "prepend") {
        // For prepend, insert both label and select at the beginning
        container.insertBefore(slotSelect, container.firstChild);
        container.insertBefore(slotLabel, slotSelect);
      }
    }

    return slotSelect;
  }

  // Hook into emulator's volume control to sync stream audio volume
  netplaySetupStreamVolumeControl() {
    if (this.netplay._volumeControlHooked) {
      return;
    }
    this.netplay._volumeControlHooked = true;

    // Store original setVolume method
    const originalSetVolume = this.emulator.setVolume.bind(this.emulator);

    // Override setVolume to also update stream audio
    this.emulator.setVolume = (volume) => {
      // Call original method first
      originalSetVolume(volume);

      // Update stream audio element volume
      const audioElement = this.netplay.mediaElements?.audio;
      if (audioElement) {
        audioElement.volume = volume;
      }
    };

    // Also sync when volume property is set directly
    let volumeProperty = this.emulator.volume;
    Object.defineProperty(this.emulator, "volume", {
      get: function () {
        return volumeProperty;
      },
      set: function (value) {
        volumeProperty = value;
        // Update stream audio if it exists
        const audioElement = this.netplay?.mediaElements?.audio;
        if (audioElement) {
          audioElement.volume = value;
        }
        // Call setVolume to update UI and emulator audio
        if (this.setVolume) {
          this.setVolume(value);
        }
      },
    });

    console.log(
      "[NetplayMenu] Stream audio volume control hooked into emulator volume",
    );
  }

  /**
   * Validate player data and log debug information
   * @param {Object} data - Player data from server
   * @returns {boolean} True if validation passed
   */
  validateAndDebugPlayerData(data) {
    console.log("[NetplayMenu] Updating player list:", data);
    console.log(
      "[NetplayMenu] Players object keys:",
      Object.keys(data.players || {}),
    );
    console.log(
      "[NetplayMenu] Players object values:",
      Object.values(data.players || {}),
    );

    // Debug player data structure
    if (data.players) {
      Object.entries(data.players).forEach(([playerId, playerData]) => {
        console.log(`[NetplayMenu] Player ${playerId} data:`, {
          name: playerData.name,
          player_name: playerData.player_name,
          netplay_username: playerData.netplay_username,
          allKeys: Object.keys(playerData),
        });
      });
    }

    if (!data || !data.players) {
      console.warn("[NetplayMenu] No players data provided");
      return false;
    }
    return true;
  }

  /**
   * Convert server player format to local joinedPlayers format
   * @param {Object} data - Player data from server
   * @returns {Array} Array of player objects in local format
   */
  convertServerPlayersToLocalFormat(data) {
    const playersArray = Object.entries(data.players).map(
      ([playerId, playerData]) => {
        // Prefer netplay_username for display (censored), fallback to player_name (uncensored), then name
        const resolvedName =
          playerData.netplay_username ||
          playerData.player_name ||
          playerData.name ||
          "Unknown";
        console.log(`[NetplayMenu] Player ${playerId} name resolution:`, {
          name: playerData.name,
          player_name: playerData.player_name,
          netplay_username: playerData.netplay_username,
          resolvedName,
        });
        return {
          id: playerId,
          slot: playerData.slot || playerData.player_slot || 0,
          name: resolvedName,
          ready: playerData.ready || false,
          // Include any other properties that might be needed
          ...playerData,
        };
      },
    );
    console.log("[NetplayMenu] Converted playersArray:", playersArray);
    console.log("[NetplayMenu] playersArray length:", playersArray.length);

    return playersArray;
  }

  /**
   * Identify the local player from session state
   * @returns {Object} Object with localPlayerId and localPlayerName
   */
  identifyLocalPlayer() {
    const localPlayerId = this.netplay.engine?.sessionState?.localPlayerId;
    const localPlayerName = this.netplay.name;
    console.log(
      "[NetplayMenu] Local player ID:",
      localPlayerId,
      "Local player name:",
      localPlayerName,
    );

    return { localPlayerId, localPlayerName };
  }

  /**
   * Process player slots, preserving local player's slot and auto-assigning for others
   * @param {Array} playersArray - Array of player objects
   * @param {string} localPlayerId - Local player ID
   * @param {string} localPlayerName - Local player name
   * @returns {Set} Set of taken slots
   */
  processPlayerSlots(playersArray, localPlayerId, localPlayerName) {
    // Track current taken slots (spectators don't take player slots)
    const takenSlots = new Set();
    playersArray.forEach((player) => {
      if (
        player.slot !== undefined &&
        player.slot !== null &&
        player.slot !== 8
      ) {
        takenSlots.add(player.slot);
      }
    });

    // Auto-assign slots to players who don't have one or have conflicting slots
    playersArray.forEach((player, index) => {
      // Check if this is the local player
      const isLocalPlayer =
        (localPlayerId && player.id === localPlayerId) ||
        (localPlayerName && player.name === localPlayerName);

      // For local player, preserve their assigned slot from session state
      if (isLocalPlayer) {
        // If we found the local player by name but not by ID, update the session state with the correct ID
        if (!localPlayerId || player.id !== localPlayerId) {
          console.log(
            `[NetplayMenu] Updating session state local player ID from ${localPlayerId} to ${player.id} (matched by name)`,
          );
          if (this.netplay?.engine?.sessionState) {
            this.netplay.engine.sessionState.localPlayerId = player.id;
          }
        }

        const currentLocalSlot =
          this.netplay?.engine?.sessionState?.getLocalPlayerSlot() ??
          this.netplay?.localSlot;
        if (currentLocalSlot !== null && currentLocalSlot !== undefined) {
          // Override server data with local player's actual slot
          player.slot = currentLocalSlot;
          console.log(
            `[NetplayMenu] Preserving local player slot ${currentLocalSlot} for ${player.name}`,
          );
        }
      }

      // If player has no slot assigned or slot conflicts, assign a free slot
      // (Skip local player since we preserved their slot above, and skip spectators)
      if (
        !isLocalPlayer &&
        player.slot !== 8 &&
        (player.slot === undefined || player.slot === null)
      ) {
        // Find lowest available slot
        let newSlot = 0;
        while (takenSlots.has(newSlot) && newSlot < 4) {
          newSlot++;
        }

        if (newSlot < 4) {
          console.log(
            `[NetplayMenu] Auto-assigning slot ${newSlot} to player ${player.name} (was ${player.slot})`,
          );
          player.slot = newSlot;
          takenSlots.add(newSlot);

          // Update local slot preference if this is the local player
          if (isLocalPlayer) {
            this.netplay.localSlot = newSlot;
            this.netplayPreferredSlot = newSlot;
            window.EJS_NETPLAY_PREFERRED_SLOT = newSlot;
            if (this.netplay.extra) {
              this.netplay.extra.player_slot = newSlot;
            }
            // Update slot selector UI to reflect server-assigned slot
            if (this.netplay.slotSelect) {
              this.netplay.slotSelect.value = String(newSlot);
              console.log(
                `[NetplayMenu] Updated slot selector UI to slot ${newSlot}`,
              );
            }
            console.log(
              `[NetplayMenu] Updated local player slot to ${newSlot}`,
            );
          }
        } else {
          console.warn(
            `[NetplayMenu] No available slots for player ${player.name}`,
          );
        }
      } else {
        // Slot is valid, mark it as taken
        takenSlots.add(player.slot);
      }
    });

    return takenSlots;
  }

  /**
   * Synchronize local state arrays with processed player data
   * @param {Array} playersArray - Array of processed player objects
   */
  synchronizeLocalState(playersArray) {
    // Update joinedPlayers array
    this.netplay.joinedPlayers = playersArray;

    // Update taken slots (spectators don't take player slots)
    if (!this.netplay.takenSlots) {
      this.netplay.takenSlots = new Set();
    }
    this.netplay.takenSlots.clear();
    playersArray.forEach((player) => {
      if (player.slot !== 8) {
        // Spectators don't take player slots
        this.netplay.takenSlots.add(player.slot);
      }
    });

    // Update ready states array
    const maxPlayers = this.netplay.maxPlayers || 4;
    this.netplay.playerReadyStates = new Array(maxPlayers).fill(false);
    playersArray.forEach((player) => {
      if (player.slot < maxPlayers) {
        this.netplay.playerReadyStates[player.slot] = player.ready || false;
      }
    });
  }

  /**
   * Update player UI components (table, selector, buttons)
   * @param {Array} playersArray - Array of player objects
   */
  updatePlayerUI(playersArray) {
    // Update the appropriate player table
    if (
      this.netplay.delaySyncPlayerTable ||
      this.netplay.liveStreamPlayerTable
    ) {
      // Use getPlayerTable() to ensure local player is always included
      const playerTable = this.getPlayerTable();
      const playersToDisplay = Object.values(playerTable);

      const tableType = this.netplay.delaySyncPlayerTable
        ? "delay sync"
        : "live stream";
      console.log(
        `[NetplayMenu] Rebuilding ${tableType} player table with`,
        playersToDisplay.length,
        "players",
      );

      // Clear existing table
      const tbody =
        this.netplay.delaySyncPlayerTable || this.netplay.liveStreamPlayerTable;
      console.log(
        "[NetplayMenu] Clearing existing table, had",
        tbody.children.length,
        "rows",
      );
      tbody.innerHTML = "";

      // Rebuild table with current players
      console.log(
        `[NetplayMenu] Rebuilding table with ${playersToDisplay.length} players`,
      );
      this.netplayUpdatePlayerTable(playersToDisplay);

      console.log(
        "[NetplayMenu] Table rebuild complete, now has",
        tbody.children.length,
        "rows",
      );

      // Log the content of each row
      for (let i = 0; i < tbody.children.length; i++) {
        const row = tbody.children[i];
        const cells = row.querySelectorAll("td");
        const cellTexts = Array.from(cells).map((cell) => cell.textContent);
        console.log(`[NetplayMenu] Row ${i} content:`, cellTexts);
      }

      // Also log the entire table HTML for debugging
      console.log("[NetplayMenu] Table HTML:", tbody.innerHTML);
    } else {
      console.log("[NetplayMenu] No player table to update");
    }

    // Update slot selector to reflect taken slots and select current player's slot
    this.netplayUpdateSlotSelector();

    // Update launch button state
    this.netplayUpdateLaunchButton();
  }

  // Update player list in UI
  netplayUpdatePlayerList(data) {
    // 1. Validate and debug
    if (!this.validateAndDebugPlayerData(data)) {
      return;
    }

    // 2. Convert data format
    let playersArray = this.convertServerPlayersToLocalFormat(data);

    // 3. Identify local player
    const { localPlayerId, localPlayerName } = this.identifyLocalPlayer();

    // 4. Ensure local player is included (server might not send local player data)
    // Don't add if there's already a player with the local name or an "Unknown" player that might be local
    if (
      !playersArray.find(
        (p) =>
          p.name === localPlayerName ||
          (p.name === "Unknown" && localPlayerName),
      )
    ) {
      console.log(
        `[NetplayMenu] Local player ${localPlayerName} not in server data, adding basic entry`,
      );
      // Create basic local player entry
      const localPlayerEntry = {
        id: localPlayerId || "local-player",
        name: localPlayerName || "Player",
        slot: this.netplay?.localSlot || 0,
        ready: false,
      };
      playersArray.push(localPlayerEntry);
      console.log(
        `[NetplayMenu] Added basic local player entry to playersArray:`,
        localPlayerEntry,
      );
    }

    // 5. Process slots (including local player preservation)
    this.processPlayerSlots(playersArray, localPlayerId, localPlayerName);

    // 6. Synchronize local state
    this.synchronizeLocalState(playersArray);

    // 7. Update UI
    this.updatePlayerUI(playersArray);

    // 8. Notify other systems
    this.notifyPlayerTableUpdated();
  }

  // Update just one player's slot in the table (targeted update)
  netplayUpdatePlayerSlot(playerId, newSlot) {
    console.log(
      `[NetplayMenu] Updating slot for player ${playerId} to ${newSlot}`,
    );
    console.log(`[NetplayMenu] joinedPlayers:`, this.netplay.joinedPlayers);

    // Check if this is the local player
    const localPlayerId = this.netplay.engine?.sessionState?.localPlayerId;
    const isLocalPlayer = localPlayerId === playerId;

    // Always update local slot state for slot changes (since only local player can change slots)
    this.netplay.localSlot = newSlot;
    console.log(
      `[NetplayMenu] Updated local player slot to ${newSlot} (player: ${playerId}, local: ${isLocalPlayer})`,
    );

    if (isLocalPlayer) {
      console.log(`[NetplayMenu] Confirmed local player slot update`);
    }

    if (!this.netplay.joinedPlayers) {
      console.warn("[NetplayMenu] No joinedPlayers array to update");
      return;
    }

    // Find the player in the joinedPlayers array
    let playerIndex = this.netplay.joinedPlayers.findIndex(
      (p) => p.id === playerId,
    );

    // If player not found, try to add them from session state
    if (playerIndex === -1) {
      console.log(
        `[NetplayMenu] Player ${playerId} not found in joinedPlayers, attempting to add from session state`,
      );

      // Try to get player data from session state
      const sessionState = this.netplay.engine?.sessionState;
      if (sessionState) {
        const players = sessionState.getPlayers();
        const playerData = players.get(playerId);

        if (playerData) {
          console.log(
            `[NetplayMenu] Found player ${playerId} in session state, adding to joinedPlayers`,
          );
          // Add the player to joinedPlayers
          const newPlayer = {
            id: playerId,
            name: playerData.name || playerData.player_name || "Unknown",
            slot: playerData.slot || playerData.player_slot || 0,
            ready: playerData.ready || false,
            ...playerData, // Include any other properties
          };

          this.netplay.joinedPlayers.push(newPlayer);
          playerIndex = this.netplay.joinedPlayers.length - 1;

          // Update taken slots for new player
          if (!this.netplay.takenSlots) {
            this.netplay.takenSlots = new Set();
          }
          if (newPlayer.slot !== 8) {
            this.netplay.takenSlots.add(newPlayer.slot);
          }

          console.log(
            `[NetplayMenu] Added new player ${playerId} to joinedPlayers at index ${playerIndex}`,
          );
        } else {
          console.warn(
            `[NetplayMenu] Player ${playerId} not found in session state either`,
          );
          return;
        }
      } else {
        console.warn(
          `[NetplayMenu] Player ${playerId} not found in joinedPlayers and no session state available`,
        );
        return;
      }
    }

    // Update the player's slot
    const oldSlot = this.netplay.joinedPlayers[playerIndex].slot;
    this.netplay.joinedPlayers[playerIndex].slot = newSlot;

    console.log(
      `[NetplayMenu] Updated player ${playerId} slot from ${oldSlot} to ${newSlot}`,
    );

    // Update taken slots (spectators don't take player slots)
    if (this.netplay.takenSlots) {
      if (oldSlot !== 8) {
        this.netplay.takenSlots.delete(oldSlot);
      }
      if (newSlot !== 8) {
        this.netplay.takenSlots.add(newSlot);
      }
    }

    // Update ready states if slot changed
    if (oldSlot !== newSlot && this.netplay.playerReadyStates) {
      const maxPlayers = this.netplay.maxPlayers || 4;
      if (oldSlot < maxPlayers) {
        this.netplay.playerReadyStates[oldSlot] = false; // Clear old slot
      }
      if (newSlot < maxPlayers) {
        this.netplay.playerReadyStates[newSlot] =
          this.netplay.joinedPlayers[playerIndex].ready || false;
      }
    }

    // Update the table row for this specific player
    const tbody =
      this.netplay.delaySyncPlayerTable || this.netplay.liveStreamPlayerTable;
    console.log(`[NetplayMenu] Table body:`, tbody);
    console.log(
      `[NetplayMenu] Table children:`,
      tbody ? tbody.children.length : "no tbody",
    );

    if (tbody) {
      // Find the table row that corresponds to this player using data attribute
      const playerId = this.netplay.joinedPlayers[playerIndex].id;
      const playerName = this.netplay.joinedPlayers[playerIndex].name;
      console.log(
        `[NetplayMenu] Looking for table row for player ID: ${playerId}`,
      );

      // Use data attribute for reliable identification
      const targetRow = tbody.querySelector(`tr[data-player-id="${playerId}"]`);

      if (targetRow) {
        console.log(`[NetplayMenu] Found table row for player ${playerId}`);
      } else {
        console.warn(
          `[NetplayMenu] Could not find table row for player ID ${playerId}`,
        );
        console.log(`[NetplayMenu] Available table rows:`);
        for (let i = 0; i < tbody.children.length; i++) {
          const row = tbody.children[i];
          const playerIdAttr = row.getAttribute("data-player-id");
          console.log(`  Row ${i}: data-player-id="${playerIdAttr}"`);
        }
      }

      if (targetRow) {
        const slotCell = targetRow.querySelector("td:first-child"); // Slot column is first
        console.log(`[NetplayMenu] Slot cell:`, slotCell);
        if (slotCell) {
          const newSlotText = this.getSlotDisplayText(newSlot);
          console.log(
            `[NetplayMenu] Changing slot cell from "${slotCell.textContent}" to "${newSlotText}"`,
          );
          slotCell.textContent = newSlotText;
          console.log(
            `[NetplayMenu] Updated table row for player ${playerName} slot cell to ${newSlotText}`,
          );
        } else {
          console.warn(
            `[NetplayMenu] Could not find slot cell for player ${playerName}`,
          );
        }
      } else {
        console.warn(
          `[NetplayMenu] Could not find table row for player ${playerName}`,
        );
        console.log(`[NetplayMenu] Available table rows:`);
        for (let i = 0; i < tbody.children.length; i++) {
          const row = tbody.children[i];
          const cells = row.querySelectorAll("td");
          if (cells.length >= 2) {
            console.log(
              `  Row ${i}: slot="${cells[0].textContent}", name="${cells[1].textContent}"`,
            );
          }
        }
      }
    }

    // Update slot selector to reflect changes
    this.netplayUpdateSlotSelector();

    // Update launch button state
    this.netplayUpdateLaunchButton();

    // Notify systems of the targeted update (avoid full table rebuild)
    this.notifyPlayerTableUpdatedTargeted();
  }

  // Clean up room-specific UI elements
  cleanupRoomUI() {
    console.log("[NetplayMenu] Cleaning up room UI elements");

    // Restore canvas visibility (in case it was hidden for livestream)
    if (
      this.emulator &&
      this.emulator.canvas &&
      this.emulator.canvas.style.display === "none"
    ) {
      console.log("[NetplayMenu] Restoring canvas visibility");
      this.emulator.canvas.style.display = "";
    }

    // Clean up media elements
    if (this.netplay && this.netplay.mediaElements) {
      // Remove video element if it exists
      if (
        this.netplay.mediaElements.video &&
        this.netplay.mediaElements.video.parentElement
      ) {
        console.log("[NetplayMenu] Removing video element from DOM");
        this.netplay.mediaElements.video.parentElement.removeChild(
          this.netplay.mediaElements.video,
        );
      }
      // Clear media elements references
      this.netplay.mediaElements = {};
    }

    // Remove table elements from DOM
    if (this.netplay) {
      // Remove live stream table
      if (
        this.netplay.liveStreamPlayerTable &&
        this.netplay.liveStreamPlayerTable.parentElement
      ) {
        const table = this.netplay.liveStreamPlayerTable.parentElement; // tbody -> table
        if (table.parentElement) {
          table.parentElement.removeChild(table);
        }
      }

      // Remove delay sync table
      if (
        this.netplay.delaySyncPlayerTable &&
        this.netplay.delaySyncPlayerTable.parentElement
      ) {
        const table = this.netplay.delaySyncPlayerTable.parentElement; // tbody -> table
        if (table.parentElement) {
          table.parentElement.removeChild(table);
        }
      }

      // Clear table references
      this.netplay.liveStreamPlayerTable = null;
      this.netplay.delaySyncPlayerTable = null;

      // Clear other room-specific UI elements
      if (this.netplay.slotSelect) {
        // Remove all slot selectors from DOM, not just the referenced one.
        const allSlotSelectors = this.netplayMenu?.querySelectorAll("select");
        allSlotSelectors?.forEach((select) => {
          if (select.parentElement) {
            select.parentElement.removeChild(select);
          }
        });

        // Also remove any "Player Select" labels that might be left behind
        const allLabels = this.netplayMenu?.querySelectorAll("strong");
        allLabels?.forEach((label) => {
          // Only remove labels that contain "Player" text (our slot selector labels)
          if (
            label.innerText &&
            label.innerText.includes("Player") &&
            label.parentElement
          ) {
            label.parentElement.removeChild(label);
          }
        });

        //Clear all slot selector references
        this.netplay.slotSelect = null;
        this.netplay._slotSelectWired = false;
        // Try to remove the slot selector from DOM if it has a parent
        if (this.netplay.slotSelect.parentElement) {
          const slotContainer = this.netplay.slotSelect.parentElement;
          // If the parent is just a wrapper container (like our slot container), remove it
          if (
            slotContainer.parentElement &&
            slotContainer.children.length <= 2
          ) {
            // label + select
            slotContainer.parentElement.removeChild(slotContainer);
          } else {
            // Otherwise just remove the select element itself
            slotContainer.removeChild(this.netplay.slotSelect);
          }
        }
        // Also check if it's directly in the joined tab (live stream case)
        if (
          this.netplay.tabs &&
          this.netplay.tabs[1] &&
          this.netplay.tabs[1].contains(this.netplay.slotSelect)
        ) {
          this.netplay.tabs[1].removeChild(this.netplay.slotSelect);
        }
      }

      // Clear the reference
      this.netplay.slotSelect = null;

      // Also clear any slot selector wiring flags
      this.netplay._slotSelectWired = false;

      // Clear player-related state
      this.netplay.joinedPlayers = [];
      this.netplay.takenSlots = new Set();
      this.netplay.playerReadyStates = null;
      this.netplay.localSlot = null;
      this.netplay.PreferredSlot = null;
    }
  }

  // Add this function to NetplayMenu class

  /**
   * Setup input syncing for live stream room based on host status and player slot
   * Non-host players (P2, P3, P4) will send their inputs to the host via data channel
   */
  netplaySetupLiveStreamInputSync() {
    // Try to get engine from multiple sources (handles case where engine was cleared)
    const engine =
      this.netplay?.engine || this.emulator.netplay?.engine || this.engine;
    if (!engine) {
      console.warn("[NetplayMenu] Engine not available for input sync setup");
      return;
    }

    // Ensure netplay.engine is set for consistency
    if (this.netplay && !this.netplay.engine) {
      this.netplay.engine = engine;
    }

    const isHost = engine.sessionState?.isHostRole() || false;

    // Get current player slot from player data (more reliable than this.netplay.localSlot)
    let playerSlot = 0;
    const localPlayerId = engine.sessionState?.localPlayerId;
    const localPlayerName = this.netplay.name;

    // Try to get slot from player manager first
    if (engine.playerManager) {
      const players = engine.playerManager.getPlayersObject() || {};
      const localPlayer = Object.values(players).find(
        (p) =>
          (localPlayerId && p.id === localPlayerId) ||
          (localPlayerName && p.name === localPlayerName),
      );
      if (
        localPlayer &&
        (localPlayer.slot !== undefined ||
          localPlayer.player_slot !== undefined)
      ) {
        playerSlot =
          localPlayer.slot !== undefined
            ? localPlayer.slot
            : localPlayer.player_slot;
      }
    }

    // Fallback to this.netplay.localSlot or engine.sessionState.localSlot
    if (
      playerSlot === 0 &&
      this.netplay.localSlot !== undefined &&
      this.netplay.localSlot !== null
    ) {
      playerSlot = parseInt(this.netplay.localSlot, 10);
    } else if (
      playerSlot === 0 &&
      engine.sessionState?.localSlot !== undefined
    ) {
      playerSlot = engine.sessionState.localSlot;
    }

    console.log("[NetplayMenu] Setting up input sync:", {
      isHost,
      playerSlot,
      slotName: this.getSlotDisplayText(playerSlot),
    });

    // Set global preferred slot for InputSync (so it maps inputs to correct slot)
    if (typeof window !== "undefined") {
      window.EJS_NETPLAY_PREFERRED_SLOT = playerSlot;
      console.log(
        "[NetplayMenu] Set window.EJS_NETPLAY_PREFERRED_SLOT to:",
        playerSlot,
      );
    }

    // Configure InputSync with the player slot
    if (engine.inputSync.slotManager) {
      if (localPlayerId) {
        const assignedSlot = engine.inputSync.slotManager.assignSlot(
          localPlayerId,
          playerSlot,
        );
        console.log(
          "[NetplayMenu] Assigned slot",
          assignedSlot,
          "to player",
          localPlayerId,
        );
      } else {
        console.warn(
          "[NetplayMenu] No localPlayerId available for slot assignment",
        );
      }
    }

    // Get input mode from settings (unorderedRelay, orderedRelay, or unorderedP2P)
    const inputMode =
      this.emulator.getSettingValue("netplayInputMode") ||
      this.emulator.netplayInputMode ||
      "unorderedRelay";

    console.log("[NetplayMenu] Input mode:", inputMode);

    // Handle dynamic transport switching
    const previousMode = this.engine?.dataChannelManager?.mode;
    const modeChanged = previousMode && previousMode !== inputMode;

    if (modeChanged) {
      console.log(
        `[NetplayMenu] 🚀 Transport mode changed from ${previousMode} to ${inputMode}, switching connections`,
      );

      // Tear down existing P2P connections if switching away from P2P
      if (
        (previousMode === "unorderedP2P" || previousMode === "orderedP2P") &&
        (inputMode === "unorderedRelay" || inputMode === "orderedRelay")
      ) {
        console.log(
          "[NetplayMenu] 🔌 Tearing down P2P connections for relay mode",
        );
        this.netplayTearDownP2PConnections();
      }

      // Tear down existing P2P connections if switching between P2P modes
      if (
        (previousMode === "unorderedP2P" || previousMode === "orderedP2P") &&
        (inputMode === "unorderedP2P" || inputMode === "orderedP2P") &&
        previousMode !== inputMode
      ) {
        console.log(
          "[NetplayMenu] 🔄 Switching between P2P modes, tearing down existing connections",
        );
        this.netplayTearDownP2PConnections();
      }

      // Update DataChannelManager mode
      if (this.engine?.dataChannelManager) {
        this.engine.dataChannelManager.mode = inputMode;

        // Update buffer limit based on new settings
        const unorderedRetries =
          this.emulator.getSettingValue("netplayUnorderedRetries") || 0;
        this.engine.dataChannelManager.maxPendingInputs = Math.max(
          unorderedRetries,
          10,
        ); // Minimum 10
        console.log(
          `[NetplayMenu] 📦 Updated buffer limit to ${this.engine.dataChannelManager.maxPendingInputs}`,
        );
      }
    } else if (this.engine?.dataChannelManager) {
      console.log(
        `[NetplayMenu] Updating DataChannelManager mode from ${this.engine.dataChannelManager.mode} to ${inputMode}`,
      );
      this.engine.dataChannelManager.mode = inputMode;
    }

    // Ensure InputSync is initialized
    if (!engine.inputSync) {
      console.warn("[NetplayMenu] InputSync not initialized yet");
      return;
    }

    // Ensure DataChannelManager is configured with the correct mode
    if (engine.dataChannelManager) {
      engine.dataChannelManager.mode = inputMode;
      console.log("[NetplayMenu] DataChannelManager mode set to:", inputMode);

      // For hosts in P2P mode, set up P2P channels now
      if (isHost) {
        if (engine.netplaySetupP2PChannels) {
          setTimeout(() => {
            engine.netplaySetupP2PChannels().catch((err) => {
              console.error(
                "[NetplayMenu] Failed to setup host P2P channels:",
                err,
              );
            });
          }, 500); // Small delay to ensure everything is ready
        }
      }
    }

    // Set global preferred slot for InputSync (so it maps inputs to correct slot)
    if (typeof window !== "undefined") {
      window.EJS_NETPLAY_PREFERRED_SLOT = playerSlot;
    }

    // Configure InputSync with the player slot
    if (engine.inputSync.slotManager) {
      if (localPlayerId) {
        engine.inputSync.slotManager.assignSlot(localPlayerId, playerSlot);
        console.log(
          "[NetplayMenu] Assigned slot",
          playerSlot,
          "to player",
          localPlayerId,
        );
      }
    }

    // For live stream mode, both host and clients should send inputs via data channel only
    if (engine.dataChannelManager) {
      // Override InputSync's sendInputCallback to send via data channel (no Socket.IO fallback)
      const originalSendInputCallback = engine.inputSync.sendInputCallback;
      engine.inputSync.sendInputCallback = (frame, inputData) => {
        console.log("[NetplayMenu] sendInputCallback called:", {
          frame,
          inputData,
        });

        // Send via data channel only (no Socket.IO fallback for inputs)
        if (engine.dataChannelManager && engine.dataChannelManager.isReady()) {
          console.log(
            "[NetplayMenu] DataChannelManager is ready, sending via data channel",
          );
          if (Array.isArray(inputData)) {
            inputData.forEach((data) => {
              if (data.connected_input && data.connected_input.length === 3) {
                const [playerIndex, inputIndex, value] = data.connected_input;
                const inputPayload = {
                  frame: data.frame || frame || 0,
                  slot: 0, // Default slot for fallback
                  playerIndex: playerIndex,
                  inputIndex: inputIndex,
                  value: value,
                };
                engine.dataChannelManager.sendInput(inputPayload);
              }
            });
          } else if (
            inputData.connected_input &&
            inputData.connected_input.length === 3
          ) {
            const [playerIndex, inputIndex, value] = inputData.connected_input;
            const inputPayload = {
              frame: frame || inputData.frame || 0,
              slot: 0, // Default slot for fallback
              playerIndex: playerIndex,
              inputIndex: inputIndex,
              value: value,
            };
            console.log(
              "[NetplayMenu] Calling dataChannelManager.sendInput with:",
              inputPayload,
            );
            engine.dataChannelManager.sendInput(inputPayload);
          }
        } else {
          console.log(
            "[NetplayMenu] DataChannelManager not ready, inputs cannot be sent",
          );
        }
      };

      if (isHost) {
        console.log(
          "[NetplayMenu] Host input callback configured to send via data channel only",
        );
      } else {
        console.log(
          "[NetplayMenu] Client input callback configured to send via data channel only",
        );
      }
    }

    // Hook into the emulator's simulateInput to forward inputs through netplay
    if (this.emulator?.gameManager?.functions?.simulateInput) {
      const originalSimulateInput =
        this.emulator.gameManager.functions.simulateInput;
      this.emulator.gameManager.functions.simulateInput = (
        playerIndex,
        inputIndex,
        value,
        ...args
      ) => {
        // Forward to netplay if this is a local input (not from network)
        if (this.engine?.inputSync && !args.includes?.("netplay-remote")) {
          // Use the current netplay slot for both local application and netplay forwarding
          const netplaySlot = this.netplay?.localSlot ?? 0;
          console.log(
            `[NetplayMenu] Forwarding local input to netplay: emulator player ${playerIndex} -> netplay slot ${netplaySlot}, input ${inputIndex}, value ${value}`,
          );

          // Call original simulateInput with the correct player index based on slot
          originalSimulateInput.call(
            this.emulator.gameManager.functions,
            netplaySlot,
            inputIndex,
            value,
            ...args,
          );

          // Send to netplay with the slot
          if (netplaySlot !== 8) {
            this.engine.inputSync.sendInput(netplaySlot, inputIndex, value);
          }
        } else {
          // Not a netplay input, call original simulateInput normally
          originalSimulateInput.call(
            this.emulator.gameManager.functions,
            playerIndex,
            inputIndex,
            value,
            ...args,
          );
        }
      };
      console.log(
        "[NetplayMenu] Hooked into emulator simulateInput for netplay forwarding",
      );
    } else {
      console.warn(
        "[NetplayMenu] Could not hook into emulator simulateInput - netplay input forwarding disabled",
      );
    }

    console.log(
      "[NetplayMenu] Input sync setup complete for slot",
      playerSlot,
      "with mode",
      inputMode,
    );

    // For clients in P2P mode, initiate P2P connection after room is fully set up
    console.log(
      `[NetplayMenu] Checking P2P initiation: isHost=${isHost}, inputMode=${inputMode}, hasEngine=${!!this.engine}, hasMethod=${!!this.engine?.netplayInitiateP2PConnection}`,
    );
    if (
      !isHost &&
      (inputMode === "unorderedP2P" || inputMode === "orderedP2P")
    ) {
      console.log(
        "[NetplayMenu] Client will initiate P2P connection after room setup completes",
      );
      // Delay P2P initiation to allow room data to settle
      setTimeout(() => {
        console.log(
          "[NetplayMenu] Executing delayed P2P connection initiation",
        );
        if (this.engine?.netplayInitiateP2PConnection) {
          console.log("[NetplayMenu] Calling netplayInitiateP2PConnection");
          this.engine.netplayInitiateP2PConnection().catch((err) => {
            console.error(
              "[NetplayMenu] Failed to initiate P2P connection:",
              err,
            );
          });
        } else {
          console.error(
            "[NetplayMenu] P2P connection method not available on engine:",
            this.engine,
          );
        }
      }, 3000); // Increased delay to allow room data to settle
    } else {
      console.log(
        `[NetplayMenu] Skipping P2P initiation: isHost=${isHost}, mode=${inputMode}`,
      );
    }
  }

  /**
   * Attach a WebRTC consumer track to a video or audio element
   * @param {MediaStreamTrack} track - The media track from the consumer
   * @param {string} kind - Track kind: 'video' or 'audio'
   */
  netplayAttachConsumerTrack(track, kind) {
    if (!track) {
      console.warn(
        "[NetplayMenu] Cannot attach track - track is null/undefined",
      );
      return;
    }

    // Initialize mediaElements if it doesn't exist
    if (!this.netplay || !this.netplay.mediaElements) {
      if (!this.netplay) {
        this.netplay = {};
      }
      this.netplay.mediaElements = {};
    }

    if (kind === "video") {
      // Create or reuse video element
      let videoElement = this.netplay.mediaElements.video;
      if (!videoElement) {
        videoElement = document.createElement("video");
        videoElement.autoplay = true;
        videoElement.playsInline = true;
        videoElement.style.width = "100%";
        videoElement.style.height = "100%";
        videoElement.style.objectFit = "contain";
        this.netplay.mediaElements.video = videoElement;

        // Insert video element into the joined tab (replace canvas)
        const joinedDiv = this.emulator.netplay?.tabs?.[1];
        if (!isHost) {
          // Hide canvas if it exists
          if (this.emulator?.canvas) {
            this.emulator.canvas.style.display = "none";
          }
          // Append video element to joined tab
          joinedDiv.appendChild(videoElement);
          console.log(
            "[NetplayMenu] Created and inserted video element for livestream",
          );
        } else {
          console.warn(
            "[NetplayMenu] Cannot insert video element - joined tab not found",
          );
        }
      }

      // Attach track to video element
      if (videoElement.srcObject) {
        // If there's already a stream, add track to it
        const stream = videoElement.srcObject;
        stream.addTrack(track);
      } else {
        // Create new stream with track
        const stream = new MediaStream([track]);
        videoElement.srcObject = stream;
      }
      console.log("[NetplayMenu] Attached video track to video element");
    } else if (kind === "audio") {
      // Create or reuse audio element
      let audioElement = this.netplay.mediaElements.audio;
      if (!audioElement) {
        audioElement = document.createElement("audio");
        audioElement.autoplay = true;
        audioElement.volume = this.emulator?.volume ?? 1.0;
        this.netplay.mediaElements.audio = audioElement;

        // Insert audio element into the joined tab
        const joinedDiv = this.emulator.netplay?.tabs?.[1];
        if (joinedDiv) {
          joinedDiv.appendChild(audioElement);
          console.log(
            "[NetplayMenu] Created and inserted audio element for livestream",
          );
        } else {
          console.warn(
            "[NetplayMenu] Cannot insert audio element - joined tab not found",
          );
        }
      }

      // Attach track to audio element
      if (audioElement.srcObject) {
        // If there's already a stream, add track to it
        const stream = audioElement.srcObject;
        stream.addTrack(track);
      } else {
        // Create new stream with track
        const stream = new MediaStream([track]);
        audioElement.srcObject = stream;
      }
      console.log("[NetplayMenu] Attached audio track to audio element");
    } else {
      console.warn(`[NetplayMenu] Unknown track kind: ${kind}`);
    }
  }

  async netplayJoinRoomViaSocket(roomName) {
    console.log("[NetplayMenu] Joining room via socket:", roomName);

    if (!this.engine || !this.engine.roomManager) {
      console.error("[NetplayMenu] Engine or RoomManager not available");
      return;
    }

    // Ensure socket is connected
    if (!this.engine.roomManager.socket?.isConnected()) {
      console.warn("[NetplayMenu] Socket not connected, waiting...");
      // Wait for socket connection
      return new Promise((resolve) => {
        const checkConnection = setInterval(() => {
          if (this.engine?.roomManager?.socket?.isConnected()) {
            clearInterval(checkConnection);
            this.netplayJoinRoomViaSocket(roomName).then(resolve);
          }
        }, 100);

        // Timeout after 5 seconds
        setTimeout(() => {
          clearInterval(checkConnection);
          console.error("[NetplayMenu] Socket connection timeout");
          resolve();
        }, 5000);
      });
    }

    try {
      // Get player name
      const playerName = this.engine.getPlayerName() || "Player";

      // Get password if stored (from previous join attempt)
      const password = this.emulator.netplay?.currentRoom?.password || null;

      // Prepare player info with ROM metadata
      const playerInfo = {
        netplayUsername: playerName,
        name: playerName,
        preferredSlot: this.emulator.netplay.localSlot || 0,
        userId:
          this.emulator.netplay.engine?.sessionState?.localPlayerId || null,
        // ROM metadata for compatibility validation
        romHash: this.emulator.config.romHash || null,
        romName: this.emulator.config.romName || null,
        romFilename: this.emulator.config.romFilename || null,
        core: this.emulator.config.core || null,
        system: this.emulator.config.system || null,
        platform: this.emulator.config.platform || null,
        coreId:
          this.emulator.config.coreId || this.emulator.config.system || null,
        coreVersion: this.emulator.config.coreVersion || null,
        systemType:
          this.emulator.config.systemType ||
          this.emulator.config.system ||
          null,
      };

      // Join room via Socket.IO
      const result = await this.engine.roomManager.joinRoom(
        null, // sessionId (not needed for Socket.IO join)
        roomName,
        4, // maxPlayers
        password,
        playerInfo,
      );

      console.log(
        "[NetplayMenu] Room joined successfully via Socket.IO:",
        result,
      );

      // Store room info
      this.emulator.netplay.currentRoomId = roomName;
      this.emulator.netplay.currentRoom = result;

      // Update UI based on room type
      const netplayMode =
        result.netplay_mode ||
        (result.netplay_mode === 1 ? "delay_sync" : "live_stream");

      if (netplayMode === "delay_sync" || result.netplay_mode === 1) {
        this.netplaySwitchToDelaySyncRoom(roomName, password, result.max || 4);
      } else {
        this.netplaySwitchToLiveStreamRoom(roomName, password);
      }
    } catch (error) {
      console.error("[NetplayMenu] Failed to join room via Socket.IO:", error);
      // Handle compatibility errors
      if (
        error.message?.includes("ROM or emulator core doesn't match") ||
        error.message?.includes("delay_sync_incompatible") ||
        error.details?.error === "delay_sync_incompatible" ||
        error.details?.error === "incompatible_game"
      ) {
        this.parseCompatibilityError(error);
      } else {
        alert(`Failed to join room: ${error.message}`);
      }
    }
  }

  // Setup input forwarding for data producers
  netplaySetupInputForwarding(dataProducer) {
    console.log("[NetplayMenu] Setting up input forwarding:", dataProducer);

    // Setup input syncing (this will configure InputSync and DataChannelManager)
    // we will manage conditions here to stage users based on the room type
    // and their slot + settings when this is called.
    this.netplaySetupLiveStreamInputSync();
  }

  /**
   * Handle netplay setting changes (called from emulator.js).
   * @param {string} changeType - Type of change ("unordered-retries-change", "setting-change", etc.)
   */
  async netplayApplyInputMode(changeType) {
    console.log(`[NetplayMenu] 📝 Applying input mode change: ${changeType}`);

    if (changeType === "unordered-retries-change") {
      // Update buffer limit when unordered retries setting changes
      const unorderedRetries =
        this.emulator.getSettingValue("netplayUnorderedRetries") || 0;
      if (this.engine?.dataChannelManager) {
        this.engine.dataChannelManager.maxPendingInputs = Math.max(
          unorderedRetries,
          10,
        );
        console.log(
          `[NetplayMenu] 📦 Updated buffer limit to ${this.engine.dataChannelManager.maxPendingInputs} based on unordered retries setting`,
        );
      }
    } else if (changeType === "setting-change") {
      // Handle other setting changes, including input mode changes
      console.log(`[NetplayMenu] 🔄 Applying live input mode change`);
      this.netplaySetupLiveStreamInputSync();

      // Additional handling for dynamic P2P mode switching
      const inputMode =
        this.emulator.getSettingValue("netplayInputMode") || "unorderedRelay";
      const isHost =
        typeof window !== "undefined" && window.EJS_netplay?.isHost;

      // Clean up any stale P2P initiation state before attempting new connections
      if (this.engine) {
        console.log(
          `[NetplayMenu] Resetting P2P initiation state for mode switch to ${inputMode}`,
        );
        this.engine._p2pInitiating = false; // Reset the initiation flag
      }

      // If switching TO P2P mode mid-game, ensure P2P connections are established
      if (inputMode === "unorderedP2P" || inputMode === "orderedP2P") {
        console.log(
          `[NetplayMenu] 🌐 Switching to P2P mode ${inputMode}, ensuring connections are established`,
        );

        if (isHost) {
          // Host: Set up P2P channels if not already done
          if (this.engine?.netplaySetupP2PChannels) {
            try {
              await new Promise((resolve) => setTimeout(resolve, 500));
              console.log(
                `[NetplayMenu] Host re-establishing P2P channels for ${inputMode}`,
              );
              await this.engine.netplaySetupP2PChannels();
            } catch (err) {
              console.error(
                "[NetplayMenu] Failed to re-establish host P2P channels:",
                err,
              );
            }
          }
        } else {
          // Client: Initiate P2P connection if not already done
          if (this.engine?.netplayInitiateP2PConnection) {
            try {
              await new Promise((resolve) => setTimeout(resolve, 1000));
              console.log(
                `[NetplayMenu] Client re-initiating P2P connection for ${inputMode}`,
              );
              await this.engine.netplayInitiateP2PConnection();
            } catch (err) {
              console.error(
                "[NetplayMenu] Failed to re-initiate P2P connection:",
                err,
              );
            }
          }
        }
      }
    }
  }

  /**
   * Tear down existing P2P connections when switching transport modes.
   */
  netplayTearDownP2PConnections() {
    if (!this.engine?.dataChannelManager) {
      return;
    }

    console.log("[NetplayMenu] 🔌 Tearing down P2P connections");

    // Clear all P2P channels
    this.engine.dataChannelManager.p2pChannels.clear();

    // Clear any pending inputs since we're switching transports
    this.engine.dataChannelManager.pendingInputs = [];

    console.log("[NetplayMenu] ✅ P2P connections torn down");
  }

  /**
   * Initialize client-side audio mixing system for game + voice audio.
   */
  netplayInitializeAudioMixer() {
    if (this.netplay.audioMixer) {
      return; // Already initialized
    }

    console.log(
      "[NetplayMenu] 🎛️ Initializing audio mixer for game + voice audio",
    );

    this.netplay.audioMixer = {
      audioContext: null,
      gameSource: null,
      micSource: null,
      gameGain: null,
      micGain: null,
      gameTrack: null,
      micTrack: null,
      audioElement: null,
    };

    try {
      // Create AudioContext
      this.netplay.audioMixer.audioContext = new (
        window.AudioContext || window.webkitAudioContext
      )();

      // Create audio element for output (fallback)
      const audioElement = document.createElement("audio");
      audioElement.autoplay = true;
      audioElement.playsInline = true;
      audioElement.muted = false;
      audioElement.style.display = "none";
      audioElement.id = "ejs-netplay-mixed-audio";
      document.body.appendChild(audioElement);
      this.netplay.audioMixer.audioElement = audioElement;

      // Hook into emulator's volume control
      this.netplaySetupStreamVolumeControl();

      console.log("[NetplayMenu] ✅ Audio mixer initialized");
    } catch (error) {
      console.error(
        "[NetplayMenu] ❌ Failed to initialize audio mixer:",
        error,
      );
    }
  }

  /**
   * Add an audio track to the mixer (game or mic audio).
   * @param {MediaStreamTrack} track - Audio track to add
   * @param {string} type - 'game' or 'mic'
   */
  netplayAddAudioTrack(track, type) {
    if (!this.netplay.audioMixer) {
      console.warn("[NetplayMenu] Audio mixer not initialized");
      return;
    }

    const mixer = this.netplay.audioMixer;
    console.log(`[NetplayMenu] 🎚️ Adding ${type} audio track to mixer`);

    try {
      // Create MediaStream from track
      const stream = new MediaStream([track]);

      if (type === "game") {
        // Disconnect existing game audio if any
        if (mixer.gameSource) {
          mixer.gameSource.disconnect();
        }

        // Create new game audio source
        mixer.gameSource = mixer.audioContext.createMediaStreamSource(stream);
        mixer.gameGain = mixer.audioContext.createGain();
        mixer.gameGain.gain.value = 1.0; // Full volume for game audio
        mixer.gameTrack = track;

        // Connect: game source -> game gain -> context destination
        mixer.gameSource.connect(mixer.gameGain);
        mixer.gameGain.connect(mixer.audioContext.destination);

        console.log("[NetplayMenu] 🎮 Game audio connected to mixer");
      } else if (type === "mic") {
        // Disconnect existing mic audio if any
        if (mixer.micSource) {
          mixer.micSource.disconnect();
        }

        // Create new mic audio source
        mixer.micSource = mixer.audioContext.createMediaStreamSource(stream);
        mixer.micGain = mixer.audioContext.createGain();
        mixer.micGain.gain.value = 0.8; // Slightly quieter voice chat
        mixer.micTrack = track;

        // Connect: mic source -> mic gain -> context destination
        mixer.micSource.connect(mixer.micGain);
        mixer.micGain.connect(mixer.audioContext.destination);

        console.log("[NetplayMenu] 🎤 Mic audio connected to mixer");
      }

      // Resume audio context if suspended
      if (mixer.audioContext.state === "suspended") {
        mixer.audioContext.resume().then(() => {
          console.log("[NetplayMenu] 🔊 Audio context resumed");
        });
      }
    } catch (error) {
      console.error(
        `[NetplayMenu] ❌ Failed to add ${type} audio to mixer:`,
        error,
      );
    }
  }

  // ... continue with all other netplay* functions
  // All other netplay functions moved here...
}

window.NetplayMenu = NetplayMenu;

class EJS_GameManager {
    constructor(Module, EJS) {
        this.EJS = EJS;
        this.Module = Module;
        this.FS = this.Module.FS;
        this.functions = {
            restart: this.Module.cwrap("system_restart", "", []),
            //saveStateInfo: this.Module.cwrap("save_state_info", "string", []),
            loadState: this.Module.cwrap("load_state", "number", ["string", "number"]),
            screenshot: this.Module.cwrap("cmd_take_screenshot", "", []),
            simulateInput: this.Module.cwrap("simulate_input", "null", ["number", "number", "number"]),
            toggleMainLoop: this.Module.cwrap("toggleMainLoop", "null", ["number"]),
            getCoreOptions: this.Module.cwrap("get_core_options", "string", []),
            setVariable: this.Module.cwrap("ejs_set_variable", "null", ["string", "string"]),
            setCheat: this.Module.cwrap("set_cheat", "null", ["number", "number", "string"]),
            resetCheat: this.Module.cwrap("reset_cheat", "null", []),
            toggleShader: this.Module.cwrap("shader_enable", "null", ["number"]),
            getDiskCount: this.Module.cwrap("get_disk_count", "number", []),
            getCurrentDisk: this.Module.cwrap("get_current_disk", "number", []),
            setCurrentDisk: this.Module.cwrap("set_current_disk", "null", ["number"]),
            getSaveFilePath: this.Module.cwrap("save_file_path", "string", []),
            saveSaveFiles: this.Module.cwrap("cmd_savefiles", "", []),
            supportsStates: this.Module.cwrap("supports_states", "number", []),
            loadSaveFiles: this.Module.cwrap("refresh_save_files", "null", []),
            toggleFastForward: this.Module.cwrap("toggle_fastforward", "null", ["number"]),
            setFastForwardRatio: this.Module.cwrap("set_ff_ratio", "null", ["number"]),
            toggleRewind: this.Module.cwrap("toggle_rewind", "null", ["number"]),
            setRewindGranularity: this.Module.cwrap("set_rewind_granularity", "null", ["number"]),
            toggleSlowMotion: this.Module.cwrap("toggle_slow_motion", "null", ["number"]),
            setSlowMotionRatio: this.Module.cwrap("set_sm_ratio", "null", ["number"]),
            getFrameNum: this.Module.cwrap("get_current_frame_count", "number", [""]),
            setVSync: this.Module.cwrap("set_vsync", "null", ["number"]),
            setVideoRoation: this.Module.cwrap("set_video_rotation", "null", ["number"]),
            getVideoDimensions: this.Module.cwrap("get_video_dimensions", "number", ["string"]),
            setKeyboardEnabled: this.Module.cwrap("ejs_set_keyboard_enabled", "null", ["number"])
        }

        this.writeFile("/home/web_user/.config/retroarch/retroarch.cfg", this.getRetroArchCfg());

        this.writeConfigFile();
        this.initShaders();
        this.setupPreLoadSettings();

        this.EJS.on("exit", () => {
            if (!this.EJS.failedToStart) {
                this.saveSaveFiles();
                this.functions.restart();
                this.saveSaveFiles();
            }
            this.toggleMainLoop(0);
            this.FS.unmount("/data/saves");
            setTimeout(() => {
                try {
                    this.Module.abort();
                } catch(e) {
                    console.warn(e);
                };
            }, 1000);
        })
    }
    setupPreLoadSettings() {
        this.Module.callbacks.setupCoreSettingFile = (filePath) => {
            if (this.EJS.debug) console.log("Setting up core settings with path:", filePath);
            this.writeFile(filePath, this.EJS.getCoreSettings());
        }
    }
    mountFileSystems() {
        return new Promise(async resolve => {
            this.mkdir("/data");
            this.mkdir("/data/saves");
            this.FS.mount(this.FS.filesystems.IDBFS, { autoPersist: true }, "/data/saves");
            this.FS.syncfs(true, resolve);
        });
    }
    writeConfigFile() {
        if (!this.EJS.defaultCoreOpts.file || !this.EJS.defaultCoreOpts.settings) {
            return;
        }
        let output = "";
        for (const k in this.EJS.defaultCoreOpts.settings) {
            output += k + ' = "' + this.EJS.defaultCoreOpts.settings[k] + '"\n';
        }

        this.writeFile("/home/web_user/retroarch/userdata/config/" + this.EJS.defaultCoreOpts.file, output);
    }
    loadExternalFiles() {
        return new Promise(async (resolve, reject) => {
            if (this.EJS.config.externalFiles && this.EJS.config.externalFiles.constructor.name === "Object") {
                for (const key in this.EJS.config.externalFiles) {
                    await new Promise(done => {
                        this.EJS.downloadFile(this.EJS.config.externalFiles[key], null, true, { responseType: "arraybuffer", method: "GET" }).then(async (res) => {
                            if (res === -1) {
                                if (this.EJS.debug) console.warn("Failed to fetch file from '" + this.EJS.config.externalFiles[key] + "'. Make sure the file exists.");
                                return done();
                            }
                            let path = key;
                            if (key.trim().endsWith("/")) {
                                const invalidCharacters = /[#<$+%>!`&*'|{}/\\?"=@:^\r\n]/ig;
                                let name = this.EJS.config.externalFiles[key].split("/").pop().split("#")[0].split("?")[0].replace(invalidCharacters, "").trim();
                                if (!name) return done();
                                const files = await this.EJS.checkCompression(new Uint8Array(res.data), this.EJS.localization("Decompress Game Assets"));
                                if (files["!!notCompressedData"]) {
                                    path += name;
                                } else {
                                    for (const k in files) {
                                        this.writeFile(path + k, files[k]);
                                    }
                                    return done();
                                }
                            }
                            try {
                                this.writeFile(path, new Uint8Array(res.data));
                            } catch(e) {
                                if (this.EJS.debug) console.warn("Failed to write file to '" + path + "'. Make sure there are no conflicting files.");
                            }
                            done();
                        });
                    })
                }
            }
            resolve();
        });
    }
    writeFile(path, data) {
        const parts = path.split("/");
        let current = "/";
        for (let i = 0; i < parts.length - 1; i++) {
            if (!parts[i].trim()) continue;
            current += parts[i] + "/";
            this.mkdir(current);
        }
        this.FS.writeFile(path, data);
    }
    mkdir(path) {
        try {
            this.FS.mkdir(path);
        } catch(e) {}
    }
    getRetroArchCfg() {
        let cfg = "autosave_interval = 60\n" +
            "screenshot_directory = \"/\"\n" +
            "block_sram_overwrite = false\n" +
            "video_gpu_screenshot = false\n" +
            "audio_latency = 64\n" +
            "video_top_portrait_viewport = true\n" +
            "video_vsync = true\n" +
            "video_smooth = false\n" +
            "fastforward_ratio = 3.0\n" +
            "slowmotion_ratio = 3.0\n" +
            (this.EJS.rewindEnabled ? "rewind_enable = true\n" : "") +
            (this.EJS.rewindEnabled ? "rewind_granularity = 6\n" : "") +
            "savefile_directory = \"/data/saves\"\n";

        if (this.EJS.retroarchOpts && Array.isArray(this.EJS.retroarchOpts)) {
            this.EJS.retroarchOpts.forEach(option => {
                let selected = this.EJS.preGetSetting(option.name);
                console.log(selected);
                if (!selected) {
                    selected = option.default;
                }
                const value = option.isString === false ? selected : '"' + selected + '"';
                cfg += option.name + " = " + value + "\n"
            })
        }
        return cfg;
    }
    writeBootupBatchFile() {
        const data = `
SET BLASTER=A220 I7 D1 H5 T6

@ECHO OFF
mount A / -t floppy
SET PATH=Z:\\;A:\\
mount c /emulator/c
c:
COMMAND.COM
IF EXIST AUTORUN.BAT AUTORUN.BAT
`;
        const filename = "BOOTUP.BAT";
        this.FS.writeFile("/" + filename, data);
        return filename;
    }
    initShaders() {
        if (!this.EJS.config.shaders) return;
        this.mkdir("/shader");
        for (const shaderFileName in this.EJS.config.shaders) {
            const shader = this.EJS.config.shaders[shaderFileName];
            if (typeof shader === "string") {
                this.FS.writeFile(`/shader/${shaderFileName}`, shader);
            }
        }
    }
    clearEJSResetTimer() {
        if (this.EJS.resetTimeout) {
            clearTimeout(this.EJS.resetTimeout);
            delete this.EJS.resetTimeout;
        }
    }
    restart() {
        this.clearEJSResetTimer();
        this.functions.restart();
    }
    getState() {
        return this.Module.EmulatorJSGetState();
    }
    loadState(state) {
        try {
            this.FS.unlink("game.state");
        } catch(e) {}
        this.FS.writeFile("/game.state", state);
        this.clearEJSResetTimer();
        this.functions.loadState("game.state", 0);
        setTimeout(() => {
            try {
                this.FS.unlink("game.state");
            } catch(e) {}
        }, 5000)
    }
    screenshot() {
        try {
            this.FS.unlink("/screenshot.png");
        } catch(e) {}
        this.functions.screenshot();
        return new Promise(async resolve => {
            while (1) {
                try {
                    this.FS.stat("/screenshot.png");
                    return resolve(this.FS.readFile("/screenshot.png"));
                } catch(e) {}
                await new Promise(res => setTimeout(res, 50));
            }
        })
    }
    quickSave(slot) {
        if (!slot) slot = 1;
        let name = slot + "-quick.state";
        try {
            this.FS.unlink(name);
        } catch(e) {}
        try {
            let data = this.getState();
            this.FS.writeFile("/" + name, data);
        } catch(e) {
            return false;
        }
        return true;
    }
    quickLoad(slot) {
        if (!slot) slot = 1;
        (async () => {
            let name = slot + "-quick.state";
            this.clearEJSResetTimer();
            this.functions.loadState(name, 0);
        })();
    }
    simulateInput(player, index, value) {
        const isNetplayGlobal = window.EJS?.isNetplay;
        const isNetplayLocal = !!(this.EJS?.netplay && typeof this.EJS.netplay.simulateInput === 'function');
        const isNetplay = isNetplayGlobal || isNetplayLocal;

        console.log('[GameManager] simulateInput called:', {
            player,
            index,
            value,
            isNetplayGlobal,
            isNetplayLocal,
            isNetplay
        });

        if (isNetplay) {
            console.log('[GameManager] In netplay mode, calling netplay.simulateInput');
            if (this.EJS.netplay && typeof this.EJS.netplay.simulateInput === 'function') {
                console.log('[GameManager] Calling EJS.netplay.simulateInput');
                this.EJS.netplay.simulateInput(player, index, value);
            } else {
                console.warn('[GameManager] Netplay simulateInput not available yet');
                console.log('[GameManager] EJS.netplay exists:', !!this.EJS.netplay);
                console.log('[GameManager] simulateInput function exists:', typeof this.EJS.netplay?.simulateInput === 'function');
            }
            return;
        }
        if ([24, 25, 26, 27, 28, 29].includes(index)) {
            if (index === 24 && value === 1) {
                const slot = this.EJS.settings["save-state-slot"] ? this.EJS.settings["save-state-slot"] : "1";
                if (this.quickSave(slot)) {
                    this.EJS.displayMessage(this.EJS.localization("SAVED STATE TO SLOT") + " " + slot);
                } else {
                    this.EJS.displayMessage(this.EJS.localization("FAILED TO SAVE STATE"));
                }
            }
            if (index === 25 && value === 1) {
                const slot = this.EJS.settings["save-state-slot"] ? this.EJS.settings["save-state-slot"] : "1";
                this.quickLoad(slot);
                this.EJS.displayMessage(this.EJS.localization("LOADED STATE FROM SLOT") + " " + slot);
            }
            if (index === 26 && value === 1) {
                let newSlot;
                try {
                    newSlot = parseFloat(this.EJS.settings["save-state-slot"] ? this.EJS.settings["save-state-slot"] : "1") + 1;
                } catch(e) {
                    newSlot = 1;
                }
                if (newSlot > 9) newSlot = 1;
                this.EJS.displayMessage(this.EJS.localization("SET SAVE STATE SLOT TO") + " " + newSlot);
                this.EJS.changeSettingOption("save-state-slot", newSlot.toString());
            }
            if (index === 27) {
                this.functions.toggleFastForward(this.EJS.isFastForward ? !value : value);
            }
            if (index === 29) {
                this.functions.toggleSlowMotion(this.EJS.isSlowMotion ? !value : value);
            }
            if (index === 28) {
                if (this.EJS.rewindEnabled) {
                    this.functions.toggleRewind(value);
                }
            }
            return;
        }
        this.functions.simulateInput(player, index, value);
    }
    getFileNames() {
        if (this.EJS.getCore() === "picodrive") {
            return ["bin", "gen", "smd", "md", "32x", "cue", "iso", "sms", "68k", "chd"];
        } else {
            return ["toc", "ccd", "exe", "pbp", "chd", "img", "bin", "iso"];
        }
    }
    createCueFile(fileNames) {
        try {
            if (fileNames.length > 1) {
                fileNames = fileNames.filter((item) => {
                    return this.getFileNames().includes(item.split(".").pop().toLowerCase());
                })
                fileNames = fileNames.sort((a, b) => {
                    if (isNaN(a.charAt()) || isNaN(b.charAt())) throw new Error("Incorrect file name format");
                    return (parseInt(a.charAt()) > parseInt(b.charAt())) ? 1 : -1;
                })
            }
        } catch(e) {
            if (fileNames.length > 1) {
                console.warn("Could not auto-create cue file(s).");
                return null;
            }
        }
        for (let i = 0; i < fileNames.length; i++) {
            if (fileNames[i].split(".").pop().toLowerCase() === "ccd") {
                console.warn("Did not auto-create cue file(s). Found a ccd.");
                return null;
            }
        }
        if (fileNames.length === 0) {
            console.warn("Could not auto-create cue file(s).");
            return null;
        }
        let baseFileName = fileNames[0].split("/").pop();
        if (baseFileName.includes(".")) {
            baseFileName = baseFileName.substring(0, baseFileName.length - baseFileName.split(".").pop().length - 1);
        }
        for (let i = 0; i < fileNames.length; i++) {
            const contents = " FILE \"" + fileNames[i] + "\" BINARY\n  TRACK 01 MODE1/2352\n   INDEX 01 00:00:00";
            this.FS.writeFile("/" + baseFileName + "-" + i + ".cue", contents);
        }
        if (fileNames.length > 1) {
            let contents = "";
            for (let i = 0; i < fileNames.length; i++) {
                contents += "/" + baseFileName + "-" + i + ".cue\n";
            }
            this.FS.writeFile("/" + baseFileName + ".m3u", contents);
        }
        return (fileNames.length === 1) ? baseFileName + "-0.cue" : baseFileName + ".m3u";
    }
    loadPpssppAssets() {
        return new Promise(resolve => {
            this.EJS.downloadFile("cores/ppsspp-assets.zip", null, false, { responseType: "arraybuffer", method: "GET" }).then((res) => {
                this.EJS.checkCompression(new Uint8Array(res.data), this.EJS.localization("Decompress Game Data")).then((pspassets) => {
                    if (pspassets === -1) {
                        this.EJS.textElem.innerText = this.localization("Network Error");
                        this.EJS.textElem.style.color = "red";
                        return;
                    }
                    this.mkdir("/PPSSPP");

                    for (const file in pspassets) {
                        const data = pspassets[file];
                        const path = "/PPSSPP/" + file;
                        const paths = path.split("/");
                        let cp = "";
                        for (let i = 0; i < paths.length - 1; i++) {
                            if (paths[i] === "") continue;
                            cp += "/" + paths[i];
                            if (!this.FS.analyzePath(cp).exists) {
                                this.FS.mkdir(cp);
                            }
                        }
                        if (!path.endsWith("/")) {
                            this.FS.writeFile(path, data);
                        }
                    }
                    resolve();
                })
            });
        })
    }
    setVSync(enabled) {
        this.functions.setVSync(enabled);
    }
    toggleMainLoop(playing) {
        this.functions.toggleMainLoop(playing);
    }
    getCoreOptions() {
        return this.functions.getCoreOptions();
    }
    setVariable(option, value) {
        this.functions.setVariable(option, value);
    }
    setCheat(index, enabled, code) {
        this.functions.setCheat(index, enabled, code);
    }
    resetCheat() {
        this.functions.resetCheat();
    }
    toggleShader(active) {
        this.functions.toggleShader(active);
    }
    getDiskCount() {
        return this.functions.getDiskCount();
    }
    getCurrentDisk() {
        return this.functions.getCurrentDisk();
    }
    setCurrentDisk(disk) {
        this.functions.setCurrentDisk(disk);
    }
    getSaveFilePath() {
        return this.functions.getSaveFilePath();
    }
    saveSaveFiles() {
        this.functions.saveSaveFiles();
        this.EJS.callEvent("saveSaveFiles", this.getSaveFile(false));
        //this.FS.syncfs(false, () => {});
    }
    supportsStates() {
        return !!this.functions.supportsStates();
    }
    getSaveFile(save) {
        if (save !== false) {
            this.saveSaveFiles();
        }
        const exists = this.FS.analyzePath(this.getSaveFilePath()).exists;
        return (exists ? this.FS.readFile(this.getSaveFilePath()) : null);
    }
    loadSaveFiles() {
        this.clearEJSResetTimer();
        this.functions.loadSaveFiles();
    }
    setFastForwardRatio(ratio) {
        this.functions.setFastForwardRatio(ratio);
    }
    toggleFastForward(active) {
        this.functions.toggleFastForward(active);
    }
    setSlowMotionRatio(ratio) {
        this.functions.setSlowMotionRatio(ratio);
    }
    toggleSlowMotion(active) {
        this.functions.toggleSlowMotion(active);
    }
    setRewindGranularity(value) {
        this.functions.setRewindGranularity(value);
    }
    getFrameNum() {
        return this.functions.getFrameNum();
    }
    setVideoRotation(rotation) {
        this.functions.setVideoRoation(rotation);
    }
    getVideoDimensions(type) {
        try {
            return this.functions.getVideoDimensions(type);
        } catch(e) {
            console.warn(e);
        }
    }
    setKeyboardEnabled(enabled) {
        this.functions.setKeyboardEnabled(enabled === true ? 1 : 0);
    }
    setAltKeyEnabled(enabled) {
        this.functions.setKeyboardEnabled(enabled === true ? 3 : 2);
    }
}

window.EJS_GameManager = EJS_GameManager;

/**
 * Handles compression and decompression of various archive formats (ZIP, 7Z, RAR)
 * for the EmulatorJS system.
 *
 * This class provides functionality to detect compressed file formats and extract
 * their contents using web workers for better performance.
 */
class EJSCompression {
    /**
     * Creates a new compression handler instance.
     *
     * @param {Object} EJS - The main EmulatorJS instance
     */
    constructor(EJS) {
        this.EJS = EJS;
    }

    /**
     * Detects if the given data represents a compressed archive format.
     *
     * @param {Uint8Array|ArrayBuffer} data - The binary data to analyze
     * @returns {string|null} The detected compression format ('zip', '7z', 'rar') or null if not compressed
     *
     * @description
     * Checks the file signature (magic bytes) at the beginning of the data to identify
     * the compression format. Supports ZIP, 7Z, and RAR formats.
     *
     * @see {@link https://www.garykessler.net/library/file_sigs.html|File Signature Database}
     */
    isCompressed(data) {
            if ((data[0] === 0x50 && data[1] === 0x4B) && ((data[2] === 0x03 && data[3] === 0x04) || (data[2] === 0x05 && data[3] === 0x06) || (data[2] === 0x07 && data[3] === 0x08))) {
                return "zip";
            } else if (data[0] === 0x37 && data[1] === 0x7A && data[2] === 0xBC && data[3] === 0xAF && data[4] === 0x27 && data[5] === 0x1C) {
                return "7z";
            } else if ((data[0] === 0x52 && data[1] === 0x61 && data[2] === 0x72 && data[3] === 0x21 && data[4] === 0x1A && data[5] === 0x07) && ((data[6] === 0x00) || (data[6] === 0x01 && data[7] === 0x00))) {
                return "rar";
            }
            return null;
        }

    /**
     * Decompresses the given data and extracts all files.
     *
     * @param {Uint8Array|ArrayBuffer} data - The compressed data to extract
     * @param {Function} updateMsg - Callback function for progress updates (message, isProgress)
     * @param {Function} fileCbFunc - Callback function called for each extracted file (filename, fileData)
     * @returns {Promise<Object>} Promise that resolves to an object mapping filenames to file data
     *
     * @description
     * Automatically detects the compression format and delegates to the appropriate
     * decompression method. If the data is not compressed, returns it as-is.
     */
    decompress(data, updateMsg, fileCbFunc) {
        const compressed = this.isCompressed(data.slice(0, 10));
        if (compressed === null) {
            if (typeof fileCbFunc === "function") {
                fileCbFunc("!!notCompressedData", data);
            }
            return new Promise(resolve => resolve({ "!!notCompressedData": data }));
        }
        return this.decompressFile(compressed, data, updateMsg, fileCbFunc);
    }

    /**
     * Retrieves the appropriate worker script for the specified compression method.
     *
     * @param {string} method - The compression method ('7z', 'zip', or 'rar')
     * @returns {Promise<Blob>} Promise that resolves to a Blob containing the worker script
     *
     * @description
     * Downloads the necessary worker script and WASM files for the specified compression
     * method. For RAR files, also downloads the libunrar.wasm file and creates a custom
     * worker script with the WASM binary embedded.
     *
     * @throws {Error} When network errors occur during file downloads
     */
    getWorkerFile(method) {
        return new Promise(async (resolve, reject) => {
            let path, obj;
            if (method === "7z") {
                path = "compression/extract7z.js";
                obj = "sevenZip";
            } else if (method === "zip") {
                path = "compression/extractzip.js";
                obj = "zip";
            } else if (method === "rar") {
                path = "compression/libunrar.js";
                obj = "rar";
            }
            const res = await this.EJS.downloadFile(path, null, false, { responseType: "text", method: "GET" });
            if (res === -1) {
                this.EJS.startGameError(this.EJS.localization("Network Error"));
                return;
            }
            if (method === "rar") {
                const res2 = await this.EJS.downloadFile("compression/libunrar.wasm", null, false, { responseType: "arraybuffer", method: "GET" });
                if (res2 === -1) {
                    this.EJS.startGameError(this.EJS.localization("Network Error"));
                    return;
                }
                const path = URL.createObjectURL(new Blob([res2.data], { type: "application/wasm" }));
                let script = `
                    let dataToPass = [];
                    Module = {
                        monitorRunDependencies: function(left) {
                            if (left == 0) {
                                setTimeout(function() {
                                    unrar(dataToPass, null);
                                }, 100);
                            }
                        },
                        onRuntimeInitialized: function() {},
                        locateFile: function(file) {
                            console.log("locateFile");
                            return "` + path + `";
                        }
                    };
                    ` + res.data + `
                    let unrar = function(data, password) {
                        let cb = function(fileName, fileSize, progress) {
                            postMessage({ "t": 4, "current": progress, "total": fileSize, "name": fileName });
                        };
                        let rarContent = readRARContent(data.map(function(d) {
                            return {
                                name: d.name,
                                content: new Uint8Array(d.content)
                            }
                        }), password, cb)
                        let rec = function(entry) {
                            if (!entry) return;
                            if (entry.type === "file") {
                                postMessage({ "t": 2, "file": entry.fullFileName, "size": entry.fileSize, "data": entry.fileContent });
                            } else if (entry.type === "dir") {
                                Object.keys(entry.ls).forEach(function(k) {
                                    rec(entry.ls[k]);
                                });
                            } else {
                                throw "Unknown type";
                            }
                        }
                        rec(rarContent);
                        postMessage({ "t": 1 });
                        return rarContent;
                    };
                    onmessage = function(data) {
                        dataToPass.push({ name: "test.rar", content: data.data });
                    };
                `;
                const blob = new Blob([script], {
                    type: "application/javascript"
                })
                resolve(blob);
            } else {
                const blob = new Blob([res.data], {
                    type: "application/javascript"
                })
                resolve(blob);
            }
        })
    }

    /**
     * Decompresses a file using the specified compression method.
     *
     * @param {string} method - The compression method ('7z', 'zip', or 'rar')
     * @param {Uint8Array|ArrayBuffer} data - The compressed data to extract
     * @param {Function} updateMsg - Callback function for progress updates (message, isProgress)
     * @param {Function} fileCbFunc - Callback function called for each extracted file (filename, fileData)
     * @returns {Promise<Object>} Promise that resolves to an object mapping filenames to file data
     *
     * @description
     * Creates a web worker to handle the decompression process asynchronously.
     * The worker communicates progress updates and extracted files back to the main thread.
     *
     * @example
     * // Message types from worker:
     * // t: 4 - Progress update (current, total, name)
     * // t: 2 - File extracted (file, size, data)
     * // t: 1 - Extraction complete
     */
    decompressFile(method, data, updateMsg, fileCbFunc) {
        return new Promise(async callback => {
            const file = await this.getWorkerFile(method);
            const worker = new Worker(URL.createObjectURL(file));
            const files = {};
            worker.onmessage = (data) => {
                if (!data.data) return;
                //data.data.t/ 4=progress, 2 is file, 1 is zip done
                if (data.data.t === 4) {
                    const pg = data.data;
                    const num = Math.floor(pg.current / pg.total * 100);
                    if (isNaN(num)) return;
                    const progress = " " + num.toString() + "%";
                    updateMsg(progress, true);
                }
                if (data.data.t === 2) {
                    if (typeof fileCbFunc === "function") {
                        fileCbFunc(data.data.file, data.data.data);
                        files[data.data.file] = true;
                    } else {
                        files[data.data.file] = data.data.data;
                    }
                }
                if (data.data.t === 1) {
                    callback(files);
                }
            }
            worker.postMessage(data);
        });
    }
}

window.EJS_COMPRESSION = EJSCompression;

class EmulatorJS {
  getCores() {
    let rv = {
      atari5200: ["a5200"],
      vb: ["beetle_vb"],
      nds: ["melonds", "desmume", "desmume2015"],
      arcade: ["fbneo", "fbalpha2012_cps1", "fbalpha2012_cps2", "same_cdi"],
      nes: ["fceumm", "nestopia"],
      gb: ["gambatte"],
      coleco: ["gearcoleco"],
      segaMS: [
        "smsplus",
        "genesis_plus_gx",
        "genesis_plus_gx_wide",
        "picodrive",
      ],
      segaMD: ["genesis_plus_gx", "genesis_plus_gx_wide", "picodrive"],
      segaGG: ["genesis_plus_gx", "genesis_plus_gx_wide"],
      segaCD: ["genesis_plus_gx", "genesis_plus_gx_wide", "picodrive"],
      sega32x: ["picodrive"],
      sega: ["genesis_plus_gx", "genesis_plus_gx_wide", "picodrive"],
      lynx: ["handy"],
      mame: ["mame2003_plus", "mame2003"],
      ngp: ["mednafen_ngp"],
      pce: ["mednafen_pce"],
      pcfx: ["mednafen_pcfx"],
      psx: ["pcsx_rearmed", "mednafen_psx_hw"],
      ws: ["mednafen_wswan"],
      gba: ["mgba"],
      n64: ["mupen64plus_next", "parallel_n64"],
      "3do": ["opera"],
      psp: ["ppsspp"],
      atari7800: ["prosystem"],
      snes: ["snes9x", "bsnes"],
      atari2600: ["stella2014"],
      jaguar: ["virtualjaguar"],
      segaSaturn: ["yabause"],
      amiga: ["puae"],
      c64: ["vice_x64sc"],
      c128: ["vice_x128"],
      pet: ["vice_xpet"],
      plus4: ["vice_xplus4"],
      vic20: ["vice_xvic"],
      dos: ["dosbox_pure"],
      intv: ["freeintv"],
    };
    if (this.isSafari && this.isMobile) {
      rv.n64 = rv.n64.reverse();
    }
    return rv;
  }
  requiresThreads(core) {
    const requiresThreads = ["ppsspp", "dosbox_pure"];
    return requiresThreads.includes(core);
  }
  requiresWebGL2(core) {
    const requiresWebGL2 = ["ppsspp"];
    return requiresWebGL2.includes(core);
  }
  getCore(generic) {
    const cores = this.getCores();
    const core = this.config.system;
    if (generic) {
      for (const k in cores) {
        if (cores[k].includes(core)) {
          return k;
        }
      }
      return core;
    }
    const gen = this.getCore(true);
    if (
      cores[gen] &&
      cores[gen].includes(this.preGetSetting("retroarch_core"))
    ) {
      return this.preGetSetting("retroarch_core");
    }
    if (cores[core]) {
      return cores[core][0];
    }
    return core;
  }
  createElement(type) {
    return document.createElement(type);
  }
  addEventListener(element, listener, callback) {
    const listeners = listener.split(" ");
    let rv = [];
    for (let i = 0; i < listeners.length; i++) {
      element.addEventListener(listeners[i], callback);
      const data = { cb: callback, elem: element, listener: listeners[i] };
      rv.push(data);
    }
    return rv;
  }
  removeEventListener(data) {
    for (let i = 0; i < data.length; i++) {
      data[i].elem.removeEventListener(data[i].listener, data[i].cb);
    }
  }
  downloadFile(path, progressCB, notWithPath, opts) {
    return new Promise(async (cb) => {
      const data = this.toData(path); //check other data types
      if (data) {
        data.then((game) => {
          if (opts.method === "HEAD") {
            cb({ headers: {} });
          } else {
            cb({ headers: {}, data: game });
          }
        });
        return;
      }
      const basePath = notWithPath ? "" : this.config.dataPath;
      path = basePath + path;
      if (
        !notWithPath &&
        this.config.filePaths &&
        typeof this.config.filePaths[path.split("/").pop()] === "string"
      ) {
        path = this.config.filePaths[path.split("/").pop()];
      }
      let url;
      try {
        url = new URL(path);
      } catch (e) {}
      if (url && !["http:", "https:"].includes(url.protocol)) {
        //Most commonly blob: urls. Not sure what else it could be
        if (opts.method === "HEAD") {
          cb({ headers: {} });
          return;
        }
        try {
          let res = await fetch(path);
          if (
            (opts.type && opts.type.toLowerCase() === "arraybuffer") ||
            !opts.type
          ) {
            res = await res.arrayBuffer();
          } else {
            res = await res.text();
            try {
              res = JSON.parse(res);
            } catch (e) {}
          }
          if (path.startsWith("blob:")) URL.revokeObjectURL(path);
          cb({ data: res, headers: {} });
        } catch (e) {
          cb(-1);
        }
        return;
      }
      const xhr = new XMLHttpRequest();
      if (progressCB instanceof Function) {
        xhr.addEventListener("progress", (e) => {
          const progress = e.total
            ? " " + Math.floor((e.loaded / e.total) * 100).toString() + "%"
            : " " + (e.loaded / 1048576).toFixed(2) + "MB";
          progressCB(progress);
        });
      }
      xhr.onload = function () {
        if (xhr.readyState === xhr.DONE) {
          let data = xhr.response;
          if (
            xhr.status.toString().startsWith("4") ||
            xhr.status.toString().startsWith("5")
          ) {
            cb(-1);
            return;
          }
          try {
            data = JSON.parse(data);
          } catch (e) {}
          cb({
            data: data,
            headers: {
              "content-length": xhr.getResponseHeader("content-length"),
            },
          });
        }
      };
      if (opts.responseType) xhr.responseType = opts.responseType;
      xhr.onerror = () => cb(-1);
      xhr.open(opts.method, path, true);
      xhr.send();
    });
  }
  toData(data, rv) {
    if (
      !(data instanceof ArrayBuffer) &&
      !(data instanceof Uint8Array) &&
      !(data instanceof Blob)
    )
      return null;
    if (rv) return true;
    return new Promise(async (resolve) => {
      if (data instanceof ArrayBuffer) {
        resolve(new Uint8Array(data));
      } else if (data instanceof Uint8Array) {
        resolve(data);
      } else if (data instanceof Blob) {
        resolve(new Uint8Array(await data.arrayBuffer()));
      }
      resolve();
    });
  }
  checkForUpdates() {
    if (this.ejs_version.endsWith("-sfu")) {
      console.warn("Using EmulatorJS-SFU. Not checking for updates.");
      return;
    }
    fetch("https://cdn.emulatorjs.org/stable/data/version.json").then(
      (response) => {
        if (response.ok) {
          response.text().then((body) => {
            let version = JSON.parse(body);
            if (
              this.versionAsInt(this.ejs_version) <
              this.versionAsInt(version.version)
            ) {
              console.log(
                `Using EmulatorJS version ${this.ejs_version} but the newest version is ${version.current_version}\nopen https://github.com/EmulatorJS/EmulatorJS to update`,
              );
            }
          });
        }
      },
    );
  }
  versionAsInt(ver) {
    if (typeof ver !== "string") {
      return 0;
    }
    if (ver.endsWith("-beta")) {
      return 99999999;
    }
    // Ignore build suffixes like "-sfu" (e.g. "4.3.0-sfu" -> "4.3.0").
    ver = ver.split("-")[0];
    let rv = ver.split(".");
    if (rv[rv.length - 1].length === 1) {
      rv[rv.length - 1] = "0" + rv[rv.length - 1];
    }
    return parseInt(rv.join(""), 10);
  }
  constructor(element, config) {
    this.ejs_version = "4.3.0-sfu";
    this.extensions = [];
    this.allSettings = {};
    this.initControlVars();
    this.debug = window.EJS_DEBUG_XX === true;
    if (
      this.debug ||
      (window.location &&
        ["localhost", "127.0.0.1"].includes(location.hostname))
    ) {
      this.checkForUpdates();
    }
    this.config = config;
    this.config.buttonOpts = this.buildButtonOptions(this.config.buttonOpts);
    this.config.settingsLanguage = window.EJS_settingsLanguage || false;
    switch (this.config.browserMode) {
      case 1: // Force mobile
      case "1":
      case "mobile":
        if (this.debug) {
          console.log("Force mobile mode is enabled");
        }
        this.config.browserMode = 1;
        break;
      case 2: // Force desktop
      case "2":
      case "desktop":
        if (this.debug) {
          console.log("Force desktop mode is enabled");
        }
        this.config.browserMode = 2;
        break;
      default: // Auto detect
        config.browserMode = undefined;
    }
    this.currentPopup = null;
    this.isFastForward = false;
    this.isSlowMotion = false;
    this.failedToStart = false;
    this.rewindEnabled = this.preGetSetting("rewindEnabled") === "enabled";
    this.touch = false;
    this.cheats = [];
    this.started = false;
    this.volume =
      typeof this.config.volume === "number" ? this.config.volume : 0.5;
    if (this.config.defaultControllers)
      this.defaultControllers = this.config.defaultControllers;
    this.muted = false;
    this.paused = true;
    this.missingLang = [];
    this.setElements(element);
    this.setColor(this.config.color || "");
    this.config.alignStartButton =
      typeof this.config.alignStartButton === "string"
        ? this.config.alignStartButton
        : "bottom";
    this.config.backgroundColor =
      typeof this.config.backgroundColor === "string"
        ? this.config.backgroundColor
        : "rgb(51, 51, 51)";
    if (this.config.adUrl) {
      this.config.adSize = Array.isArray(this.config.adSize)
        ? this.config.adSize
        : ["300px", "250px"];
      this.setupAds(
        this.config.adUrl,
        this.config.adSize[0],
        this.config.adSize[1],
      );
    }
    this.isMobile = (() => {
      // browserMode can be either a 1 (force mobile), 2 (force desktop) or undefined (auto detect)
      switch (this.config.browserMode) {
        case 1:
          return true;
        case 2:
          return false;
      }

      let check = false;
      (function (a) {
        if (
          /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(
            a,
          ) ||
          /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
            a.substr(0, 4),
          )
        )
          check = true;
      })(navigator.userAgent || navigator.vendor || window.opera);
      return check;
    })();
    this.hasTouchScreen = (function () {
      if (window.PointerEvent && "maxTouchPoints" in navigator) {
        if (navigator.maxTouchPoints > 0) {
          return true;
        }
      } else {
        if (
          window.matchMedia &&
          window.matchMedia("(any-pointer:coarse)").matches
        ) {
          return true;
        } else if (window.TouchEvent || "ontouchstart" in window) {
          return true;
        }
      }
      return false;
    })();
    this.canvas = this.createElement("canvas");
    this.canvas.classList.add("ejs_canvas");
    this.videoRotation = [0, 1, 2, 3].includes(this.config.videoRotation)
      ? this.config.videoRotation
      : this.preGetSetting("videoRotation") || 0;
    this.videoRotationChanged = false;
    this.capture = this.capture || {};
    this.capture.photo = this.capture.photo || {};
    this.capture.photo.source = ["canvas", "retroarch"].includes(
      this.capture.photo.source,
    )
      ? this.capture.photo.source
      : "canvas";
    this.capture.photo.format =
      typeof this.capture.photo.format === "string"
        ? this.capture.photo.format
        : "png";
    this.capture.photo.upscale =
      typeof this.capture.photo.upscale === "number"
        ? this.capture.photo.upscale
        : 1;
    this.capture.video = this.capture.video || {};
    this.capture.video.format =
      typeof this.capture.video.format === "string"
        ? this.capture.video.format
        : "detect";
    this.capture.video.upscale =
      typeof this.capture.video.upscale === "number"
        ? this.capture.video.upscale
        : 1;
    this.capture.video.fps =
      typeof this.capture.video.fps === "number" ? this.capture.video.fps : 30;
    this.capture.video.videoBitrate =
      typeof this.capture.video.videoBitrate === "number"
        ? this.capture.video.videoBitrate
        : 2.5 * 1024 * 1024;
    this.capture.video.audioBitrate =
      typeof this.capture.video.audioBitrate === "number"
        ? this.capture.video.audioBitrate
        : 192 * 1024;

    // Netplay dependencies below here
    // Netplay enablement
    this.netplayEnabled = true;
    this.netplayMenu = new NetplayMenu(this, null); // Create menu first with null engine
    this.netplayEngine = new NetplayEngine(this, this.netplayMenu, {
      gameId: this.config.gameId,
    });
    this.netplayMenu.engine = this.netplayEngine; // Set engine reference after creation
    this.netplayCanvas = null;

    // Add getCurrentFrame method for FrameCounter compatibility
    this.getCurrentFrame = () => {
      return this.netplay?.currentFrame || 0;
    };

    // Add setCurrentFrame method for FrameCounter compatibility
    this.setCurrentFrame = (frame) => {
      if (this.netplay) {
        this.netplay.currentFrame = frame;
      }
    };
    this.netplayShowTurnWarning = false;
    this.netplayWarningShown = false;
    // Ensure the netplay button is visible by default (workaround for styling issues)
    try {
      if (netplay && netplay.style) netplay.style.display = "";
    } catch (e) {}
    this.bindListeners();

    const storedSimulcast = this.preGetSetting("netplaySimulcast");
    const envSimulcast =
      typeof window.EJS_NETPLAY_SIMULCAST === "boolean"
        ? window.EJS_NETPLAY_SIMULCAST
        : false;
    const configSimulcast =
      typeof this.config.netplaySimulcast === "boolean"
        ? this.config.netplaySimulcast
        : envSimulcast;
    this.netplaySimulcastEnabled =
      typeof storedSimulcast === "string"
        ? storedSimulcast === "enabled"
        : !!configSimulcast;
    window.EJS_NETPLAY_SIMULCAST = this.netplaySimulcastEnabled;

    // Update the button click handler
    // VP9 SVC mode (used when VP9 is selected/negotiated): L1T1 | L1T3 | L2T3
    const normalizeVP9SVCMode = (v) => {
      const s = typeof v === "string" ? v.trim() : "";
      const sl = s.toLowerCase();
      if (sl === "l1t1") return "L1T1";
      if (sl === "l1t3") return "L1T3";
      if (sl === "l2t3") return "L2T3";
      return "L1T1";
    };
    const storedVP9SVC = this.preGetSetting("netplayVP9SVC");
    const envVP9SVC =
      typeof window.EJS_NETPLAY_VP9_SVC_MODE === "string"
        ? window.EJS_NETPLAY_VP9_SVC_MODE
        : null;
    const configVP9SVC =
      typeof this.config.netplayVP9SVC === "string"
        ? this.config.netplayVP9SVC
        : envVP9SVC;
    this.netplayVP9SVCMode = normalizeVP9SVCMode(
      typeof storedVP9SVC === "string" ? storedVP9SVC : configVP9SVC,
    );
    window.EJS_NETPLAY_VP9_SVC_MODE = this.netplayVP9SVCMode;

    // Host Codec (SFU video): auto | vp9 | h264 | vp8
    const normalizeHostCodec = (v) => {
      const s = typeof v === "string" ? v.trim().toLowerCase() : "";
      if (s === "vp9" || s === "h264" || s === "vp8" || s === "auto") return s;
      return "auto";
    };
    const storedHostCodec = this.preGetSetting("netplayHostCodec");
    const envHostCodec =
      typeof window.EJS_NETPLAY_HOST_CODEC === "string"
        ? window.EJS_NETPLAY_HOST_CODEC
        : null;
    const configHostCodec =
      typeof this.config.netplayHostCodec === "string"
        ? this.config.netplayHostCodec
        : envHostCodec;
    this.netplayHostCodec = normalizeHostCodec(
      typeof storedHostCodec === "string" ? storedHostCodec : configHostCodec,
    );
    window.EJS_NETPLAY_HOST_CODEC = this.netplayHostCodec;

    // Client Simulcast Quality (replaces legacy Client Max Resolution).
    // Values are: high | low.
    const normalizeSimulcastQuality = (v) => {
      const s = typeof v === "string" ? v.trim().toLowerCase() : "";
      if (s === "high" || s === "low") return s;
      if (s === "medium") return "low";
      // Legacy values
      if (s === "720p") return "high";
      if (s === "360p") return "low";
      if (s === "180p") return "low";
      return "high";
    };
    const simulcastQualityToLegacyRes = (q) => {
      const s = normalizeSimulcastQuality(q);
      return s === "low" ? "360p" : "720p";
    };

    const storedSimulcastQuality = this.preGetSetting(
      "netplayClientSimulcastQuality",
    );
    const storedClientMaxRes = this.preGetSetting("netplayClientMaxResolution");

    const envSimulcastQuality =
      typeof window.EJS_NETPLAY_CLIENT_SIMULCAST_QUALITY === "string"
        ? window.EJS_NETPLAY_CLIENT_SIMULCAST_QUALITY
        : typeof window.EJS_NETPLAY_CLIENT_PREFERRED_QUALITY === "string"
          ? window.EJS_NETPLAY_CLIENT_PREFERRED_QUALITY
          : null;
    const envClientMaxRes =
      typeof window.EJS_NETPLAY_CLIENT_MAX_RESOLUTION === "string"
        ? window.EJS_NETPLAY_CLIENT_MAX_RESOLUTION
        : null;

    const configSimulcastQuality =
      typeof this.config.netplayClientSimulcastQuality === "string"
        ? this.config.netplayClientSimulcastQuality
        : envSimulcastQuality;
    const configClientMaxRes =
      typeof this.config.netplayClientMaxResolution === "string"
        ? this.config.netplayClientMaxResolution
        : envClientMaxRes;

    const simulcastQualityRaw =
      (typeof storedSimulcastQuality === "string" && storedSimulcastQuality) ||
      (typeof storedClientMaxRes === "string" && storedClientMaxRes) ||
      (typeof configSimulcastQuality === "string" && configSimulcastQuality) ||
      (typeof configClientMaxRes === "string" && configClientMaxRes) ||
      "high";

    this.netplayClientSimulcastQuality =
      normalizeSimulcastQuality(simulcastQualityRaw);
    window.EJS_NETPLAY_CLIENT_SIMULCAST_QUALITY =
      this.netplayClientSimulcastQuality;
    // Keep older global populated for compatibility with older integrations.
    window.EJS_NETPLAY_CLIENT_PREFERRED_QUALITY =
      this.netplayClientSimulcastQuality;
    // Keep legacy global populated for compatibility with older integrations.
    window.EJS_NETPLAY_CLIENT_MAX_RESOLUTION = simulcastQualityToLegacyRes(
      this.netplayClientSimulcastQuality,
    );

    const storedRetryTimer = this.preGetSetting("netplayRetryConnectionTimer");
    const envRetryTimerRaw =
      typeof window.EJS_NETPLAY_RETRY_CONNECTION_TIMER === "number" ||
      typeof window.EJS_NETPLAY_RETRY_CONNECTION_TIMER === "string"
        ? window.EJS_NETPLAY_RETRY_CONNECTION_TIMER
        : null;
    const configRetryTimerRaw =
      typeof this.config.netplayRetryConnectionTimer === "number" ||
      typeof this.config.netplayRetryConnectionTimer === "string"
        ? this.config.netplayRetryConnectionTimer
        : envRetryTimerRaw;
    let retrySeconds = parseInt(
      typeof storedRetryTimer === "string"
        ? storedRetryTimer
        : configRetryTimerRaw,
      10,
    );
    if (isNaN(retrySeconds)) retrySeconds = 3;
    if (retrySeconds < 0) retrySeconds = 0;
    if (retrySeconds > 5) retrySeconds = 5;
    this.netplayRetryConnectionTimerSeconds = retrySeconds;
    window.EJS_NETPLAY_RETRY_CONNECTION_TIMER = retrySeconds;

    const storedUnorderedRetries = this.preGetSetting(
      "netplayUnorderedRetries",
    );
    const envUnorderedRetriesRaw =
      typeof window.EJS_NETPLAY_UNORDERED_RETRIES === "number" ||
      typeof window.EJS_NETPLAY_UNORDERED_RETRIES === "string"
        ? window.EJS_NETPLAY_UNORDERED_RETRIES
        : null;
    const configUnorderedRetriesRaw =
      typeof this.config.netplayUnorderedRetries === "number" ||
      typeof this.config.netplayUnorderedRetries === "string"
        ? this.config.netplayUnorderedRetries
        : envUnorderedRetriesRaw;
    let unorderedRetries = parseInt(
      typeof storedUnorderedRetries === "string"
        ? storedUnorderedRetries
        : configUnorderedRetriesRaw,
      10,
    );
    if (isNaN(unorderedRetries)) unorderedRetries = 0;
    if (unorderedRetries < 0) unorderedRetries = 0;
    if (unorderedRetries > 2) unorderedRetries = 2;
    this.netplayUnorderedRetries = unorderedRetries;
    window.EJS_NETPLAY_UNORDERED_RETRIES = unorderedRetries;

    const storedInputMode = this.preGetSetting("netplayInputMode");
    const envInputMode =
      typeof window.EJS_NETPLAY_INPUT_MODE === "string"
        ? window.EJS_NETPLAY_INPUT_MODE
        : null;
    const configInputMode =
      typeof this.config.netplayInputMode === "string"
        ? this.config.netplayInputMode
        : envInputMode;
    const normalizeInputMode = (m) => {
      const mode = typeof m === "string" ? m : "";
      if (
        mode === "orderedRelay" ||
        mode === "unorderedRelay" ||
        mode === "unorderedP2P"
      )
        return mode;
      return "unorderedRelay";
    };
    this.netplayInputMode = normalizeInputMode(
      typeof storedInputMode === "string" ? storedInputMode : configInputMode,
    );
    window.EJS_NETPLAY_INPUT_MODE = this.netplayInputMode;

    // Preferred local player slot (0-3) for netplay.
    const normalizePreferredSlot = (v) => {
      try {
        if (typeof v === "number" && isFinite(v)) {
          const n = Math.floor(v);
          if (n >= 0 && n <= 3) return n;
          if (n >= 1 && n <= 4) return n - 1;
        }
        const s = typeof v === "string" ? v.trim().toLowerCase() : "";
        if (!s) return 0;
        if (s === "p1") return 0;
        if (s === "p2") return 1;
        if (s === "p3") return 2;
        if (s === "p4") return 3;
        const n = parseInt(s, 10);
        if (!isNaN(n)) {
          if (n >= 0 && n <= 3) return n;
          if (n >= 1 && n <= 4) return n - 1;
        }
      } catch (e) {
        // ignore
      }
      return 0;
    };
    const storedPreferredSlot = this.preGetSetting("netplayPreferredSlot");
    const envPreferredSlot =
      typeof window.EJS_NETPLAY_PREFERRED_SLOT === "number" ||
      typeof window.EJS_NETPLAY_PREFERRED_SLOT === "string"
        ? window.EJS_NETPLAY_PREFERRED_SLOT
        : null;
    const configPreferredSlot =
      typeof this.config.netplayPreferredSlot === "number" ||
      typeof this.config.netplayPreferredSlot === "string"
        ? this.config.netplayPreferredSlot
        : envPreferredSlot;
    this.netplayPreferredSlot = normalizePreferredSlot(
      typeof storedPreferredSlot === "string" ||
        typeof storedPreferredSlot === "number"
        ? storedPreferredSlot
        : configPreferredSlot,
    );
    window.EJS_NETPLAY_PREFERRED_SLOT = this.netplayPreferredSlot;

    if (this.netplayEnabled) {
      const iceServers =
        this.config.netplayICEServers || window.EJS_netplayICEServers || [];
      const hasTurnServer = iceServers.some(
        (server) =>
          server &&
          typeof server.urls === "string" &&
          server.urls.startsWith("turn:"),
      );
      if (!hasTurnServer) {
        this.netplayShowTurnWarning = true;
      }
      if (this.netplayShowTurnWarning && this.debug) {
        console.warn(
          "WARNING: No TURN addresses are configured! Many clients may fail to connect!",
        );
      }
    }
    // End of gathered dependencies. Collect dependencies and sort above here.

    if ((this.isMobile || this.hasTouchScreen) && this.virtualGamepad) {
      this.virtualGamepad.classList.add("ejs-vgamepad-active");
      this.canvas.classList.add("ejs-canvas-no-pointer");
    }

    this.fullscreen = false;
    this.enableMouseLock = false;
    this.supportsWebgl2 =
      !!document.createElement("canvas").getContext("webgl2") &&
      this.config.forceLegacyCores !== true;
    this.webgl2Enabled = (() => {
      let setting = this.preGetSetting("webgl2Enabled");
      if (setting === "disabled" || !this.supportsWebgl2) {
        return false;
      } else if (setting === "enabled") {
        return true;
      }
      // Default-on when supported.
      return true;
    })();
    this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (this.config.disableDatabases) {
      this.storage = {
        rom: new window.EJS_DUMMYSTORAGE(),
        bios: new window.EJS_DUMMYSTORAGE(),
        core: new window.EJS_DUMMYSTORAGE(),
      };
    } else {
      this.storage = {
        rom: new window.EJS_STORAGE("EmulatorJS-roms", "rom"),
        bios: new window.EJS_STORAGE("EmulatorJS-bios", "bios"),
        core: new window.EJS_STORAGE("EmulatorJS-core", "core"),
      };
    }
    // This is not cache. This is save data
    this.storage.states = new window.EJS_STORAGE("EmulatorJS-states", "states");

    this.game.classList.add("ejs_game");
    if (typeof this.config.backgroundImg === "string") {
      this.game.classList.add("ejs_game_background");
      if (this.config.backgroundBlur)
        this.game.classList.add("ejs_game_background_blur");
      this.game.setAttribute(
        "style",
        `--ejs-background-image: url("${this.config.backgroundImg}"); --ejs-background-color: ${this.config.backgroundColor};`,
      );
      this.on("start", () => {
        this.game.classList.remove("ejs_game_background");
        if (this.config.backgroundBlur)
          this.game.classList.remove("ejs_game_background_blur");
      });
    } else {
      this.game.setAttribute(
        "style",
        "--ejs-background-color: " + this.config.backgroundColor + ";",
      );
    }

    if (Array.isArray(this.config.cheats)) {
      for (let i = 0; i < this.config.cheats.length; i++) {
        const cheat = this.config.cheats[i];
        if (Array.isArray(cheat) && cheat[0] && cheat[1]) {
          this.cheats.push({
            desc: cheat[0],
            checked: false,
            code: cheat[1],
            is_permanent: true,
          });
        }
      }
    }

    this.createStartButton();
    this.handleResize();

    if (this.config.fixedSaveInterval) {
      this.startSaveInterval(this.config.fixedSaveInterval);
    }
  }

  startSaveInterval(period) {
    if (this.saveSaveInterval) {
      clearInterval(this.saveSaveInterval);
      this.saveSaveInterval = null;
    }
    // Disabled
    if (period === 0 || isNaN(period)) return;
    if (this.started) this.gameManager.saveSaveFiles();
    if (this.debug) console.log("Saving every", period, "miliseconds");
    this.saveSaveInterval = setInterval(() => {
      if (this.started) this.gameManager.saveSaveFiles();
    }, period);
  }

  setColor(color) {
    if (typeof color !== "string") color = "";
    let getColor = function (color) {
      color = color.toLowerCase();
      if (color && /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(color)) {
        if (color.length === 4) {
          let rv = "#";
          for (let i = 1; i < 4; i++) {
            rv += color.slice(i, i + 1) + color.slice(i, i + 1);
          }
          color = rv;
        }
        let rv = [];
        for (let i = 1; i < 7; i += 2) {
          rv.push(parseInt("0x" + color.slice(i, i + 2), 16));
        }
        return rv.join(", ");
      }
      return null;
    };
    if (!color || getColor(color) === null) {
      this.elements.parent.setAttribute(
        "style",
        "--ejs-primary-color: 26,175,255;",
      );
      return;
    }
    this.elements.parent.setAttribute(
      "style",
      "--ejs-primary-color:" + getColor(color) + ";",
    );
  }
  setupAds(ads, width, height) {
    const div = this.createElement("div");
    const time =
      typeof this.config.adMode === "number" &&
      this.config.adMode > -1 &&
      this.config.adMode < 3
        ? this.config.adMode
        : 2;
    div.classList.add("ejs_ad_iframe");
    const frame = this.createElement("iframe");
    frame.src = ads;
    frame.setAttribute("scrolling", "no");
    frame.setAttribute("frameborder", "no");
    frame.style.width = width;
    frame.style.height = height;
    const closeParent = this.createElement("div");
    closeParent.classList.add("ejs_ad_close");
    const closeButton = this.createElement("a");
    closeParent.appendChild(closeButton);
    closeParent.setAttribute("hidden", "");
    div.appendChild(closeParent);
    div.appendChild(frame);
    if (this.config.adMode !== 1) {
      this.elements.parent.appendChild(div);
    }
    this.addEventListener(closeButton, "click", () => {
      div.remove();
    });

    this.on("start-clicked", () => {
      if (this.config.adMode === 0) div.remove();
      if (this.config.adMode === 1) {
        this.elements.parent.appendChild(div);
      }
    });

    this.on("start", () => {
      closeParent.removeAttribute("hidden");
      const time =
        typeof this.config.adTimer === "number" && this.config.adTimer > 0
          ? this.config.adTimer
          : 10000;
      if (this.config.adTimer === -1) div.remove();
      if (this.config.adTimer === 0) return;
      setTimeout(() => {
        div.remove();
      }, time);
    });
  }
  adBlocked(url, del) {
    if (del) {
      document.querySelector('div[class="ejs_ad_iframe"]').remove();
    } else {
      try {
        document.querySelector('div[class="ejs_ad_iframe"]').remove();
      } catch (e) {}
      this.config.adUrl = url;
      this.setupAds(
        this.config.adUrl,
        this.config.adSize[0],
        this.config.adSize[1],
      );
    }
  }
  on(event, func) {
    if (!this.functions) this.functions = {};
    if (!Array.isArray(this.functions[event])) this.functions[event] = [];
    this.functions[event].push(func);
  }
  callEvent(event, data) {
    if (!this.functions) this.functions = {};
    if (!Array.isArray(this.functions[event])) return 0;
    this.functions[event].forEach((e) => e(data));
    return this.functions[event].length;
  }
  setElements(element) {
    const game = this.createElement("div");
    const elem = document.querySelector(element);
    elem.innerHTML = "";
    elem.appendChild(game);
    this.game = game;

    this.elements = {
      main: this.game,
      parent: elem,
    };
    this.elements.parent.classList.add("ejs_parent");
    this.elements.parent.setAttribute("tabindex", -1);
  }
  // Start button
  createStartButton() {
    const button = this.createElement("div");
    button.classList.add("ejs_start_button");
    let border = 0;
    if (typeof this.config.backgroundImg === "string") {
      button.classList.add("ejs_start_button_border");
      border = 1;
    }
    button.innerText =
      typeof this.config.startBtnName === "string"
        ? this.config.startBtnName
        : this.localization("Start Game");
    if (this.config.alignStartButton == "top") {
      button.style.bottom = "calc(100% - 20px)";
    } else if (this.config.alignStartButton == "center") {
      button.style.bottom = "calc(50% + 22.5px + " + border + "px)";
    }
    this.elements.parent.appendChild(button);
    this.addEventListener(button, "touchstart", () => {
      this.touch = true;
    });
    this.addEventListener(button, "click", this.startButtonClicked.bind(this));
    if (this.config.startOnLoad === true) {
      this.startButtonClicked(button);
    }
    setTimeout(() => {
      this.callEvent("ready");
    }, 20);
  }
  startButtonClicked(e) {
    // DELAY_SYNC: Prevent emulator start while in lobby phase
    if (
      window.EJS_emulator?.netplay?.currentRoom?.netplay_mode ===
        "delay_sync" &&
      window.EJS_emulator?.netplay?.currentRoom?.room_phase === "lobby"
    ) {
      console.log(
        "[EmulatorJS] Delaying emulator start - DELAY_SYNC room in lobby phase",
      );
      return;
    }

    this.callEvent("start-clicked");
    if (e.pointerType === "touch") {
      this.touch = true;
    }
    if (e.preventDefault) {
      e.preventDefault();
      e.target.remove();
    } else {
      e.remove();
    }
    this.createText();
    this.downloadGameCore();
  }
  // End start button
  createText() {
    this.textElem = this.createElement("div");
    this.textElem.classList.add("ejs_loading_text");
    if (typeof this.config.backgroundImg === "string")
      this.textElem.classList.add("ejs_loading_text_glow");
    this.textElem.innerText = this.localization("Loading...");
    this.elements.parent.appendChild(this.textElem);
  }
  localization(text, log) {
    if (typeof text === "undefined" || text.length === 0) return;
    text = text.toString();
    if (text.includes("EmulatorJS v")) return text;
    if (this.config.langJson) {
      if (typeof log === "undefined") log = true;
      if (!this.config.langJson[text] && log) {
        if (!this.missingLang.includes(text)) this.missingLang.push(text);
        if (this.debug)
          console.log(
            `Translation not found for '${text}'. Language set to '${this.config.language}'`,
          );
      }
      return this.config.langJson[text] || text;
    }
    return text;
  }
  checkCompression(data, msg, fileCbFunc) {
    if (!this.compression) {
      this.compression = new window.EJS_COMPRESSION(this);
    }
    if (msg) {
      this.textElem.innerText = msg;
    }
    return this.compression.decompress(
      data,
      (m, appendMsg) => {
        this.textElem.innerText = appendMsg ? msg + m : m;
      },
      fileCbFunc,
    );
  }
  checkCoreCompatibility(version) {
    if (
      this.versionAsInt(version.minimumEJSVersion) >
      this.versionAsInt(this.ejs_version)
    ) {
      this.startGameError(this.localization("Outdated EmulatorJS version"));
      throw new Error(
        "Core requires minimum EmulatorJS version of " +
          version.minimumEJSVersion,
      );
    }
  }
  startGameError(message) {
    console.log(message);
    if (this.textElem) {
      this.textElem.innerText = message;
      this.textElem.classList.add("ejs_error_text");
    }

    this.setupSettingsMenu();
    this.loadSettings();

    this.menu.failedToStart();
    this.handleResize();
    this.failedToStart = true;
  }
  downloadGameCore() {
    this.textElem.innerText = this.localization("Download Game Core");
    if (!this.config.threads && this.requiresThreads(this.getCore())) {
      this.startGameError(
        this.localization("Error for site owner") +
          "\n" +
          this.localization("Check console"),
      );
      console.warn("This core requires threads, but EJS_threads is not set!");
      return;
    }
    if (!this.supportsWebgl2 && this.requiresWebGL2(this.getCore())) {
      this.startGameError(this.localization("Outdated graphics driver"));
      return;
    }
    if (this.config.threads && typeof window.SharedArrayBuffer !== "function") {
      this.startGameError(
        this.localization("Error for site owner") +
          "\n" +
          this.localization("Check console"),
      );
      console.warn(
        "Threads is set to true, but the SharedArrayBuffer function is not exposed. Threads requires 2 headers to be set when sending you html page. See https://stackoverflow.com/a/68630724",
      );
      return;
    }
    const gotCore = (data) => {
      this.defaultCoreOpts = {};
      this.checkCompression(
        new Uint8Array(data),
        this.localization("Decompress Game Core"),
      ).then((data) => {
        let js, thread, wasm;
        for (let k in data) {
          if (k.endsWith(".wasm")) {
            wasm = data[k];
          } else if (k.endsWith(".worker.js")) {
            thread = data[k];
          } else if (k.endsWith(".js")) {
            js = data[k];
          } else if (k === "build.json") {
            this.checkCoreCompatibility(
              JSON.parse(new TextDecoder().decode(data[k])),
            );
          } else if (k === "core.json") {
            let core = JSON.parse(new TextDecoder().decode(data[k]));
            this.extensions = core.extensions;
            this.coreName = core.name;
            this.repository = core.repo;
            this.defaultCoreOpts = core.options;
            this.enableMouseLock = core.options.supportsMouse;
            this.retroarchOpts = core.retroarchOpts;
            this.saveFileExt = core.save;
          } else if (k === "license.txt") {
            this.license = new TextDecoder().decode(data[k]);
          }
        }

        if (this.saveFileExt === false) {
          this.elements.bottomBar.saveSavFiles[0].style.display = "none";
          this.elements.bottomBar.loadSavFiles[0].style.display = "none";
        }

        this.initGameCore(js, wasm, thread);
      });
    };
    const report = "cores/reports/" + this.getCore() + ".json";
    this.downloadFile(report, null, false, {
      responseType: "text",
      method: "GET",
    }).then(async (rep) => {
      if (
        rep === -1 ||
        typeof rep === "string" ||
        typeof rep.data === "string"
      ) {
        rep = {};
      } else {
        rep = rep.data;
      }
      if (!rep.buildStart) {
        console.warn(
          "Could not fetch core report JSON! Core caching will be disabled!",
        );
        rep.buildStart = Math.random() * 100;
      }
      if (this.webgl2Enabled === null) {
        this.webgl2Enabled = rep.options ? rep.options.defaultWebGL2 : false;
      }
      if (this.requiresWebGL2(this.getCore())) {
        this.webgl2Enabled = true;
      }
      let threads = false;
      if (typeof window.SharedArrayBuffer === "function") {
        const opt = this.preGetSetting("ejs_threads");
        if (opt) {
          threads = opt === "enabled";
        } else {
          threads = this.config.threads;
        }
      }

      let legacy = this.supportsWebgl2 && this.webgl2Enabled ? "" : "-legacy";
      let filename =
        this.getCore() + (threads ? "-thread" : "") + legacy + "-wasm.data";
      if (!this.debug) {
        const result = await this.storage.core.get(filename);
        if (result && result.version === rep.buildStart) {
          gotCore(result.data);
          return;
        }
      }
      const corePath = "cores/" + filename;
      let res = await this.downloadFile(
        corePath,
        (progress) => {
          this.textElem.innerText =
            this.localization("Download Game Core") + progress;
        },
        false,
        { responseType: "arraybuffer", method: "GET" },
      );
      if (res === -1) {
        console.log("File not found, attemping to fetch from emulatorjs cdn.");
        console.error(
          "**THIS METHOD IS A FAILSAFE, AND NOT OFFICIALLY SUPPORTED. USE AT YOUR OWN RISK**",
        );
        // RomM does not bundle cores; use the upstream EmulatorJS CDN.
        // Default to `nightly` for a consistent "latest cores" location.
        const version =
          typeof window.EJS_CDN_CORES_VERSION === "string" &&
          window.EJS_CDN_CORES_VERSION.length > 0
            ? window.EJS_CDN_CORES_VERSION
            : "nightly";
        res = await this.downloadFile(
          `https://cdn.emulatorjs.org/${version}/data/${corePath}`,
          (progress) => {
            this.textElem.innerText =
              this.localization("Download Game Core") + progress;
          },
          true,
          { responseType: "arraybuffer", method: "GET" },
        );
        if (res === -1) {
          if (!this.supportsWebgl2) {
            this.startGameError(this.localization("Outdated graphics driver"));
          } else {
            this.startGameError(
              this.localization("Error downloading core") +
                " (" +
                filename +
                ")",
            );
          }
          return;
        }
        console.warn(
          "File was not found locally, but was found on the emulatorjs cdn.\nIt is recommended to download the stable release from here: https://cdn.emulatorjs.org/releases/",
        );
      }
      gotCore(res.data);
      this.storage.core.put(filename, {
        version: rep.buildStart,
        data: res.data,
      });
    });
  }
  initGameCore(js, wasm, thread) {
    let script = this.createElement("script");
    script.src = URL.createObjectURL(
      new Blob([js], { type: "application/javascript" }),
    );
    script.addEventListener("load", () => {
      this.initModule(wasm, thread);
    });
    document.body.appendChild(script);
  }
  getBaseFileName(force) {
    //Only once game and core is loaded
    if (!this.started && !force) return null;
    if (
      force &&
      this.config.gameUrl !== "game" &&
      !this.config.gameUrl.startsWith("blob:")
    ) {
      return this.config.gameUrl.split("/").pop().split("#")[0].split("?")[0];
    }
    if (typeof this.config.gameName === "string") {
      const invalidCharacters = /[#<$+%>!`&*'|{}/\\?"=@:^\r\n]/gi;
      const name = this.config.gameName.replace(invalidCharacters, "").trim();
      if (name) return name;
    }
    if (!this.fileName) return "game";
    let parts = this.fileName.split(".");
    parts.splice(parts.length - 1, 1);
    return parts.join(".");
  }
  saveInBrowserSupported() {
    return (
      !!window.indexedDB &&
      (typeof this.config.gameName === "string" ||
        !this.config.gameUrl.startsWith("blob:"))
    );
  }
  displayMessage(message, time) {
    if (!this.msgElem) {
      this.msgElem = this.createElement("div");
      this.msgElem.classList.add("ejs_message");
      this.msgElem.style.zIndex = "6";
      this.elements.parent.appendChild(this.msgElem);
    }
    clearTimeout(this.msgTimeout);
    this.msgTimeout = setTimeout(
      () => {
        this.msgElem.innerText = "";
      },
      typeof time === "number" && time > 0 ? time : 3000,
    );
    this.msgElem.innerText = message;
  }

  downloadStartState() {
    return new Promise((resolve, reject) => {
      if (
        typeof this.config.loadState !== "string" &&
        !this.toData(this.config.loadState, true)
      ) {
        resolve();
        return;
      }
      this.textElem.innerText = this.localization("Download Game State");

      this.downloadFile(
        this.config.loadState,
        (progress) => {
          this.textElem.innerText =
            this.localization("Download Game State") + progress;
        },
        true,
        { responseType: "arraybuffer", method: "GET" },
      ).then((res) => {
        if (res === -1) {
          this.startGameError(
            this.localization("Error downloading game state"),
          );
          return;
        }
        this.on("start", () => {
          setTimeout(() => {
            this.gameManager.loadState(new Uint8Array(res.data));
          }, 10);
        });
        resolve();
      });
    });
  }
  downloadGameFile(assetUrl, type, progressMessage, decompressProgressMessage) {
    return new Promise(async (resolve, reject) => {
      if (
        (typeof assetUrl !== "string" || !assetUrl.trim()) &&
        !this.toData(assetUrl, true)
      ) {
        return resolve(assetUrl);
      }
      const gotData = async (input) => {
        const coreFilename = "/" + this.fileName;
        const coreFilePath = coreFilename.substring(
          0,
          coreFilename.length - coreFilename.split("/").pop().length,
        );
        if (this.config.dontExtractBIOS === true) {
          this.gameManager.FS.writeFile(
            coreFilePath + assetUrl.split("/").pop(),
            new Uint8Array(input),
          );
          return resolve(assetUrl);
        }
        const data = await this.checkCompression(
          new Uint8Array(input),
          decompressProgressMessage,
        );
        for (const k in data) {
          if (k === "!!notCompressedData") {
            this.gameManager.FS.writeFile(
              coreFilePath +
                assetUrl.split("/").pop().split("#")[0].split("?")[0],
              data[k],
            );
            break;
          }
          if (k.endsWith("/")) continue;
          this.gameManager.FS.writeFile(
            coreFilePath + k.split("/").pop(),
            data[k],
          );
        }
      };

      this.textElem.innerText = progressMessage;
      if (!this.debug) {
        const res = await this.downloadFile(assetUrl, null, true, {
          method: "HEAD",
        });
        const result = await this.storage.rom.get(assetUrl.split("/").pop());
        if (
          result &&
          result["content-length"] === res.headers["content-length"] &&
          result.type === type
        ) {
          await gotData(result.data);
          return resolve(assetUrl);
        }
      }
      const res = await this.downloadFile(
        assetUrl,
        (progress) => {
          this.textElem.innerText = progressMessage + progress;
        },
        true,
        { responseType: "arraybuffer", method: "GET" },
      );
      if (res === -1) {
        this.startGameError(this.localization("Network Error"));
        reject();
        return;
      }
      if (assetUrl instanceof File) {
        assetUrl = assetUrl.name;
      } else if (this.toData(assetUrl, true)) {
        assetUrl = "game";
      }
      await gotData(res.data);
      resolve(assetUrl);
      const limit =
        typeof this.config.cacheLimit === "number"
          ? this.config.cacheLimit
          : 1073741824;
      if (
        parseFloat(res.headers["content-length"]) < limit &&
        this.saveInBrowserSupported() &&
        assetUrl !== "game"
      ) {
        this.storage.rom.put(assetUrl.split("/").pop(), {
          "content-length": res.headers["content-length"],
          data: res.data,
          type: type,
        });
      }
    });
  }
  downloadGamePatch() {
    return new Promise(async (resolve) => {
      this.config.gamePatchUrl = await this.downloadGameFile(
        this.config.gamePatchUrl,
        "patch",
        this.localization("Download Game Patch"),
        this.localization("Decompress Game Patch"),
      );
      resolve();
    });
  }
  downloadGameParent() {
    return new Promise(async (resolve) => {
      this.config.gameParentUrl = await this.downloadGameFile(
        this.config.gameParentUrl,
        "parent",
        this.localization("Download Game Parent"),
        this.localization("Decompress Game Parent"),
      );
      resolve();
    });
  }
  downloadBios() {
    return new Promise(async (resolve) => {
      this.config.biosUrl = await this.downloadGameFile(
        this.config.biosUrl,
        "bios",
        this.localization("Download Game BIOS"),
        this.localization("Decompress Game BIOS"),
      );
      resolve();
    });
  }
  downloadRom() {
    const supportsExt = (ext) => {
      const core = this.getCore();
      if (!this.extensions) return false;
      return this.extensions.includes(ext);
    };

    return new Promise((resolve) => {
      this.textElem.innerText = this.localization("Download Game Data");

      const gotGameData = async (data) => {
        const coreName = this.getCore(true);
        const altName = this.getBaseFileName(true);
        if (
          ["arcade", "mame"].includes(coreName) ||
          this.config.dontExtractRom === true
        ) {
          this.fileName = altName;
          this.gameManager.FS.writeFile(this.fileName, new Uint8Array(data));

          // Calculate and store ROM metadata for netplay
          await this.calculateAndStoreRomMetadata(data, altName);

          resolve();
          return;
        }

        // List of cores to generate a CUE file for, if it doesn't exist.
        const cueGeneration = ["mednafen_psx_hw"];
        const prioritizeExtensions = ["cue", "ccd", "toc", "m3u"];

        let createCueFile = cueGeneration.includes(this.getCore());
        if (this.config.disableCue === true) {
          createCueFile = false;
        }

        let fileNames = [];
        this.checkCompression(
          new Uint8Array(data),
          this.localization("Decompress Game Data"),
          async (fileName, fileData) => {
            if (fileName.includes("/")) {
              const paths = fileName.split("/");
              let cp = "";
              for (let i = 0; i < paths.length - 1; i++) {
                if (paths[i] === "") continue;
                cp += `/${paths[i]}`;
                if (!this.gameManager.FS.analyzePath(cp).exists) {
                  this.gameManager.FS.mkdir(cp);
                }
              }
            }
            if (fileName.endsWith("/")) {
              this.gameManager.FS.mkdir(fileName);
              return;
            }
            if (fileName === "!!notCompressedData") {
              this.gameManager.FS.writeFile(altName, fileData);
              fileNames.push(altName);
            } else {
              this.gameManager.FS.writeFile(`/${fileName}`, fileData);
              fileNames.push(fileName);
            }
          },
        ).then(async () => {
          let isoFile = null;
          let supportedFile = null;
          let cueFile = null;
          fileNames.forEach((fileName) => {
            const ext = fileName.split(".").pop().toLowerCase();
            if (supportedFile === null && supportsExt(ext)) {
              supportedFile = fileName;
            }
            if (
              isoFile === null &&
              ["iso", "cso", "chd", "elf"].includes(ext)
            ) {
              isoFile = fileName;
            }
            if (prioritizeExtensions.includes(ext)) {
              const currentCueExt =
                cueFile === null
                  ? null
                  : cueFile.split(".").pop().toLowerCase();
              if (coreName === "psx") {
                // Always prefer m3u files for psx cores
                if (currentCueExt !== "m3u") {
                  if (cueFile === null || ext === "m3u") {
                    cueFile = fileName;
                  }
                }
              } else {
                const priority = ["cue", "ccd"];
                // Prefer cue or ccd files over toc or m3u
                if (!priority.includes(currentCueExt)) {
                  if (cueFile === null || priority.includes(ext)) {
                    cueFile = fileName;
                  }
                }
              }
            }
          });
          if (supportedFile !== null) {
            this.fileName = supportedFile;
          } else {
            this.fileName = fileNames[0];
          }
          if (
            isoFile !== null &&
            supportsExt(isoFile.split(".").pop().toLowerCase())
          ) {
            this.fileName = isoFile;
          }
          if (
            cueFile !== null &&
            supportsExt(cueFile.split(".").pop().toLowerCase())
          ) {
            this.fileName = cueFile;
          } else if (
            createCueFile &&
            supportsExt("m3u") &&
            supportsExt("cue")
          ) {
            this.fileName = this.gameManager.createCueFile(fileNames);
          }
          if (this.getCore(true) === "dos" && !this.config.disableBatchBootup) {
            this.fileName = this.gameManager.writeBootupBatchFile();
          }

          // Calculate and store ROM metadata for netplay
          await this.calculateAndStoreRomMetadata(
            data,
            this.fileName || this.getBaseFileName(),
          );

          resolve();
        });
      };
      const downloadFile = async () => {
        const res = await this.downloadFile(
          this.config.gameUrl,
          (progress) => {
            this.textElem.innerText =
              this.localization("Download Game Data") + progress;
          },
          true,
          { responseType: "arraybuffer", method: "GET" },
        );
        if (res === -1) {
          this.startGameError(this.localization("Network Error"));
          return;
        }
        if (this.config.gameUrl instanceof File) {
          this.config.gameUrl = this.config.gameUrl.name;
        } else if (this.toData(this.config.gameUrl, true)) {
          this.config.gameUrl = "game";
        }
        gotGameData(res.data);
        const limit =
          typeof this.config.cacheLimit === "number"
            ? this.config.cacheLimit
            : 1073741824;
        if (
          parseFloat(res.headers["content-length"]) < limit &&
          this.saveInBrowserSupported() &&
          this.config.gameUrl !== "game"
        ) {
          this.storage.rom.put(this.config.gameUrl.split("/").pop(), {
            "content-length": res.headers["content-length"],
            data: res.data,
          });
        }
      };

      if (!this.debug) {
        this.downloadFile(this.config.gameUrl, null, true, {
          method: "HEAD",
        }).then(async (res) => {
          const name =
            typeof this.config.gameUrl === "string"
              ? this.config.gameUrl.split("/").pop()
              : "game";
          const result = await this.storage.rom.get(name);
          if (
            result &&
            result["content-length"] === res.headers["content-length"] &&
            name !== "game"
          ) {
            gotGameData(result.data);
            return;
          }
          downloadFile();
        });
      } else {
        downloadFile();
      }
    });
  }
  downloadFiles() {
    (async () => {
      this.gameManager = new window.EJS_GameManager(this.Module, this);
      await this.gameManager.loadExternalFiles();
      await this.gameManager.mountFileSystems();
      this.callEvent("saveDatabaseLoaded", this.gameManager.FS);
      if (this.getCore() === "ppsspp") {
        await this.gameManager.loadPpssppAssets();
      }
      await this.downloadRom();
      await this.downloadBios();
      await this.downloadStartState();
      await this.downloadGameParent();
      await this.downloadGamePatch();
      this.startGame();
    })();
  }
  initModule(wasmData, threadData) {
    if (typeof window.EJS_Runtime !== "function") {
      console.warn("EJS_Runtime is not defined!");
      this.startGameError(
        this.localization("Error loading EmulatorJS runtime"),
      );
      throw new Error("EJS_Runtime is not defined!");
    }

    // Firefox tends to be more sensitive to WebAudio scheduling jitter.
    // Apply a small compatibility patch that nudges towards stability
    // (higher latency + larger ScriptProcessor buffers when used).
    if (!this._ejsWebAudioStabilityPatched) {
      const ua =
        typeof navigator !== "undefined" && navigator.userAgent
          ? navigator.userAgent
          : "";
      const isFirefox = /firefox\//i.test(ua);
      const enabled =
        !(this.config && this.config.firefoxAudioStability === false) &&
        isFirefox;

      if (enabled) {
        const desiredLatencyHint =
          this.config && typeof this.config.audioLatencyHint !== "undefined"
            ? this.config.audioLatencyHint
            : "playback";
        const minScriptProcessorBufferSize =
          this.config &&
          typeof this.config.audioMinScriptProcessorBufferSize === "number"
            ? this.config.audioMinScriptProcessorBufferSize
            : 8192;

        const installWebAudioStabilityPatch = () => {
          const originalAudioContext = window.AudioContext;
          const originalWebkitAudioContext = window.webkitAudioContext;
          const cleanups = [];

          const wrapAudioContextConstructor = (Ctor, assign) => {
            if (typeof Ctor !== "function") return;

            function PatchedAudioContext(options) {
              const nextOptions =
                options && typeof options === "object" ? { ...options } : {};

              if (
                typeof desiredLatencyHint !== "undefined" &&
                desiredLatencyHint !== null &&
                typeof nextOptions.latencyHint === "undefined"
              ) {
                nextOptions.latencyHint = desiredLatencyHint;
              }

              return Reflect.construct(
                Ctor,
                [nextOptions],
                PatchedAudioContext,
              );
            }

            PatchedAudioContext.prototype = Ctor.prototype;
            Object.setPrototypeOf(PatchedAudioContext, Ctor);
            assign(PatchedAudioContext);
            cleanups.push(() => assign(Ctor));
          };

          // Patch constructors to supply a default latencyHint.
          wrapAudioContextConstructor(originalAudioContext, (v) => {
            window.AudioContext = v;
          });
          wrapAudioContextConstructor(originalWebkitAudioContext, (v) => {
            window.webkitAudioContext = v;
          });

          // Patch ScriptProcessor buffer size when used (older emscripten paths).
          // Only override explicit small sizes; keep 0 (browser-chosen) as-is.
          if (
            originalAudioContext &&
            originalAudioContext.prototype &&
            typeof originalAudioContext.prototype.createScriptProcessor ===
              "function"
          ) {
            const originalCreateScriptProcessor =
              originalAudioContext.prototype.createScriptProcessor;
            originalAudioContext.prototype.createScriptProcessor = function (
              bufferSize,
              numberOfInputChannels,
              numberOfOutputChannels,
            ) {
              let nextBufferSize = bufferSize;
              if (
                typeof bufferSize === "number" &&
                bufferSize > 0 &&
                bufferSize < minScriptProcessorBufferSize
              ) {
                nextBufferSize = minScriptProcessorBufferSize;
              }
              return originalCreateScriptProcessor.call(
                this,
                nextBufferSize,
                numberOfInputChannels,
                numberOfOutputChannels,
              );
            };
            cleanups.push(() => {
              originalAudioContext.prototype.createScriptProcessor =
                originalCreateScriptProcessor;
            });
          }

          return () => {
            for (let i = cleanups.length - 1; i >= 0; i--) {
              try {
                cleanups[i]();
              } catch (e) {}
            }
          };
        };

        this._ejsWebAudioStabilityPatched = true;
        this._ejsUninstallWebAudioStabilityPatch =
          installWebAudioStabilityPatch();
        this.on("exit", () => {
          if (typeof this._ejsUninstallWebAudioStabilityPatch === "function") {
            try {
              this._ejsUninstallWebAudioStabilityPatch();
            } catch (e) {}
          }
          this._ejsUninstallWebAudioStabilityPatch = null;
          this._ejsWebAudioStabilityPatched = false;
        });

        if (this.debug) {
          console.log(
            "Firefox WebAudio stability patch enabled:",
            "latencyHint=",
            desiredLatencyHint,
            "minScriptProcessorBufferSize=",
            minScriptProcessorBufferSize,
          );
        }
      }
    }

    window
      .EJS_Runtime({
        noInitialRun: true,
        onRuntimeInitialized: null,
        arguments: [],
        preRun: [],
        postRun: [],
        canvas: this.canvas,
        callbacks: {},
        parent: this.elements.parent,
        print: (msg) => {
          if (this.debug) {
            console.log(msg);
          }
        },
        printErr: (msg) => {
          if (this.debug) {
            console.log(msg);
          }
        },
        totalDependencies: 0,
        locateFile: function (fileName) {
          if (this.debug) console.log(fileName);
          if (fileName.endsWith(".wasm")) {
            return URL.createObjectURL(
              new Blob([wasmData], { type: "application/wasm" }),
            );
          } else if (fileName.endsWith(".worker.js")) {
            return URL.createObjectURL(
              new Blob([threadData], { type: "application/javascript" }),
            );
          }
        },
        getSavExt: () => {
          if (this.saveFileExt) {
            return "." + this.saveFileExt;
          }
          return ".srm";
        },
      })
      .then((module) => {
        this.Module = module;
        this.downloadFiles();
      })
      .catch((e) => {
        console.warn(e);
        this.startGameError(this.localization("Failed to start game"));
      });
  }
  startGame() {
    try {
      const args = [];
      if (this.debug) args.push("-v");
      args.push("/" + this.fileName);
      if (this.debug) console.log(args);

      if (this.textElem) {
        this.textElem.remove();
        this.textElem = null;
      }
      this.game.classList.remove("ejs_game");
      this.game.classList.add("ejs_canvas_parent");
      if (!this.canvas.isConnected) {
        this.game.appendChild(this.canvas);
      }

      let initialResolution;
      if (
        this.Module &&
        typeof this.Module.getNativeResolution === "function"
      ) {
        try {
          initialResolution = this.Module.getNativeResolution();
        } catch (e) {}
      }
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = this.canvas.getBoundingClientRect();
      const displayWidth = Math.floor((rect.width || 0) * dpr);
      const displayHeight = Math.floor((rect.height || 0) * dpr);
      const nativeWidth = Math.floor(
        (initialResolution && initialResolution.width) || 0,
      );
      const nativeHeight = Math.floor(
        (initialResolution && initialResolution.height) || 0,
      );
      const initialWidth = Math.max(
        1,
        displayWidth,
        nativeWidth,
        Math.floor(640 * dpr),
      );
      const initialHeight = Math.max(
        1,
        displayHeight,
        nativeHeight,
        Math.floor(480 * dpr),
      );
      this.canvas.width = initialWidth;
      this.canvas.height = initialHeight;
      if (this.Module && typeof this.Module.setCanvasSize === "function") {
        this.Module.setCanvasSize(initialWidth, initialHeight);
      }

      this.handleResize();
      this.Module.callMain(args);
      if (
        typeof this.config.softLoad === "number" &&
        this.config.softLoad > 0
      ) {
        this.resetTimeout = setTimeout(() => {
          this.gameManager.restart();
        }, this.config.softLoad * 1000);
      }
      this.Module.resumeMainLoop();
      this.checkSupportedOpts();
      this.setupDisksMenu();

      // Initialize netplay functions early (don't wait for menu to open)
      if (typeof this.defineNetplayFunctions === "function") {
        this.defineNetplayFunctions();
      }
      // hide the disks menu if the disk count is not greater than 1
      if (!(this.gameManager.getDiskCount() > 1)) {
        this.diskParent.style.display = "none";
      }
      this.setupSettingsMenu();
      this.loadSettings();
      this.updateCheatUI();
      this.updateGamepadLabels();
      if (!this.muted) this.setVolume(this.volume);
      if (this.config.noAutoFocus !== true) this.elements.parent.focus();
      this.started = true;
      this.paused = false;
      if (this.touch) {
        this.virtualGamepad.style.display = "";
      }
      this.handleResize();
      if (this.config.fullscreenOnLoad) {
        try {
          this.toggleFullscreen(true);
        } catch (e) {
          if (this.debug) console.warn("Could not fullscreen on load");
        }
      }
      this.menu.open();
      if (this.isSafari && this.isMobile) {
        //Safari is --- funny
        this.checkStarted();
      }
    } catch (e) {
      console.warn("Failed to start game", e);
      this.startGameError(this.localization("Failed to start game"));
      this.callEvent("exit");
      return;
    }
    this.callEvent("start");
  }
  checkStarted() {
    (async () => {
      let sleep = (ms) => new Promise((r) => setTimeout(r, ms));
      let state = "suspended";
      let popup;
      while (state === "suspended") {
        if (!this.Module.AL) return;
        this.Module.AL.currentCtx.sources.forEach((ctx) => {
          state = ctx.gain.context.state;
        });
        if (state !== "suspended") break;
        if (!popup) {
          popup = this.createPopup("", {});
          const button = this.createElement("button");
          button.innerText = this.localization("Click to resume Emulator");
          button.classList.add("ejs_menu_button");
          button.style.width = "25%";
          button.style.height = "25%";
          popup.appendChild(button);
          popup.style["text-align"] = "center";
          popup.style["font-size"] = "28px";
        }
        await sleep(10);
      }
      if (popup) this.closePopup();
    })();
  }
  bindListeners() {
    this.createContextMenu();
    this.createBottomMenuBar();
    this.createControlSettingMenu();
    this.createCheatsMenu();
    this.setVirtualGamepad();
    this.addEventListener(
      this.elements.parent,
      "keydown keyup",
      this.keyChange.bind(this),
    );
    this.addEventListener(this.elements.parent, "mousedown touchstart", (e) => {
      if (
        document.activeElement !== this.elements.parent &&
        this.config.noAutoFocus !== true
      )
        this.elements.parent.focus();
    });
    this.addEventListener(window, "resize", this.handleResize.bind(this));
    //this.addEventListener(window, "blur", e => console.log(e), true); //TODO - add "click to make keyboard keys work" message?

    let counter = 0;
    this.elements.statePopupPanel = this.createPopup("", {}, true);
    this.elements.statePopupPanel.innerText = this.localization(
      "Drop save state here to load",
    );
    this.elements.statePopupPanel.style["text-align"] = "center";
    this.elements.statePopupPanel.style["font-size"] = "28px";

    //to fix a funny apple bug
    this.addEventListener(
      window,
      "webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange",
      () => {
        setTimeout(() => {
          this.handleResize.bind(this);
          if (this.config.noAutoFocus !== true) this.elements.parent.focus();
        }, 0);
      },
    );
    this.addEventListener(window, "beforeunload", (e) => {
      if (this.config.disableAutoUnload) {
        e.preventDefault();
        e.returnValue = "";
        return;
      }
      if (!this.started) return;
      this.callEvent("exit");
    });
    this.addEventListener(this.elements.parent, "dragenter", (e) => {
      e.preventDefault();
      if (!this.started) return;
      counter++;
      this.elements.statePopupPanel.parentElement.style.display = "block";
    });
    this.addEventListener(this.elements.parent, "dragover", (e) => {
      e.preventDefault();
    });
    this.addEventListener(this.elements.parent, "dragleave", (e) => {
      e.preventDefault();
      if (!this.started) return;
      counter--;
      if (counter === 0) {
        this.elements.statePopupPanel.parentElement.style.display = "none";
      }
    });
    this.addEventListener(this.elements.parent, "dragend", (e) => {
      e.preventDefault();
      if (!this.started) return;
      counter = 0;
      this.elements.statePopupPanel.parentElement.style.display = "none";
    });

    this.addEventListener(this.elements.parent, "drop", (e) => {
      e.preventDefault();
      if (!this.started) return;
      this.elements.statePopupPanel.parentElement.style.display = "none";
      counter = 0;
      const items = e.dataTransfer.items;
      let file;
      for (let i = 0; i < items.length; i++) {
        if (items[i].kind !== "file") continue;
        file = items[i];
        break;
      }
      if (!file) return;
      const fileHandle = file.getAsFile();
      fileHandle.arrayBuffer().then((data) => {
        this.gameManager.loadState(new Uint8Array(data));
      });
    });

    this.gamepad = new GamepadHandler(); //https://github.com/ethanaobrien/Gamepad
    this.gamepad.on("connected", (e) => {
      if (!this.gamepadLabels) return;
      for (let i = 0; i < this.gamepadSelection.length; i++) {
        if (this.gamepadSelection[i] === "") {
          this.gamepadSelection[i] =
            this.gamepad.gamepads[e.gamepadIndex].id +
            "_" +
            this.gamepad.gamepads[e.gamepadIndex].index;
          break;
        }
      }
      this.updateGamepadLabels();
    });
    this.gamepad.on("disconnected", (e) => {
      const gamepadIndex = this.gamepad.gamepads.indexOf(
        this.gamepad.gamepads.find((f) => f.index == e.gamepadIndex),
      );
      const gamepadSelection =
        this.gamepad.gamepads[gamepadIndex].id +
        "_" +
        this.gamepad.gamepads[gamepadIndex].index;
      for (let i = 0; i < this.gamepadSelection.length; i++) {
        if (this.gamepadSelection[i] === gamepadSelection) {
          this.gamepadSelection[i] = "";
        }
      }
      setTimeout(this.updateGamepadLabels.bind(this), 10);
    });
    this.gamepad.on("axischanged", this.gamepadEvent.bind(this));
    this.gamepad.on("buttondown", this.gamepadEvent.bind(this));
    this.gamepad.on("buttonup", this.gamepadEvent.bind(this));
  }
  checkSupportedOpts() {
    if (!this.gameManager.supportsStates()) {
      this.elements.bottomBar.saveState[0].style.display = "none";
      this.elements.bottomBar.loadState[0].style.display = "none";
      this.elements.contextMenu.save.style.display = "none";
      this.elements.contextMenu.load.style.display = "none";
    }
    if (!this.config.netplayUrl || this.netplayEnabled === false) {
      this.elements.bottomBar.netplay[0].style.display = "none";
    }

    // Netplay listing uses gameId as a query param, but the server can safely
    // ignore it. Do not hide netplay just because the embedding page didn't
    // provide a numeric ID.
    if (typeof this.config.gameId !== "number") {
      this.config.gameId = 0;
    }
  }
  updateGamepadLabels() {
    for (let i = 0; i < this.gamepadLabels.length; i++) {
      this.gamepadLabels[i].innerHTML = "";
      const def = this.createElement("option");
      def.setAttribute("value", "notconnected");
      def.innerText = "Not Connected";
      this.gamepadLabels[i].appendChild(def);
      for (let j = 0; j < this.gamepad.gamepads.length; j++) {
        const opt = this.createElement("option");
        opt.setAttribute(
          "value",
          this.gamepad.gamepads[j].id + "_" + this.gamepad.gamepads[j].index,
        );
        opt.innerText =
          this.gamepad.gamepads[j].id + "_" + this.gamepad.gamepads[j].index;
        this.gamepadLabels[i].appendChild(opt);
      }
      this.gamepadLabels[i].value = this.gamepadSelection[i] || "notconnected";
    }
  }
  createLink(elem, link, text, useP) {
    const elm = this.createElement("a");
    elm.href = link;
    elm.target = "_blank";
    elm.innerText = this.localization(text);
    if (useP) {
      const p = this.createElement("p");
      p.appendChild(elm);
      elem.appendChild(p);
    } else {
      elem.appendChild(elm);
    }
  }
  defaultButtonOptions = {
    playPause: {
      visible: true,
      icon: "play",
      displayName: "Play/Pause",
    },
    play: {
      visible: true,
      icon: '<svg viewBox="0 0 320 512"><path d="M361 215C375.3 223.8 384 239.3 384 256C384 272.7 375.3 288.2 361 296.1L73.03 472.1C58.21 482 39.66 482.4 24.52 473.9C9.377 465.4 0 449.4 0 432V80C0 62.64 9.377 46.63 24.52 38.13C39.66 29.64 58.21 29.99 73.03 39.04L361 215z"/></svg>',
      displayName: "Play",
    },
    pause: {
      visible: true,
      icon: '<svg viewBox="0 0 320 512"><path d="M272 63.1l-32 0c-26.51 0-48 21.49-48 47.1v288c0 26.51 21.49 48 48 48L272 448c26.51 0 48-21.49 48-48v-288C320 85.49 298.5 63.1 272 63.1zM80 63.1l-32 0c-26.51 0-48 21.49-48 48v288C0 426.5 21.49 448 48 448l32 0c26.51 0 48-21.49 48-48v-288C128 85.49 106.5 63.1 80 63.1z"/></svg>',
      displayName: "Pause",
    },
    restart: {
      visible: true,
      icon: '<svg viewBox="0 0 512 512"><path d="M496 48V192c0 17.69-14.31 32-32 32H320c-17.69 0-32-14.31-32-32s14.31-32 32-32h63.39c-29.97-39.7-77.25-63.78-127.6-63.78C167.7 96.22 96 167.9 96 256s71.69 159.8 159.8 159.8c34.88 0 68.03-11.03 95.88-31.94c14.22-10.53 34.22-7.75 44.81 6.375c10.59 14.16 7.75 34.22-6.375 44.81c-39.03 29.28-85.36 44.86-134.2 44.86C132.5 479.9 32 379.4 32 256s100.5-223.9 223.9-223.9c69.15 0 134 32.47 176.1 86.12V48c0-17.69 14.31-32 32-32S496 30.31 496 48z"/></svg>',
      displayName: "Restart",
    },
    mute: {
      visible: true,
      icon: '<svg viewBox="0 0 640 512"><path d="M412.6 182c-10.28-8.334-25.41-6.867-33.75 3.402c-8.406 10.24-6.906 25.35 3.375 33.74C393.5 228.4 400 241.8 400 255.1c0 14.17-6.5 27.59-17.81 36.83c-10.28 8.396-11.78 23.5-3.375 33.74c4.719 5.806 11.62 8.802 18.56 8.802c5.344 0 10.75-1.779 15.19-5.399C435.1 311.5 448 284.6 448 255.1S435.1 200.4 412.6 182zM473.1 108.2c-10.22-8.334-25.34-6.898-33.78 3.34c-8.406 10.24-6.906 25.35 3.344 33.74C476.6 172.1 496 213.3 496 255.1s-19.44 82.1-53.31 110.7c-10.25 8.396-11.75 23.5-3.344 33.74c4.75 5.775 11.62 8.771 18.56 8.771c5.375 0 10.75-1.779 15.22-5.431C518.2 366.9 544 313 544 255.1S518.2 145 473.1 108.2zM534.4 33.4c-10.22-8.334-25.34-6.867-33.78 3.34c-8.406 10.24-6.906 25.35 3.344 33.74C559.9 116.3 592 183.9 592 255.1s-32.09 139.7-88.06 185.5c-10.25 8.396-11.75 23.5-3.344 33.74C505.3 481 512.2 484 519.2 484c5.375 0 10.75-1.779 15.22-5.431C601.5 423.6 640 342.5 640 255.1S601.5 88.34 534.4 33.4zM301.2 34.98c-11.5-5.181-25.01-3.076-34.43 5.29L131.8 160.1H48c-26.51 0-48 21.48-48 47.96v95.92c0 26.48 21.49 47.96 48 47.96h83.84l134.9 119.8C272.7 477 280.3 479.8 288 479.8c4.438 0 8.959-.9314 13.16-2.835C312.7 471.8 320 460.4 320 447.9V64.12C320 51.55 312.7 40.13 301.2 34.98z"/></svg>',
      displayName: "Mute",
    },
    unmute: {
      visible: true,
      icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M301.2 34.85c-11.5-5.188-25.02-3.122-34.44 5.253L131.8 160H48c-26.51 0-48 21.49-48 47.1v95.1c0 26.51 21.49 47.1 48 47.1h83.84l134.9 119.9c5.984 5.312 13.58 8.094 21.26 8.094c4.438 0 8.972-.9375 13.17-2.844c11.5-5.156 18.82-16.56 18.82-29.16V64C319.1 51.41 312.7 40 301.2 34.85zM513.9 255.1l47.03-47.03c9.375-9.375 9.375-24.56 0-33.94s-24.56-9.375-33.94 0L480 222.1L432.1 175c-9.375-9.375-24.56-9.375-33.94 0s-9.375 24.56 0 33.94l47.03 47.03l-47.03 47.03c-9.375 9.375-9.375 24.56 0 33.94c9.373 9.373 24.56 9.381 33.94 0L480 289.9l47.03 47.03c9.373 9.373 24.56 9.381 33.94 0c9.375-9.375 9.375-24.56 0-33.94L513.9 255.1z"/></svg>',
      displayName: "Unmute",
    },
    settings: {
      visible: true,
      icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M495.9 166.6C499.2 175.2 496.4 184.9 489.6 191.2L446.3 230.6C447.4 238.9 448 247.4 448 256C448 264.6 447.4 273.1 446.3 281.4L489.6 320.8C496.4 327.1 499.2 336.8 495.9 345.4C491.5 357.3 486.2 368.8 480.2 379.7L475.5 387.8C468.9 398.8 461.5 409.2 453.4 419.1C447.4 426.2 437.7 428.7 428.9 425.9L373.2 408.1C359.8 418.4 344.1 427 329.2 433.6L316.7 490.7C314.7 499.7 307.7 506.1 298.5 508.5C284.7 510.8 270.5 512 255.1 512C241.5 512 227.3 510.8 213.5 508.5C204.3 506.1 197.3 499.7 195.3 490.7L182.8 433.6C167 427 152.2 418.4 138.8 408.1L83.14 425.9C74.3 428.7 64.55 426.2 58.63 419.1C50.52 409.2 43.12 398.8 36.52 387.8L31.84 379.7C25.77 368.8 20.49 357.3 16.06 345.4C12.82 336.8 15.55 327.1 22.41 320.8L65.67 281.4C64.57 273.1 64 264.6 64 256C64 247.4 64.57 238.9 65.67 230.6L22.41 191.2C15.55 184.9 12.82 175.3 16.06 166.6C20.49 154.7 25.78 143.2 31.84 132.3L36.51 124.2C43.12 113.2 50.52 102.8 58.63 92.95C64.55 85.8 74.3 83.32 83.14 86.14L138.8 103.9C152.2 93.56 167 84.96 182.8 78.43L195.3 21.33C197.3 12.25 204.3 5.04 213.5 3.51C227.3 1.201 241.5 0 256 0C270.5 0 284.7 1.201 298.5 3.51C307.7 5.04 314.7 12.25 316.7 21.33L329.2 78.43C344.1 84.96 359.8 93.56 373.2 103.9L428.9 86.14C437.7 83.32 447.4 85.8 453.4 92.95C461.5 102.8 468.9 113.2 475.5 124.2L480.2 132.3C486.2 143.2 491.5 154.7 495.9 166.6V166.6zM256 336C300.2 336 336 300.2 336 255.1C336 211.8 300.2 175.1 256 175.1C211.8 175.1 176 211.8 176 255.1C176 300.2 211.8 336 256 336z"/></svg>',
      displayName: "Settings",
    },
    fullscreen: {
      visible: true,
      icon: "fullscreen",
      displayName: "Fullscreen",
    },
    enterFullscreen: {
      visible: true,
      icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M208 281.4c-12.5-12.5-32.76-12.5-45.26-.002l-78.06 78.07l-30.06-30.06c-6.125-6.125-14.31-9.367-22.63-9.367c-4.125 0-8.279 .7891-12.25 2.43c-11.97 4.953-19.75 16.62-19.75 29.56v135.1C.0013 501.3 10.75 512 24 512h136c12.94 0 24.63-7.797 29.56-19.75c4.969-11.97 2.219-25.72-6.938-34.87l-30.06-30.06l78.06-78.07c12.5-12.49 12.5-32.75 .002-45.25L208 281.4zM487.1 0h-136c-12.94 0-24.63 7.797-29.56 19.75c-4.969 11.97-2.219 25.72 6.938 34.87l30.06 30.06l-78.06 78.07c-12.5 12.5-12.5 32.76 0 45.26l22.62 22.62c12.5 12.5 32.76 12.5 45.26 0l78.06-78.07l30.06 30.06c9.156 9.141 22.87 11.84 34.87 6.937C504.2 184.6 512 172.9 512 159.1V23.1C512 10.74 501.3 0 487.1 0z"/></svg>',
      displayName: "Enter Fullscreen",
    },
    exitFullscreen: {
      visible: true,
      icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M215.1 272h-136c-12.94 0-24.63 7.797-29.56 19.75C45.47 303.7 48.22 317.5 57.37 326.6l30.06 30.06l-78.06 78.07c-12.5 12.5-12.5 32.75-.0012 45.25l22.62 22.62c12.5 12.5 32.76 12.5 45.26 .0013l78.06-78.07l30.06 30.06c6.125 6.125 14.31 9.367 22.63 9.367c4.125 0 8.279-.7891 12.25-2.43c11.97-4.953 19.75-16.62 19.75-29.56V296C239.1 282.7 229.3 272 215.1 272zM296 240h136c12.94 0 24.63-7.797 29.56-19.75c4.969-11.97 2.219-25.72-6.938-34.87l-30.06-30.06l78.06-78.07c12.5-12.5 12.5-32.76 .0002-45.26l-22.62-22.62c-12.5-12.5-32.76-12.5-45.26-.0003l-78.06 78.07l-30.06-30.06c-9.156-9.141-22.87-11.84-34.87-6.937c-11.97 4.953-19.75 16.62-19.75 29.56v135.1C272 229.3 282.7 240 296 240z"/></svg>',
      displayName: "Exit Fullscreen",
    },
    saveState: {
      visible: true,
      icon: '<svg viewBox="0 0 448 512"><path fill="currentColor" d="M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"/></svg>',
      displayName: "Save State",
    },
    loadState: {
      visible: true,
      icon: '<svg viewBox="0 0 576 512"><path fill="currentColor" d="M572.694 292.093L500.27 416.248A63.997 63.997 0 0 1 444.989 448H45.025c-18.523 0-30.064-20.093-20.731-36.093l72.424-124.155A64 64 0 0 1 152 256h399.964c18.523 0 30.064 20.093 20.73 36.093zM152 224h328v-48c0-26.51-21.49-48-48-48H272l-64-64H48C21.49 64 0 85.49 0 112v278.046l69.077-118.418C86.214 242.25 117.989 224 152 224z"/></svg>',
      displayName: "Load State",
    },
    screenRecord: {
      visible: true,
    },
    gamepad: {
      visible: true,
      icon: '<svg viewBox="0 0 640 512"><path fill="currentColor" d="M480 96H160C71.6 96 0 167.6 0 256s71.6 160 160 160c44.8 0 85.2-18.4 114.2-48h91.5c29 29.6 69.5 48 114.2 48 88.4 0 160-71.6 160-160S568.4 96 480 96zM256 276c0 6.6-5.4 12-12 12h-52v52c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-52H76c-6.6 0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h52v-52c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h52c6.6 0 12 5.4 12 12v40zm184 68c-26.5 0-48-21.5-48-48s21.5-48 48-48 48 21.5 48 48-21.5 48-48 48zm80-80c-26.5 0-48-21.5-48-48s21.5-48 48-48 48 21.5 48 48-21.5 48-48 48z"/></svg>',
      displayName: "Control Settings",
    },
    cheat: {
      visible: true,
      icon: '<svg viewBox="0 0 496 512"><path fill="currentColor" d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 448c-110.3 0-200-89.7-200-200S137.7 56 248 56s200 89.7 200 200-89.7 200-200 200zm-80-216c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm160 0c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm4 72.6c-20.8 25-51.5 39.4-84 39.4s-63.2-14.3-84-39.4c-8.5-10.2-23.7-11.5-33.8-3.1-10.2 8.5-11.5 23.6-3.1 33.8 30 36 74.1 56.6 120.9 56.6s90.9-20.6 120.9-56.6c8.5-10.2 7.1-25.3-3.1-33.8-10.1-8.4-25.3-7.1-33.8 3.1z" class=""></path></svg>',
      displayName: "Cheats",
    },
    volumeSlider: {
      visible: true,
    },
    saveSavFiles: {
      visible: true,
      icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 23 23"><path d="M3 6.5V5C3 3.89543 3.89543 3 5 3H16.1716C16.702 3 17.2107 3.21071 17.5858 3.58579L20.4142 6.41421C20.7893 6.78929 21 7.29799 21 7.82843V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V17.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" fill="transparent"></path><path d="M8 3H16V8.4C16 8.73137 15.7314 9 15.4 9H8.6C8.26863 9 8 8.73137 8 8.4V3Z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" fill="transparent"></path><path d="M18 21V13.6C18 13.2686 17.7314 13 17.4 13H15" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" fill="transparent"></path><path d="M6 21V17.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" fill="transparent"></path><path d="M12 12H1M1 12L4 9M1 12L4 15" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>',
      displayName: "Export Save File",
    },
    loadSavFiles: {
      visible: true,
      icon: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 23 23"><path d="M3 7.5V5C3 3.89543 3.89543 3 5 3H16.1716C16.702 3 17.2107 3.21071 17.5858 3.58579L20.4142 6.41421C20.7893 6.78929 21 7.29799 21 7.82843V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V16.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" fill="transparent"></path><path d="M6 21V17" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M18 21V13.6C18 13.2686 17.7314 13 17.4 13H15" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" fill="transparent"></path><path d="M16 3V8.4C16 8.73137 15.7314 9 15.4 9H13.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" fill="transparent"></path><path d="M8 3V6" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M1 12H12M12 12L9 9M12 12L9 15" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>',
      displayName: "Import Save File",
    },
    quickSave: {
      visible: true,
    },
    quickLoad: {
      visible: true,
    },
    screenshot: {
      visible: true,
    },
    cacheManager: {
      visible: true,
      icon: '<svg viewBox="0 0 1800 1800"><path d="M896 768q237 0 443-43t325-127v170q0 69-103 128t-280 93.5-385 34.5-385-34.5T231 896 128 768V598q119 84 325 127t443 43zm0 768q237 0 443-43t325-127v170q0 69-103 128t-280 93.5-385 34.5-385-34.5-280-93.5-103-128v-170q119 84 325 127t443 43zm0-384q237 0 443-43t325-127v170q0 69-103 128t-280 93.5-385 34.5-385-34.5-280-93.5-103-128V982q119 84 325 127t443 43zM896 0q208 0 385 34.5t280 93.5 103 128v128q0 69-103 128t-280 93.5T896 640t-385-34.5T231 512 128 384V256q0-69 103-128t280-93.5T896 0z"/></svg>',
      displayName: "Cache Manager",
    },
    exitEmulation: {
      visible: true,
      icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 460 460"><path style="fill:none;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(255,255,255);stroke-opacity:1;stroke-miterlimit:4;" d="M 14.000061 7.636414 L 14.000061 4.5 C 14.000061 4.223877 13.776123 3.999939 13.5 3.999939 L 4.5 3.999939 C 4.223877 3.999939 3.999939 4.223877 3.999939 4.5 L 3.999939 19.5 C 3.999939 19.776123 4.223877 20.000061 4.5 20.000061 L 13.5 20.000061 C 13.776123 20.000061 14.000061 19.776123 14.000061 19.5 L 14.000061 16.363586 " transform="matrix(21.333333,0,0,21.333333,0,0)"/><path style="fill:none;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(255,255,255);stroke-opacity:1;stroke-miterlimit:4;" d="M 9.999939 12 L 21 12 M 21 12 L 18.000366 8.499939 M 21 12 L 18 15.500061 " transform="matrix(21.333333,0,0,21.333333,0,0)"/></svg>',
      displayName: "Exit Emulation",
    },
    netplay: {
      visible: true,
      icon: '<svg viewBox="0 0 512 512"><path fill="currentColor" d="M364.215 192h131.43c5.439 20.419 8.354 41.868 8.354 64s-2.915 43.581-8.354 64h-131.43c5.154-43.049 4.939-86.746 0-128zM185.214 352c10.678 53.68 33.173 112.514 70.125 151.992.221.001.44.008.661.008s.44-.008.661-.008c37.012-39.543 59.467-98.414 70.125-151.992H185.214zm174.13-192h125.385C452.802 84.024 384.128 27.305 300.95 12.075c30.238 43.12 48.821 96.332 58.394 147.925zm-27.35 32H180.006c-5.339 41.914-5.345 86.037 0 128h151.989c5.339-41.915 5.345-86.037-.001-128zM152.656 352H27.271c31.926 75.976 100.6 132.695 183.778 147.925-30.246-43.136-48.823-96.35-58.393-147.925zm206.688 0c-9.575 51.605-28.163 104.814-58.394 147.925 83.178-15.23 151.852-71.949 183.778-147.925H359.344zm-32.558-192c-10.678-53.68-33.174-112.514-70.125-151.992-.221 0-.44-.008-.661-.008s-.44.008-.661.008C218.327 47.551 195.872 106.422 185.214 160h141.572zM16.355 192C10.915 212.419 8 233.868 8 256s2.915 43.581 8.355 64h131.43c-4.939-41.254-5.154-84.951 0-128H16.355zm136.301-32c9.575-51.602 28.161-104.81 58.394-147.925C127.872 27.305 59.198 84.024 27.271 160h125.385z"/></svg>',
      displayName: "Netplay",
    },
    diskButton: {
      visible: true,
      icon: '<svg fill="#FFFFFF" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 473.109 473.109"><path d="M340.963,101.878H12.105C5.423,101.878,0,107.301,0,113.983v328.862c0,6.68,5.423,12.105,12.105,12.105h328.857 c6.685,0,12.104-5.426,12.104-12.105V113.983C353.067,107.301,347.647,101.878,340.963,101.878z M67.584,120.042h217.895v101.884 H67.584V120.042z M296.076,429.228H56.998V278.414h239.079V429.228z M223.947,135.173h30.269v72.638h-30.269V135.173z M274.13,315.741H78.933v-12.105H274.13V315.741z M274.13,358.109H78.933v-12.105H274.13V358.109z M274.13,398.965H78.933v-12.105 H274.13V398.965z M473.109,30.263v328.863c0,6.68-5.426,12.105-12.105,12.105H384.59v-25.724h31.528V194.694H384.59v-56.489h20.93 V36.321H187.625v43.361h-67.583v-49.42c0-6.682,5.423-12.105,12.105-12.105H461.01C467.695,18.158,473.109,23.581,473.109,30.263z M343.989,51.453h30.269v31.321c-3.18-1.918-6.868-3.092-10.853-3.092h-19.416V51.453z M394.177,232.021h-9.581v-12.105h9.581 V232.021z M384.59,262.284h9.581v12.105h-9.581V262.284z M384.59,303.14h9.581v12.104h-9.581V303.14z"/></svg>',
      displayName: "Disks",
    },
    contextMenu: {
      visible: true,
      icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2023 Fonticons, Inc.--><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg>',
      displayName: "Context Menu",
    },
  };
  defaultButtonAliases = {
    volume: "volumeSlider",
  };
  buildButtonOptions(buttonUserOpts) {
    let mergedButtonOptions = this.defaultButtonOptions;

    // merge buttonUserOpts with mergedButtonOptions
    if (buttonUserOpts) {
      for (const key in buttonUserOpts) {
        let searchKey = key;
        // If the key is an alias, find the actual key in the default buttons
        if (this.defaultButtonAliases[key]) {
          // Use the alias to find the actual key
          // and update the searchKey to the actual key
          searchKey = this.defaultButtonAliases[key];
        }

        // Check if the button exists in the default buttons, and update its properties
        // If the button does not exist, create a custom button
        if (!mergedButtonOptions[searchKey]) {
          // If the button does not exist in the default buttons, create a custom button
          // Custom buttons must have a displayName, icon, and callback property
          if (
            !buttonUserOpts[searchKey] ||
            !buttonUserOpts[searchKey].displayName ||
            !buttonUserOpts[searchKey].icon ||
            !buttonUserOpts[searchKey].callback
          ) {
            if (this.debug)
              console.warn(
                `Custom button "${searchKey}" is missing required properties`,
              );
            continue;
          }

          mergedButtonOptions[searchKey] = {
            visible: true,
            displayName: buttonUserOpts[searchKey].displayName || searchKey,
            icon: buttonUserOpts[searchKey].icon || "",
            callback: buttonUserOpts[searchKey].callback || (() => {}),
            custom: true,
          };
        }

        // if the value is a boolean, set the visible property to the value
        if (typeof buttonUserOpts[searchKey] === "boolean") {
          mergedButtonOptions[searchKey].visible = buttonUserOpts[searchKey];
        } else if (typeof buttonUserOpts[searchKey] === "object") {
          // If the value is an object, merge it with the default button properties

          // if the button is the contextMenu, only allow the visible property to be set
          if (searchKey === "contextMenu") {
            mergedButtonOptions[searchKey].visible =
              buttonUserOpts[searchKey].visible !== undefined
                ? buttonUserOpts[searchKey].visible
                : true;
          } else if (this.defaultButtonOptions[searchKey]) {
            // copy properties from the button definition if they aren't null
            for (const prop in buttonUserOpts[searchKey]) {
              if (buttonUserOpts[searchKey][prop] !== null) {
                mergedButtonOptions[searchKey][prop] =
                  buttonUserOpts[searchKey][prop];
              }
            }
          } else {
            // button was not in the default buttons list and is therefore a custom button
            // verify that the value has a displayName, icon, and callback property
            if (
              buttonUserOpts[searchKey].displayName &&
              buttonUserOpts[searchKey].icon &&
              buttonUserOpts[searchKey].callback
            ) {
              mergedButtonOptions[searchKey] = {
                visible: true,
                displayName: buttonUserOpts[searchKey].displayName,
                icon: buttonUserOpts[searchKey].icon,
                callback: buttonUserOpts[searchKey].callback,
                custom: true,
              };
            } else if (this.debug) {
              console.warn(
                `Custom button "${searchKey}" is missing required properties`,
              );
            }
          }
        }

        // behaviour exceptions
        switch (searchKey) {
          case "playPause":
            mergedButtonOptions.play.visible =
              mergedButtonOptions.playPause.visible;
            mergedButtonOptions.pause.visible =
              mergedButtonOptions.playPause.visible;
            break;

          case "mute":
            mergedButtonOptions.unmute.visible =
              mergedButtonOptions.mute.visible;
            break;

          case "fullscreen":
            mergedButtonOptions.enterFullscreen.visible =
              mergedButtonOptions.fullscreen.visible;
            mergedButtonOptions.exitFullscreen.visible =
              mergedButtonOptions.fullscreen.visible;
            break;
        }
      }
    }

    return mergedButtonOptions;
  }
  createContextMenu() {
    this.elements.contextmenu = this.createElement("div");
    this.elements.contextmenu.classList.add("ejs_context_menu");
    this.addEventListener(this.game, "contextmenu", (e) => {
      e.preventDefault();
      if (
        (this.config.buttonOpts &&
          this.config.buttonOpts.rightClick === false) ||
        !this.started
      )
        return;
      const parentRect = this.elements.parent.getBoundingClientRect();
      this.elements.contextmenu.style.display = "block";
      const rect = this.elements.contextmenu.getBoundingClientRect();
      const up = e.offsetY + rect.height > parentRect.height - 25;
      const left = e.offsetX + rect.width > parentRect.width - 5;
      this.elements.contextmenu.style.left =
        e.offsetX - (left ? rect.width : 0) + "px";
      this.elements.contextmenu.style.top =
        e.offsetY - (up ? rect.height : 0) + "px";
    });
    const hideMenu = () => {
      this.elements.contextmenu.style.display = "none";
    };
    this.addEventListener(this.elements.contextmenu, "contextmenu", (e) =>
      e.preventDefault(),
    );
    this.addEventListener(this.elements.parent, "contextmenu", (e) =>
      e.preventDefault(),
    );
    this.addEventListener(this.game, "mousedown touchend", hideMenu);
    const parent = this.createElement("ul");
    const addButton = (title, hidden, functi0n) => {
      //<li><a href="#" onclick="return false">'+title+'</a></li>
      const li = this.createElement("li");
      if (hidden) li.hidden = true;
      const a = this.createElement("a");
      if (functi0n instanceof Function) {
        this.addEventListener(li, "click", (e) => {
          e.preventDefault();
          functi0n();
        });
      }
      a.href = "#";
      a.onclick = "return false";
      a.innerText = this.localization(title);
      li.appendChild(a);
      parent.appendChild(li);
      hideMenu();
      return li;
    };
    let screenshotUrl;
    const screenshot = addButton("Take Screenshot", false, () => {
      if (screenshotUrl) URL.revokeObjectURL(screenshotUrl);
      const date = new Date();
      const fileName =
        this.getBaseFileName() +
        "-" +
        date.getMonth() +
        "-" +
        date.getDate() +
        "-" +
        date.getFullYear();
      this.screenshot((blob, format) => {
        screenshotUrl = URL.createObjectURL(blob);
        const a = this.createElement("a");
        a.href = screenshotUrl;
        a.download = fileName + "." + format;
        a.click();
        hideMenu();
      });
    });

    let screenMediaRecorder = null;
    const startScreenRecording = addButton(
      "Start Screen Recording",
      false,
      () => {
        if (screenMediaRecorder !== null) {
          screenMediaRecorder.stop();
        }
        screenMediaRecorder = this.screenRecord();
        startScreenRecording.setAttribute("hidden", "hidden");
        stopScreenRecording.removeAttribute("hidden");
        hideMenu();
      },
    );
    const stopScreenRecording = addButton("Stop Screen Recording", true, () => {
      if (screenMediaRecorder !== null) {
        screenMediaRecorder.stop();
        screenMediaRecorder = null;
      }
      startScreenRecording.removeAttribute("hidden");
      stopScreenRecording.setAttribute("hidden", "hidden");
      hideMenu();
    });

    const qSave = addButton("Quick Save", false, () => {
      const slot = this.getSettingValue("save-state-slot")
        ? this.getSettingValue("save-state-slot")
        : "1";
      if (this.gameManager.quickSave(slot)) {
        this.displayMessage(
          this.localization("SAVED STATE TO SLOT") + " " + slot,
        );
      } else {
        this.displayMessage(this.localization("FAILED TO SAVE STATE"));
      }
      hideMenu();
    });
    const qLoad = addButton("Quick Load", false, () => {
      const slot = this.getSettingValue("save-state-slot")
        ? this.getSettingValue("save-state-slot")
        : "1";
      this.gameManager.quickLoad(slot);
      this.displayMessage(
        this.localization("LOADED STATE FROM SLOT") + " " + slot,
      );
      hideMenu();
    });
    this.elements.contextMenu = {
      screenshot: screenshot,
      startScreenRecording: startScreenRecording,
      stopScreenRecording: stopScreenRecording,
      save: qSave,
      load: qLoad,
    };
    addButton("EmulatorJS v" + this.ejs_version, false, () => {
      hideMenu();
      const body = this.createPopup("EmulatorJS", {
        Close: () => {
          this.closePopup();
        },
      });

      body.style.display = "flex";

      const menu = this.createElement("div");
      body.appendChild(menu);
      menu.classList.add("ejs_list_selector");
      const parent = this.createElement("ul");
      const addButton = (title, hidden, functi0n) => {
        const li = this.createElement("li");
        if (hidden) li.hidden = true;
        const a = this.createElement("a");
        if (functi0n instanceof Function) {
          this.addEventListener(li, "click", (e) => {
            e.preventDefault();
            functi0n(li);
          });
        }
        a.href = "#";
        a.onclick = "return false";
        a.innerText = this.localization(title);
        li.appendChild(a);
        parent.appendChild(li);
        hideMenu();
        return li;
      };
      //body.style["padding-left"] = "20%";
      const home = this.createElement("div");
      const license = this.createElement("div");
      license.style.display = "none";
      const retroarch = this.createElement("div");
      retroarch.style.display = "none";
      const coreLicense = this.createElement("div");
      coreLicense.style.display = "none";
      body.appendChild(home);
      body.appendChild(license);
      body.appendChild(retroarch);
      body.appendChild(coreLicense);

      home.innerText = "EmulatorJS v" + this.ejs_version;
      home.appendChild(this.createElement("br"));
      home.appendChild(this.createElement("br"));

      home.classList.add("ejs_context_menu_tab");
      license.classList.add("ejs_context_menu_tab");
      retroarch.classList.add("ejs_context_menu_tab");
      coreLicense.classList.add("ejs_context_menu_tab");

      this.createLink(
        home,
        "https://github.com/EmulatorJS/EmulatorJS",
        "View on GitHub",
        true,
      );

      this.createLink(
        home,
        "https://discord.gg/6akryGkETU",
        "Join the discord",
        true,
      );

      const info = this.createElement("div");

      this.createLink(info, "https://emulatorjs.org", "EmulatorJS");
      // I do not like using innerHTML, though this should be "safe"
      info.innerHTML += " is powered by ";
      this.createLink(
        info,
        "https://github.com/libretro/RetroArch/",
        "RetroArch",
      );
      if (this.repository && this.coreName) {
        info.innerHTML += ". This core is powered by ";
        this.createLink(info, this.repository, this.coreName);
        info.innerHTML += ".";
      } else {
        info.innerHTML += ".";
      }
      home.appendChild(info);

      home.appendChild(this.createElement("br"));
      menu.appendChild(parent);
      let current = home;
      const setElem = (element, li) => {
        if (current === element) return;
        if (current) {
          current.style.display = "none";
        }
        let activeLi = li.parentElement.querySelector(
          ".ejs_active_list_element",
        );
        if (activeLi) {
          activeLi.classList.remove("ejs_active_list_element");
        }
        li.classList.add("ejs_active_list_element");
        current = element;
        element.style.display = "";
      };
      addButton("Home", false, (li) => {
        setElem(home, li);
      }).classList.add("ejs_active_list_element");
      addButton("EmulatorJS License", false, (li) => {
        setElem(license, li);
      });
      addButton("RetroArch License", false, (li) => {
        setElem(retroarch, li);
      });
      if (this.coreName && this.license) {
        addButton(this.coreName + " License", false, (li) => {
          setElem(coreLicense, li);
        });
        coreLicense.innerText = this.license;
      }
      //Todo - Contributors.

      retroarch.innerText =
        this.localization("This project is powered by") + " ";
      const a = this.createElement("a");
      a.href = "https://github.com/libretro/RetroArch";
      a.target = "_blank";
      a.innerText = "RetroArch";
      retroarch.appendChild(a);
      const licenseLink = this.createElement("a");
      licenseLink.target = "_blank";
      licenseLink.href =
        "https://github.com/libretro/RetroArch/blob/master/COPYING";
      licenseLink.innerText = this.localization(
        "View the RetroArch license here",
      );
      a.appendChild(this.createElement("br"));
      a.appendChild(licenseLink);

      license.innerText =
        '                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers\' and authors\' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users\' and\nauthors\' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users\' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  "This License" refers to version 3 of the GNU General Public License.\n\n  "Copyright" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  "The Program" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as "you".  "Licensees" and\n"recipients" may be individuals or organizations.\n\n  To "modify" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a "modified version" of the\nearlier work or a work "based on" the earlier work.\n\n  A "covered work" means either the unmodified Program or a work based\non the Program.\n\n  To "propagate" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To "convey" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays "Appropriate Legal Notices"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The "source code" for a work means the preferred form of the work\nfor making modifications to it.  "Object code" means any non-source\nform of a work.\n\n  A "Standard Interface" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The "System Libraries" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n"Major Component", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The "Corresponding Source" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work\'s\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users\' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work\'s\nusers, your or third parties\' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program\'s source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    "keep intact all notices".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n"aggregate" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation\'s users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A "User Product" is either (1) a "consumer product", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, "normally used" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  "Installation Information" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  "Additional permissions" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered "further\nrestrictions" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An "entity transaction" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party\'s predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A "contributor" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor\'s "contributor version".\n\n  A contributor\'s "essential patent claims" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, "control" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor\'s essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a "patent license" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To "grant" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  "Knowingly relying" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient\'s use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is "discriminatory" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others\' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License "or any later version" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy\'s\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe "copyright" line and a pointer to where the full notice is found.\n\n    EmulatorJS: RetroArch on the web\n    Copyright (C) 2022-2024  Ethan O\'Brien\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    EmulatorJS  Copyright (C) 2023-2025  Ethan O\'Brien\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w\'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c\' for details.\n\nThe hypothetical commands `show w\' and `show c\' should show the appropriate\nparts of the General Public License.  Of course, your program\'s commands\nmight be different; for a GUI interface, you would use an "about box".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a "copyright disclaimer" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>.\n';
    });

    if (this.config.buttonOpts) {
      if (this.config.buttonOpts.screenshot.visible === false)
        screenshot.setAttribute("hidden", "");
      if (this.config.buttonOpts.screenRecord.visible === false)
        startScreenRecording.setAttribute("hidden", "");
      if (this.config.buttonOpts.quickSave.visible === false)
        qSave.setAttribute("hidden", "");
      if (this.config.buttonOpts.quickLoad.visible === false)
        qLoad.setAttribute("hidden", "");
    }

    this.elements.contextmenu.appendChild(parent);

    this.elements.parent.appendChild(this.elements.contextmenu);
  }
  closePopup() {
    if (this.currentPopup !== null) {
      try {
        this.currentPopup.remove();
      } catch (e) {}
      this.currentPopup = null;
    }
  }
  //creates a full box popup.
  createPopup(popupTitle, buttons, hidden) {
    if (!hidden) this.closePopup();
    const popup = this.createElement("div");
    popup.classList.add("ejs_popup_container");
    this.elements.parent.appendChild(popup);
    const title = this.createElement("h4");
    title.innerText = this.localization(popupTitle);
    const main = this.createElement("div");
    main.classList.add("ejs_popup_body");

    popup.appendChild(title);
    popup.appendChild(main);

    const padding = this.createElement("div");
    padding.style["padding-top"] = "10px";
    popup.appendChild(padding);

    for (let k in buttons) {
      const button = this.createElement("a");
      if (buttons[k] instanceof Function) {
        button.addEventListener("click", (e) => {
          buttons[k]();
          e.preventDefault();
        });
      }
      button.classList.add("ejs_button");
      button.innerText = this.localization(k);
      popup.appendChild(button);
    }
    if (!hidden) {
      this.currentPopup = popup;
    } else {
      popup.style.display = "none";
    }

    return main;
  }
  selectFile() {
    return new Promise((resolve, reject) => {
      const file = this.createElement("input");
      file.type = "file";
      this.addEventListener(file, "change", (e) => {
        resolve(e.target.files[0]);
      });
      file.click();
    });
  }
  isPopupOpen() {
    return (
      (this.cheatMenu && this.cheatMenu.style.display !== "none") ||
      // (this.netplayMenu && this.netplayMenu.style.display !== "none") ||
      // Testing replacement for modular netplayUI functionality
      (this.netplayMenu && this.netplayMenu.isVisible()) ||
      (this.controlMenu && this.controlMenu.style.display !== "none") ||
      this.currentPopup !== null
    );
  }
  isChild(first, second) {
    if (!first || !second) return false;
    const adown = first.nodeType === 9 ? first.documentElement : first;

    if (first === second) return true;

    if (adown.contains) {
      return adown.contains(second);
    }

    return (
      first.compareDocumentPosition &&
      first.compareDocumentPosition(second) & 16
    );
  }
  createBottomMenuBar() {
    this.elements.menu = this.createElement("div");

    //prevent weird glitch on some devices
    this.elements.menu.style.opacity = 0;
    this.on("start", (e) => {
      this.elements.menu.style.opacity = "";
    });
    this.elements.menu.classList.add("ejs_menu_bar");
    this.elements.menu.classList.add("ejs_menu_bar_hidden");

    let timeout = null;
    let ignoreEvents = false;
    const hide = () => {
      if (this.paused || this.settingsMenuOpen || this.disksMenuOpen) return;
      this.elements.menu.classList.add("ejs_menu_bar_hidden");
    };

    const show = () => {
      clearTimeout(timeout);
      timeout = setTimeout(hide, 3000);
      this.elements.menu.classList.remove("ejs_menu_bar_hidden");
    };

    this.menu = {
      close: () => {
        clearTimeout(timeout);
        this.elements.menu.classList.add("ejs_menu_bar_hidden");
      },
      open: (force) => {
        if (!this.started && force !== true) return;
        clearTimeout(timeout);
        if (force !== true) timeout = setTimeout(hide, 3000);
        this.elements.menu.classList.remove("ejs_menu_bar_hidden");
      },
      toggle: () => {
        if (!this.started) return;
        clearTimeout(timeout);
        if (this.elements.menu.classList.contains("ejs_menu_bar_hidden")) {
          timeout = setTimeout(hide, 3000);
        }
        this.elements.menu.classList.toggle("ejs_menu_bar_hidden");
      },
    };

    this.createBottomMenuBarListeners = () => {
      const clickListener = (e) => {
        if (e.pointerType === "touch") return;
        if (
          !this.started ||
          ignoreEvents ||
          document.pointerLockElement === this.canvas
        )
          return;
        if (this.isPopupOpen()) return;
        show();
      };
      const mouseListener = (e) => {
        if (
          !this.started ||
          ignoreEvents ||
          document.pointerLockElement === this.canvas
        )
          return;
        if (this.isPopupOpen()) return;
        const deltaX = e.movementX;
        const deltaY = e.movementY;
        const threshold = this.elements.menu.offsetHeight + 30;
        const mouseY = e.clientY;

        if (mouseY >= window.innerHeight - threshold) {
          show();
          return;
        }
        let angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
        if (angle < 0) angle += 360;
        if (angle < 85 || angle > 95) return;
        show();
      };
      if (this.menu.mousemoveListener)
        this.removeEventListener(this.menu.mousemoveListener);

      if (
        (this.preGetSetting("menubarBehavior") || "downward") === "downward"
      ) {
        this.menu.mousemoveListener = this.addEventListener(
          this.elements.parent,
          "mousemove",
          mouseListener,
        );
      } else {
        this.menu.mousemoveListener = this.addEventListener(
          this.elements.parent,
          "mousemove",
          clickListener,
        );
      }

      this.addEventListener(this.elements.parent, "click", clickListener);
    };
    this.createBottomMenuBarListeners();

    this.elements.parent.appendChild(this.elements.menu);

    let tmout;
    this.addEventListener(this.elements.parent, "mousedown touchstart", (e) => {
      if (
        this.isChild(this.elements.menu, e.target) ||
        this.isChild(this.elements.menuToggle, e.target)
      )
        return;
      if (
        !this.started ||
        this.elements.menu.classList.contains("ejs_menu_bar_hidden") ||
        this.isPopupOpen()
      )
        return;
      const width = this.elements.parent.getBoundingClientRect().width;
      if (width > 575) return;
      clearTimeout(tmout);
      tmout = setTimeout(() => {
        ignoreEvents = false;
      }, 2000);
      ignoreEvents = true;
      this.menu.close();
    });

    let paddingSet = false;
    //Now add buttons
    const addButton = (buttonConfig, callback, element, both) => {
      const button = this.createElement("button");
      button.type = "button";
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("role", "presentation");
      svg.setAttribute("focusable", "false");
      svg.innerHTML = buttonConfig.icon;
      const text = this.createElement("span");
      text.innerText = this.localization(buttonConfig.displayName);
      if (paddingSet) text.classList.add("ejs_menu_text_right");
      text.classList.add("ejs_menu_text");

      button.classList.add("ejs_menu_button");
      button.appendChild(svg);
      button.appendChild(text);
      if (element) {
        element.appendChild(button);
      } else {
        this.elements.menu.appendChild(button);
      }
      if (callback instanceof Function) {
        this.addEventListener(button, "click", callback);
      }

      if (buttonConfig.callback instanceof Function) {
        this.addEventListener(button, "click", buttonConfig.callback);
      }
      return both ? [button, svg, text] : button;
    };

    const restartButton = addButton(this.config.buttonOpts.restart, () => {
      if (this.isNetplay && this.netplay.owner) {
        this.gameManager.restart();
        this.netplay.reset();
        this.netplay.sendMessage({ restart: true });
        this.play();
      } else if (!this.isNetplay) {
        this.gameManager.restart();
      }
    });
    const pauseButton = addButton(this.config.buttonOpts.pause, () => {
      if (this.isNetplay && this.netplay.owner) {
        this.pause();
        this.gameManager.saveSaveFiles();
        this.netplay.sendMessage({ pause: true });
        // Also broadcast a system message to spectators.
        try {
          if (this.netplay.socket && this.netplay.socket.connected) {
            this.netplay.socket.emit("netplay-host-paused", {});
          }
        } catch (e) {
          // ignore
        }
      } else if (!this.isNetplay) {
        this.pause();
      }
    });
    const playButton = addButton(this.config.buttonOpts.play, () => {
      if (this.isNetplay && this.netplay.owner) {
        this.play();
        this.netplay.sendMessage({ play: true });
        try {
          if (this.netplay.socket && this.netplay.socket.connected) {
            this.netplay.socket.emit("netplay-host-resumed", {});
          }
        } catch (e) {
          // ignore
        }
      } else if (!this.isNetplay) {
        this.play();
      }
    });
    playButton.style.display = "none";
    this.togglePlaying = (dontUpdate) => {
      this.paused = !this.paused;
      if (!dontUpdate) {
        if (this.paused) {
          pauseButton.style.display = "none";
          playButton.style.display = "";
        } else {
          pauseButton.style.display = "";
          playButton.style.display = "none";
        }
      }
      this.gameManager.toggleMainLoop(this.paused ? 0 : 1);

      // Notify netplay spectators when host pauses/resumes.
      // This is separate from the P2P input channel.
      if (
        this.isNetplay &&
        this.netplay &&
        this.netplay.owner &&
        this.netplay.socket &&
        this.netplay.socket.connected
      ) {
        try {
          this.netplay.socket.emit(
            this.paused ? "netplay-host-paused" : "netplay-host-resumed",
            {},
          );
        } catch (e) {
          // ignore
        }
      }

      // In SFU netplay, pausing can cause some browsers to stop producing frames
      // from a canvas capture track. On resume, re-produce the SFU video track
      // from a stable capture source.
      if (
        !this.paused &&
        this.isNetplay &&
        this.netplay &&
        this.netplay.owner &&
        this.netplay.useSFU
      ) {
        if (typeof this.netplayReproduceHostVideoToSFU === "function") {
          setTimeout(() => {
            try {
              this.netplayReproduceHostVideoToSFU("resume");
            } catch (e) {
              // ignore
            }
          }, 0);
        }
      }

      //I now realize its not easy to pause it while the cursor is locked, just in case I guess
      if (this.enableMouseLock) {
        if (this.canvas.exitPointerLock) {
          this.canvas.exitPointerLock();
        } else if (this.canvas.mozExitPointerLock) {
          this.canvas.mozExitPointerLock();
        }
      }
    };
    this.play = (dontUpdate) => {
      if (this.paused) this.togglePlaying(dontUpdate);
    };
    this.pause = (dontUpdate) => {
      if (!this.paused) this.togglePlaying(dontUpdate);
    };

    let stateUrl;
    const saveState = addButton(this.config.buttonOpts.saveState, async () => {
      let state;
      try {
        state = this.gameManager.getState();
      } catch (e) {
        this.displayMessage(this.localization("FAILED TO SAVE STATE"));
        return;
      }
      const { screenshot, format } = await this.takeScreenshot(
        this.capture.photo.source,
        this.capture.photo.format,
        this.capture.photo.upscale,
      );
      const called = this.callEvent("saveState", {
        screenshot: screenshot,
        format: format,
        state: state,
      });
      if (called > 0) return;
      if (stateUrl) URL.revokeObjectURL(stateUrl);
      if (
        this.getSettingValue("save-state-location") === "browser" &&
        this.saveInBrowserSupported()
      ) {
        this.storage.states.put(this.getBaseFileName() + ".state", state);
        this.displayMessage(this.localization("SAVED STATE TO BROWSER"));
      } else {
        const blob = new Blob([state]);
        stateUrl = URL.createObjectURL(blob);
        const a = this.createElement("a");
        a.href = stateUrl;
        a.download = this.getBaseFileName() + ".state";
        a.click();
      }
    });
    const loadState = addButton(this.config.buttonOpts.loadState, async () => {
      const called = this.callEvent("loadState");
      if (called > 0) return;
      if (
        this.getSettingValue("save-state-location") === "browser" &&
        this.saveInBrowserSupported()
      ) {
        this.storage.states.get(this.getBaseFileName() + ".state").then((e) => {
          this.gameManager.loadState(e);
          this.displayMessage(this.localization("LOADED STATE FROM BROWSER"));
        });
      } else {
        const file = await this.selectFile();
        const state = new Uint8Array(await file.arrayBuffer());
        this.gameManager.loadState(state);
      }
    });
    const controlMenu = addButton(this.config.buttonOpts.gamepad, () => {
      if (this.controlMenu) this.controlMenu.style.display = "";
    });
    const cheatMenu = addButton(this.config.buttonOpts.cheat, () => {
      if (this.cheatMenu) this.cheatMenu.style.display = "";
    });

    const cache = addButton(this.config.buttonOpts.cacheManager, () => {
      this.openCacheMenu();
    });

    if (this.config.disableDatabases) cache.style.display = "none";

    let savUrl;

    const saveSavFiles = addButton(
      this.config.buttonOpts.saveSavFiles,
      async () => {
        const file = await this.gameManager.getSaveFile();
        const { screenshot, format } = await this.takeScreenshot(
          this.capture.photo.source,
          this.capture.photo.format,
          this.capture.photo.upscale,
        );
        const called = this.callEvent("saveSave", {
          screenshot: screenshot,
          format: format,
          save: file,
        });
        if (called > 0) return;
        const blob = new Blob([file]);
        savUrl = URL.createObjectURL(blob);
        const a = this.createElement("a");
        a.href = savUrl;
        a.download = this.gameManager.getSaveFilePath().split("/").pop();
        a.click();
      },
    );
    const loadSavFiles = addButton(
      this.config.buttonOpts.loadSavFiles,
      async () => {
        const called = this.callEvent("loadSave");
        if (called > 0) return;
        const file = await this.selectFile();
        const sav = new Uint8Array(await file.arrayBuffer());
        const path = this.gameManager.getSaveFilePath();
        const paths = path.split("/");
        let cp = "";
        for (let i = 0; i < paths.length - 1; i++) {
          if (paths[i] === "") continue;
          cp += "/" + paths[i];
          if (!this.gameManager.FS.analyzePath(cp).exists)
            this.gameManager.FS.mkdir(cp);
        }
        if (this.gameManager.FS.analyzePath(path).exists)
          this.gameManager.FS.unlink(path);
        this.gameManager.FS.writeFile(path, sav);
        this.gameManager.loadSaveFiles();
      },
    );
    const netplay = addButton(this.config.buttonOpts.netplay, async () => {
      this.netplayMenu.createNetplayMenu();
    });
    // Ensure the netplay button is visible by default (workaround for styling issues)
    try {
      if (netplay && netplay.style) netplay.style.display = "";
    } catch (e) {}

    // add custom buttons
    // get all elements from this.config.buttonOpts with custom: true
    if (this.config.buttonOpts) {
      for (const [key, value] of Object.entries(this.config.buttonOpts)) {
        if (value.custom === true) {
          const customBtn = addButton(value);
        }
      }
    }

    const spacer = this.createElement("span");
    spacer.classList.add("ejs_menu_bar_spacer");
    this.elements.menu.appendChild(spacer);
    paddingSet = true;

    const volumeSettings = this.createElement("div");
    volumeSettings.classList.add("ejs_volume_parent");
    const muteButton = addButton(
      this.config.buttonOpts.mute,
      () => {
        muteButton.style.display = "none";
        unmuteButton.style.display = "";
        this.muted = true;
        this.setVolume(0);
      },
      volumeSettings,
    );
    const unmuteButton = addButton(
      this.config.buttonOpts.unmute,
      () => {
        if (this.volume === 0) this.volume = 0.5;
        muteButton.style.display = "";
        unmuteButton.style.display = "none";
        this.muted = false;
        this.setVolume(this.volume);
      },
      volumeSettings,
    );
    unmuteButton.style.display = "none";

    const volumeSlider = this.createElement("input");
    volumeSlider.setAttribute("data-range", "volume");
    volumeSlider.setAttribute("type", "range");
    volumeSlider.setAttribute("min", 0);
    volumeSlider.setAttribute("max", 1);
    volumeSlider.setAttribute("step", 0.01);
    volumeSlider.setAttribute("autocomplete", "off");
    volumeSlider.setAttribute("role", "slider");
    volumeSlider.setAttribute("aria-label", "Volume");
    volumeSlider.setAttribute("aria-valuemin", 0);
    volumeSlider.setAttribute("aria-valuemax", 100);

    this.setVolume = (volume) => {
      this.saveSettings();
      this.muted = volume === 0;
      volumeSlider.value = volume;
      volumeSlider.setAttribute("aria-valuenow", volume * 100);
      volumeSlider.setAttribute(
        "aria-valuetext",
        (volume * 100).toFixed(1) + "%",
      );
      volumeSlider.setAttribute(
        "style",
        "--value: " +
          volume * 100 +
          "%;margin-left: 5px;position: relative;z-index: 2;",
      );
      if (
        this.Module.AL &&
        this.Module.AL.currentCtx &&
        this.Module.AL.currentCtx.sources
      ) {
        this.Module.AL.currentCtx.sources.forEach((e) => {
          e.gain.gain.value = volume;
        });
      }
      if (!this.config.buttonOpts || this.config.buttonOpts.mute !== false) {
        unmuteButton.style.display = volume === 0 ? "" : "none";
        muteButton.style.display = volume === 0 ? "none" : "";
      }
    };

    this.addEventListener(
      volumeSlider,
      "change mousemove touchmove mousedown touchstart mouseup",
      (e) => {
        setTimeout(() => {
          const newVal = parseFloat(volumeSlider.value);
          if (newVal === 0 && this.muted) return;
          this.volume = newVal;
          this.setVolume(this.volume);
        }, 5);
      },
    );

    if (!this.config.buttonOpts || this.config.buttonOpts.volume !== false) {
      volumeSettings.appendChild(volumeSlider);
    }

    this.elements.menu.appendChild(volumeSettings);

    const contextMenuButton = addButton(
      this.config.buttonOpts.contextMenu,
      () => {
        if (this.elements.contextmenu.style.display === "none") {
          this.elements.contextmenu.style.display = "block";
          this.elements.contextmenu.style.left =
            getComputedStyle(this.elements.parent).width.split("px")[0] / 2 -
            getComputedStyle(this.elements.contextmenu).width.split("px")[0] /
              2 +
            "px";
          this.elements.contextmenu.style.top =
            getComputedStyle(this.elements.parent).height.split("px")[0] / 2 -
            getComputedStyle(this.elements.contextmenu).height.split("px")[0] /
              2 +
            "px";
          setTimeout(this.menu.close.bind(this), 20);
        } else {
          this.elements.contextmenu.style.display = "none";
        }
      },
    );

    this.diskParent = this.createElement("div");
    this.diskParent.id = "ejs_disksMenu";
    this.disksMenuOpen = false;
    const diskButton = addButton(
      this.config.buttonOpts.diskButton,
      () => {
        this.disksMenuOpen = !this.disksMenuOpen;
        diskButton[1].classList.toggle("ejs_svg_rotate", this.disksMenuOpen);
        this.disksMenu.style.display = this.disksMenuOpen ? "" : "none";
        diskButton[2].classList.toggle("ejs_disks_text", this.disksMenuOpen);
      },
      this.diskParent,
      true,
    );
    this.elements.menu.appendChild(this.diskParent);
    this.closeDisksMenu = () => {
      if (!this.disksMenu) return;
      this.disksMenuOpen = false;
      diskButton[1].classList.toggle("ejs_svg_rotate", this.disksMenuOpen);
      diskButton[2].classList.toggle("ejs_disks_text", this.disksMenuOpen);
      this.disksMenu.style.display = "none";
    };
    this.addEventListener(this.elements.parent, "mousedown touchstart", (e) => {
      if (this.isChild(this.disksMenu, e.target)) return;
      if (e.pointerType === "touch") return;
      if (e.target === diskButton[0] || e.target === diskButton[2]) return;
      this.closeDisksMenu();
    });

    this.settingParent = this.createElement("div");
    this.settingsMenuOpen = false;
    const settingButton = addButton(
      this.config.buttonOpts.settings,
      () => {
        this.settingsMenuOpen = !this.settingsMenuOpen;
        settingButton[1].classList.toggle(
          "ejs_svg_rotate",
          this.settingsMenuOpen,
        );
        this.settingsMenu.style.display = this.settingsMenuOpen ? "" : "none";
        settingButton[2].classList.toggle(
          "ejs_settings_text",
          this.settingsMenuOpen,
        );
      },
      this.settingParent,
      true,
    );
    this.elements.menu.appendChild(this.settingParent);
    this.closeSettingsMenu = () => {
      if (!this.settingsMenu) return;
      this.settingsMenuOpen = false;
      settingButton[1].classList.toggle(
        "ejs_svg_rotate",
        this.settingsMenuOpen,
      );
      settingButton[2].classList.toggle(
        "ejs_settings_text",
        this.settingsMenuOpen,
      );
      this.settingsMenu.style.display = "none";
    };
    this.addEventListener(this.elements.parent, "mousedown touchstart", (e) => {
      if (this.isChild(this.settingsMenu, e.target)) return;
      if (e.pointerType === "touch") return;
      if (e.target === settingButton[0] || e.target === settingButton[2])
        return;
      this.closeSettingsMenu();
    });

    this.addEventListener(this.canvas, "click", (e) => {
      if (e.pointerType === "touch") return;
      if (this.enableMouseLock && !this.paused) {
        if (this.canvas.requestPointerLock) {
          this.canvas.requestPointerLock();
        } else if (this.canvas.mozRequestPointerLock) {
          this.canvas.mozRequestPointerLock();
        }
        this.menu.close();
      }
    });

    const enter = addButton(this.config.buttonOpts.enterFullscreen, () => {
      this.toggleFullscreen(true);
    });
    const exit = addButton(this.config.buttonOpts.exitFullscreen, () => {
      this.toggleFullscreen(false);
    });
    exit.style.display = "none";

    this.toggleFullscreen = (fullscreen) => {
      if (fullscreen) {
        if (this.elements.parent.requestFullscreen) {
          this.elements.parent.requestFullscreen();
        } else if (this.elements.parent.mozRequestFullScreen) {
          this.elements.parent.mozRequestFullScreen();
        } else if (this.elements.parent.webkitRequestFullscreen) {
          this.elements.parent.webkitRequestFullscreen();
        } else if (this.elements.parent.msRequestFullscreen) {
          this.elements.parent.msRequestFullscreen();
        }
        exit.style.display = "";
        enter.style.display = "none";
        if (this.isMobile) {
          try {
            screen.orientation
              .lock(this.getCore(true) === "nds" ? "portrait" : "landscape")
              .catch((e) => {});
          } catch (e) {}
        }
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
        exit.style.display = "none";
        enter.style.display = "";
        if (this.isMobile) {
          try {
            screen.orientation.unlock();
          } catch (e) {}
        }
      }
    };

    let exitMenuIsOpen = false;
    const exitEmulation = addButton(
      this.config.buttonOpts.exitEmulation,
      async () => {
        if (exitMenuIsOpen) return;
        exitMenuIsOpen = true;
        const popups = this.createSubPopup();
        this.game.appendChild(popups[0]);
        popups[1].classList.add("ejs_cheat_parent");
        popups[1].style.width = "100%";
        const popup = popups[1];
        const header = this.createElement("div");
        header.classList.add("ejs_cheat_header");
        const title = this.createElement("h2");
        title.innerText = this.localization("Are you sure you want to exit?");
        title.classList.add("ejs_cheat_heading");
        const close = this.createElement("button");
        close.classList.add("ejs_cheat_close");
        header.appendChild(title);
        header.appendChild(close);
        popup.appendChild(header);
        this.addEventListener(close, "click", (e) => {
          exitMenuIsOpen = false;
          popups[0].remove();
        });
        popup.appendChild(this.createElement("br"));

        const footer = this.createElement("footer");
        const submit = this.createElement("button");
        const closeButton = this.createElement("button");
        submit.innerText = this.localization("Exit");
        closeButton.innerText = this.localization("Cancel");
        submit.classList.add("ejs_button_button");
        closeButton.classList.add("ejs_button_button");
        submit.classList.add("ejs_popup_submit");
        closeButton.classList.add("ejs_popup_submit");
        submit.style["background-color"] = "rgba(var(--ejs-primary-color),1)";
        footer.appendChild(submit);
        const span = this.createElement("span");
        span.innerText = " ";
        footer.appendChild(span);
        footer.appendChild(closeButton);
        popup.appendChild(footer);

        this.addEventListener(closeButton, "click", (e) => {
          popups[0].remove();
          exitMenuIsOpen = false;
        });

        this.addEventListener(submit, "click", (e) => {
          popups[0].remove();
          const body = this.createPopup("EmulatorJS has exited", {});
          this.callEvent("exit");
        });
        setTimeout(this.menu.close.bind(this), 20);
      },
    );

    this.addEventListener(
      document,
      "webkitfullscreenchange mozfullscreenchange fullscreenchange",
      (e) => {
        if (e.target !== this.elements.parent) return;
        if (document.fullscreenElement === null) {
          exit.style.display = "none";
          enter.style.display = "";
        } else {
          //not sure if this is possible, lets put it here anyways
          exit.style.display = "";
          enter.style.display = "none";
        }
      },
    );

    const hasFullscreen = !!(
      this.elements.parent.requestFullscreen ||
      this.elements.parent.mozRequestFullScreen ||
      this.elements.parent.webkitRequestFullscreen ||
      this.elements.parent.msRequestFullscreen
    );

    if (!hasFullscreen) {
      exit.style.display = "none";
      enter.style.display = "none";
    }

    this.elements.bottomBar = {
      playPause: [pauseButton, playButton],
      restart: [restartButton],
      settings: [settingButton],
      contextMenu: [contextMenuButton],
      fullscreen: [enter, exit],
      saveState: [saveState],
      loadState: [loadState],
      gamepad: [controlMenu],
      cheat: [cheatMenu],
      cacheManager: [cache],
      saveSavFiles: [saveSavFiles],
      loadSavFiles: [loadSavFiles],
      netplay: [netplay],
      exit: [exitEmulation],
    };

    if (this.config.buttonOpts) {
      if (this.debug) console.log(this.config.buttonOpts);
      if (this.config.buttonOpts.playPause.visible === false) {
        pauseButton.style.display = "none";
        playButton.style.display = "none";
      }
      if (
        this.config.buttonOpts.contextMenu.visible === false &&
        this.config.buttonOpts.rightClick !== false &&
        this.isMobile === false
      )
        contextMenuButton.style.display = "none";
      if (this.config.buttonOpts.restart.visible === false)
        restartButton.style.display = "none";
      if (this.config.buttonOpts.settings.visible === false)
        settingButton[0].style.display = "none";
      if (this.config.buttonOpts.fullscreen.visible === false) {
        enter.style.display = "none";
        exit.style.display = "none";
      }
      if (this.config.buttonOpts.mute.visible === false) {
        muteButton.style.display = "none";
        unmuteButton.style.display = "none";
      }
      if (this.config.buttonOpts.saveState.visible === false)
        saveState.style.display = "none";
      if (this.config.buttonOpts.loadState.visible === false)
        loadState.style.display = "none";
      if (this.config.buttonOpts.saveSavFiles.visible === false)
        saveSavFiles.style.display = "none";
      if (this.config.buttonOpts.loadSavFiles.visible === false)
        loadSavFiles.style.display = "none";
      if (this.config.buttonOpts.gamepad.visible === false)
        controlMenu.style.display = "none";
      if (this.config.buttonOpts.cheat.visible === false)
        cheatMenu.style.display = "none";
      if (this.config.buttonOpts.cacheManager.visible === false)
        cache.style.display = "none";
      if (this.config.buttonOpts.netplay.visible === false)
        netplay.style.display = "none";
      if (this.config.buttonOpts.diskButton.visible === false)
        diskButton[0].style.display = "none";
      if (this.config.buttonOpts.volumeSlider.visible === false)
        volumeSlider.style.display = "none";
      if (this.config.buttonOpts.exitEmulation.visible === false)
        exitEmulation.style.display = "none";
    }

    this.menu.failedToStart = () => {
      if (!this.config.buttonOpts) this.config.buttonOpts = {};
      this.config.buttonOpts.mute = false;

      settingButton[0].style.display = "";

      // Hide all except settings button.
      pauseButton.style.display = "none";
      playButton.style.display = "none";
      contextMenuButton.style.display = "none";
      restartButton.style.display = "none";
      enter.style.display = "none";
      exit.style.display = "none";
      muteButton.style.display = "none";
      unmuteButton.style.display = "none";
      saveState.style.display = "none";
      loadState.style.display = "none";
      saveSavFiles.style.display = "none";
      loadSavFiles.style.display = "none";
      controlMenu.style.display = "none";
      cheatMenu.style.display = "none";
      cache.style.display = "none";
      netplay.style.display = "none";
      diskButton[0].style.display = "none";
      volumeSlider.style.display = "none";
      exitEmulation.style.display = "none";

      this.elements.menu.style.opacity = "";
      this.elements.menu.style.background = "transparent";
      this.virtualGamepad.style.display = "none";
      settingButton[0].classList.add("shadow");
      this.menu.open(true);
    };
  }

  openCacheMenu() {
    (async () => {
      const list = this.createElement("table");
      const tbody = this.createElement("tbody");
      const body = this.createPopup("Cache Manager", {
        "Clear All": async () => {
          const roms = await this.storage.rom.getSizes();
          for (const k in roms) {
            await this.storage.rom.remove(k);
          }
          tbody.innerHTML = "";
        },
        Close: () => {
          this.closePopup();
        },
      });
      const roms = await this.storage.rom.getSizes();
      list.style.width = "100%";
      list.style["padding-left"] = "10px";
      list.style["text-align"] = "left";
      body.appendChild(list);
      list.appendChild(tbody);
      const getSize = function (size) {
        let i = -1;
        do {
          ((size /= 1024), i++);
        } while (size > 1024);
        return (
          Math.max(size, 0.1).toFixed(1) +
          [" kB", " MB", " GB", " TB", "PB", "EB", "ZB", "YB"][i]
        );
      };
      for (const k in roms) {
        const line = this.createElement("tr");
        const name = this.createElement("td");
        const size = this.createElement("td");
        const remove = this.createElement("td");
        remove.style.cursor = "pointer";
        name.innerText = k;
        size.innerText = getSize(roms[k]);

        const a = this.createElement("a");
        a.innerText = this.localization("Remove");
        this.addEventListener(remove, "click", () => {
          this.storage.rom.remove(k);
          line.remove();
        });
        remove.appendChild(a);

        line.appendChild(name);
        line.appendChild(size);
        line.appendChild(remove);
        tbody.appendChild(line);
      }
    })();
  }
  getControlScheme() {
    if (
      this.config.controlScheme &&
      typeof this.config.controlScheme === "string"
    ) {
      return this.config.controlScheme;
    } else {
      return this.getCore(true);
    }
  }
  createControlSettingMenu() {
    let buttonListeners = [];
    this.checkGamepadInputs = () => buttonListeners.forEach((elem) => elem());
    this.gamepadLabels = [];
    this.gamepadSelection = [];
    this.controls = JSON.parse(JSON.stringify(this.defaultControllers));
    const body = this.createPopup(
      "Control Settings",
      {
        Reset: () => {
          this.controls = JSON.parse(JSON.stringify(this.defaultControllers));
          this.setupKeys();
          this.checkGamepadInputs();
          this.saveSettings();
        },
        Clear: () => {
          this.controls = { 0: {}, 1: {}, 2: {}, 3: {} };
          this.setupKeys();
          this.checkGamepadInputs();
          this.saveSettings();
        },
        Close: () => {
          if (this.controlMenu) this.controlMenu.style.display = "none";
        },
      },
      true,
    );
    this.setupKeys();
    this.controlMenu = body.parentElement;
    body.classList.add("ejs_control_body");

    let buttons;
    if ("gb" === this.getControlScheme()) {
      buttons = [
        { id: 8, label: this.localization("A") },
        { id: 0, label: this.localization("B") },
        { id: 2, label: this.localization("SELECT") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
    } else if ("nes" === this.getControlScheme()) {
      buttons = [
        { id: 8, label: this.localization("A") },
        { id: 0, label: this.localization("B") },
        { id: 2, label: this.localization("SELECT") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
      if (this.getCore() === "nestopia") {
        buttons.push({ id: 10, label: this.localization("SWAP DISKS") });
      } else {
        buttons.push({ id: 10, label: this.localization("SWAP DISKS") });
        buttons.push({ id: 11, label: this.localization("EJECT/INSERT DISK") });
      }
    } else if ("snes" === this.getControlScheme()) {
      buttons = [
        { id: 8, label: this.localization("A") },
        { id: 0, label: this.localization("B") },
        { id: 9, label: this.localization("X") },
        { id: 1, label: this.localization("Y") },
        { id: 2, label: this.localization("SELECT") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
        { id: 10, label: this.localization("L") },
        { id: 11, label: this.localization("R") },
      ];
    } else if ("n64" === this.getControlScheme()) {
      buttons = [
        { id: 0, label: this.localization("A") },
        { id: 1, label: this.localization("B") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("D-PAD UP") },
        { id: 5, label: this.localization("D-PAD DOWN") },
        { id: 6, label: this.localization("D-PAD LEFT") },
        { id: 7, label: this.localization("D-PAD RIGHT") },
        { id: 10, label: this.localization("L") },
        { id: 11, label: this.localization("R") },
        { id: 12, label: this.localization("Z") },
        { id: 19, label: this.localization("STICK UP") },
        { id: 18, label: this.localization("STICK DOWN") },
        { id: 17, label: this.localization("STICK LEFT") },
        { id: 16, label: this.localization("STICK RIGHT") },
        { id: 23, label: this.localization("C-PAD UP") },
        { id: 22, label: this.localization("C-PAD DOWN") },
        { id: 21, label: this.localization("C-PAD LEFT") },
        { id: 20, label: this.localization("C-PAD RIGHT") },
      ];
    } else if ("gba" === this.getControlScheme()) {
      buttons = [
        { id: 8, label: this.localization("A") },
        { id: 0, label: this.localization("B") },
        { id: 10, label: this.localization("L") },
        { id: 11, label: this.localization("R") },
        { id: 2, label: this.localization("SELECT") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
    } else if ("nds" === this.getControlScheme()) {
      buttons = [
        { id: 8, label: this.localization("A") },
        { id: 0, label: this.localization("B") },
        { id: 9, label: this.localization("X") },
        { id: 1, label: this.localization("Y") },
        { id: 2, label: this.localization("SELECT") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
        { id: 10, label: this.localization("L") },
        { id: 11, label: this.localization("R") },
        { id: 14, label: this.localization("Microphone") },
      ];
    } else if ("vb" === this.getControlScheme()) {
      buttons = [
        { id: 8, label: this.localization("A") },
        { id: 0, label: this.localization("B") },
        { id: 10, label: this.localization("L") },
        { id: 11, label: this.localization("R") },
        { id: 2, label: this.localization("SELECT") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("LEFT D-PAD UP") },
        { id: 5, label: this.localization("LEFT D-PAD DOWN") },
        { id: 6, label: this.localization("LEFT D-PAD LEFT") },
        { id: 7, label: this.localization("LEFT D-PAD RIGHT") },
        { id: 19, label: this.localization("RIGHT D-PAD UP") },
        { id: 18, label: this.localization("RIGHT D-PAD DOWN") },
        { id: 17, label: this.localization("RIGHT D-PAD LEFT") },
        { id: 16, label: this.localization("RIGHT D-PAD RIGHT") },
      ];
    } else if (
      ["segaMD", "segaCD", "sega32x"].includes(this.getControlScheme())
    ) {
      buttons = [
        { id: 1, label: this.localization("A") },
        { id: 0, label: this.localization("B") },
        { id: 8, label: this.localization("C") },
        { id: 10, label: this.localization("X") },
        { id: 9, label: this.localization("Y") },
        { id: 11, label: this.localization("Z") },
        { id: 3, label: this.localization("START") },
        { id: 2, label: this.localization("MODE") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
    } else if ("segaMS" === this.getControlScheme()) {
      buttons = [
        { id: 0, label: this.localization("BUTTON 1 / START") },
        { id: 8, label: this.localization("BUTTON 2") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
    } else if ("segaGG" === this.getControlScheme()) {
      buttons = [
        { id: 0, label: this.localization("BUTTON 1") },
        { id: 8, label: this.localization("BUTTON 2") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
    } else if ("segaSaturn" === this.getControlScheme()) {
      buttons = [
        { id: 1, label: this.localization("A") },
        { id: 0, label: this.localization("B") },
        { id: 8, label: this.localization("C") },
        { id: 9, label: this.localization("X") },
        { id: 10, label: this.localization("Y") },
        { id: 11, label: this.localization("Z") },
        { id: 12, label: this.localization("L") },
        { id: 13, label: this.localization("R") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
    } else if ("3do" === this.getControlScheme()) {
      buttons = [
        { id: 1, label: this.localization("A") },
        { id: 0, label: this.localization("B") },
        { id: 8, label: this.localization("C") },
        { id: 10, label: this.localization("L") },
        { id: 11, label: this.localization("R") },
        { id: 2, label: this.localization("X") },
        { id: 3, label: this.localization("P") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
    } else if ("atari2600" === this.getControlScheme()) {
      buttons = [
        { id: 0, label: this.localization("FIRE") },
        { id: 2, label: this.localization("SELECT") },
        { id: 3, label: this.localization("RESET") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
        { id: 10, label: this.localization("LEFT DIFFICULTY A") },
        { id: 12, label: this.localization("LEFT DIFFICULTY B") },
        { id: 11, label: this.localization("RIGHT DIFFICULTY A") },
        { id: 13, label: this.localization("RIGHT DIFFICULTY B") },
        { id: 14, label: this.localization("COLOR") },
        { id: 15, label: this.localization("B/W") },
      ];
    } else if ("atari7800" === this.getControlScheme()) {
      buttons = [
        { id: 0, label: this.localization("BUTTON 1") },
        { id: 8, label: this.localization("BUTTON 2") },
        { id: 2, label: this.localization("SELECT") },
        { id: 3, label: this.localization("PAUSE") },
        { id: 9, label: this.localization("RESET") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
        { id: 10, label: this.localization("LEFT DIFFICULTY") },
        { id: 11, label: this.localization("RIGHT DIFFICULTY") },
      ];
    } else if ("lynx" === this.getControlScheme()) {
      buttons = [
        { id: 8, label: this.localization("A") },
        { id: 0, label: this.localization("B") },
        { id: 10, label: this.localization("OPTION 1") },
        { id: 11, label: this.localization("OPTION 2") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
    } else if ("jaguar" === this.getControlScheme()) {
      buttons = [
        { id: 8, label: this.localization("A") },
        { id: 0, label: this.localization("B") },
        { id: 1, label: this.localization("C") },
        { id: 2, label: this.localization("PAUSE") },
        { id: 3, label: this.localization("OPTION") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
    } else if ("pce" === this.getControlScheme()) {
      buttons = [
        { id: 8, label: this.localization("I") },
        { id: 0, label: this.localization("II") },
        { id: 2, label: this.localization("SELECT") },
        { id: 3, label: this.localization("RUN") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
    } else if ("ngp" === this.getControlScheme()) {
      buttons = [
        { id: 0, label: this.localization("A") },
        { id: 8, label: this.localization("B") },
        { id: 3, label: this.localization("OPTION") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
    } else if ("ws" === this.getControlScheme()) {
      buttons = [
        { id: 8, label: this.localization("A") },
        { id: 0, label: this.localization("B") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("X UP") },
        { id: 5, label: this.localization("X DOWN") },
        { id: 6, label: this.localization("X LEFT") },
        { id: 7, label: this.localization("X RIGHT") },
        { id: 13, label: this.localization("Y UP") },
        { id: 12, label: this.localization("Y DOWN") },
        { id: 10, label: this.localization("Y LEFT") },
        { id: 11, label: this.localization("Y RIGHT") },
      ];
    } else if ("coleco" === this.getControlScheme()) {
      buttons = [
        { id: 8, label: this.localization("LEFT BUTTON") },
        { id: 0, label: this.localization("RIGHT BUTTON") },
        { id: 9, label: this.localization("1") },
        { id: 1, label: this.localization("2") },
        { id: 11, label: this.localization("3") },
        { id: 10, label: this.localization("4") },
        { id: 13, label: this.localization("5") },
        { id: 12, label: this.localization("6") },
        { id: 15, label: this.localization("7") },
        { id: 14, label: this.localization("8") },
        { id: 2, label: this.localization("*") },
        { id: 3, label: this.localization("#") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
    } else if ("pcfx" === this.getControlScheme()) {
      buttons = [
        { id: 8, label: this.localization("I") },
        { id: 0, label: this.localization("II") },
        { id: 9, label: this.localization("III") },
        { id: 1, label: this.localization("IV") },
        { id: 10, label: this.localization("V") },
        { id: 11, label: this.localization("VI") },
        { id: 3, label: this.localization("RUN") },
        { id: 2, label: this.localization("SELECT") },
        { id: 12, label: this.localization("MODE1") },
        { id: 13, label: this.localization("MODE2") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
      ];
    } else if ("psp" === this.getControlScheme()) {
      buttons = [
        { id: 9, label: this.localization("\u25B3") }, // △
        { id: 1, label: this.localization("\u25A1") }, // □
        { id: 0, label: this.localization("\uFF58") }, // ｘ
        { id: 8, label: this.localization("\u25CB") }, // ○
        { id: 2, label: this.localization("SELECT") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
        { id: 10, label: this.localization("L") },
        { id: 11, label: this.localization("R") },
        { id: 19, label: this.localization("STICK UP") },
        { id: 18, label: this.localization("STICK DOWN") },
        { id: 17, label: this.localization("STICK LEFT") },
        { id: 16, label: this.localization("STICK RIGHT") },
      ];
    } else if ("psx" === this.getControlScheme()) {
      buttons = [
        { id: 9, label: this.localization("\u25B3") }, // △
        { id: 1, label: this.localization("\u25A1") }, // □
        { id: 0, label: this.localization("\uFF58") }, // ｘ
        { id: 8, label: this.localization("\u25CB") }, // ○
        { id: 2, label: this.localization("SELECT") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
        { id: 10, label: this.localization("L1") },
        { id: 11, label: this.localization("R1") },
        { id: 12, label: this.localization("L2") },
        { id: 13, label: this.localization("R2") },
        { id: 19, label: this.localization("L STICK UP") },
        { id: 18, label: this.localization("L STICK DOWN") },
        { id: 17, label: this.localization("L STICK LEFT") },
        { id: 16, label: this.localization("L STICK RIGHT") },
        { id: 23, label: this.localization("R STICK UP") },
        { id: 22, label: this.localization("R STICK DOWN") },
        { id: 21, label: this.localization("R STICK LEFT") },
        { id: 20, label: this.localization("R STICK RIGHT") },
      ];
    } else {
      buttons = [
        { id: 0, label: this.localization("B") },
        { id: 1, label: this.localization("Y") },
        { id: 2, label: this.localization("SELECT") },
        { id: 3, label: this.localization("START") },
        { id: 4, label: this.localization("UP") },
        { id: 5, label: this.localization("DOWN") },
        { id: 6, label: this.localization("LEFT") },
        { id: 7, label: this.localization("RIGHT") },
        { id: 8, label: this.localization("A") },
        { id: 9, label: this.localization("X") },
        { id: 10, label: this.localization("L") },
        { id: 11, label: this.localization("R") },
        { id: 12, label: this.localization("L2") },
        { id: 13, label: this.localization("R2") },
        { id: 14, label: this.localization("L3") },
        { id: 15, label: this.localization("R3") },
        { id: 19, label: this.localization("L STICK UP") },
        { id: 18, label: this.localization("L STICK DOWN") },
        { id: 17, label: this.localization("L STICK LEFT") },
        { id: 16, label: this.localization("L STICK RIGHT") },
        { id: 23, label: this.localization("R STICK UP") },
        { id: 22, label: this.localization("R STICK DOWN") },
        { id: 21, label: this.localization("R STICK LEFT") },
        { id: 20, label: this.localization("R STICK RIGHT") },
      ];
    }
    if (["arcade", "mame"].includes(this.getControlScheme())) {
      for (const buttonIdx in buttons) {
        if (buttons[buttonIdx].id === 2) {
          buttons[buttonIdx].label = this.localization("INSERT COIN");
        }
      }
    }
    buttons.push(
      { id: 24, label: this.localization("QUICK SAVE STATE") },
      { id: 25, label: this.localization("QUICK LOAD STATE") },
      { id: 26, label: this.localization("CHANGE STATE SLOT") },
      { id: 27, label: this.localization("FAST FORWARD") },
      { id: 29, label: this.localization("SLOW MOTION") },
      { id: 28, label: this.localization("REWIND") },
    );
    let nums = [];
    for (let i = 0; i < buttons.length; i++) {
      nums.push(buttons[i].id);
    }
    for (let i = 0; i < 30; i++) {
      if (!nums.includes(i)) {
        delete this.defaultControllers[0][i];
        delete this.defaultControllers[1][i];
        delete this.defaultControllers[2][i];
        delete this.defaultControllers[3][i];
        delete this.controls[0][i];
        delete this.controls[1][i];
        delete this.controls[2][i];
        delete this.controls[3][i];
      }
    }

    //if (_this.statesSupported === false) {
    //    delete buttons[24];
    //    delete buttons[25];
    //    delete buttons[26];
    //}
    let selectedPlayer;
    let players = [];
    let playerDivs = [];

    const playerSelect = this.createElement("ul");
    playerSelect.classList.add("ejs_control_player_bar");
    for (let i = 1; i < 5; i++) {
      const playerContainer = this.createElement("li");
      playerContainer.classList.add("tabs-title");
      playerContainer.setAttribute("role", "presentation");
      const player = this.createElement("a");
      player.innerText = this.localization("Player") + " " + i;
      player.setAttribute("role", "tab");
      player.setAttribute("aria-controls", "controls-" + (i - 1));
      player.setAttribute("aria-selected", "false");
      player.id = "controls-" + (i - 1) + "-label";
      this.addEventListener(player, "click", (e) => {
        e.preventDefault();
        players[selectedPlayer].classList.remove("ejs_control_selected");
        playerDivs[selectedPlayer].setAttribute("hidden", "");
        selectedPlayer = i - 1;
        players[i - 1].classList.add("ejs_control_selected");
        playerDivs[i - 1].removeAttribute("hidden");
      });
      playerContainer.appendChild(player);
      playerSelect.appendChild(playerContainer);
      players.push(playerContainer);
    }
    body.appendChild(playerSelect);

    const controls = this.createElement("div");
    for (let i = 0; i < 4; i++) {
      if (!this.controls[i]) this.controls[i] = {};
      const player = this.createElement("div");
      const playerTitle = this.createElement("div");

      const gamepadTitle = this.createElement("div");
      gamepadTitle.innerText = this.localization("Connected Gamepad") + ": ";

      const gamepadName = this.createElement("select");
      gamepadName.classList.add("ejs_gamepad_dropdown");
      gamepadName.setAttribute("title", "gamepad-" + i);
      gamepadName.setAttribute("index", i);
      this.gamepadLabels.push(gamepadName);
      this.gamepadSelection.push("");
      this.addEventListener(gamepadName, "change", (e) => {
        const controller = e.target.value;
        const player = parseInt(e.target.getAttribute("index"));
        if (controller === "notconnected") {
          this.gamepadSelection[player] = "";
        } else {
          for (let i = 0; i < this.gamepadSelection.length; i++) {
            if (player === i) continue;
            if (this.gamepadSelection[i] === controller) {
              this.gamepadSelection[i] = "";
            }
          }
          this.gamepadSelection[player] = controller;
          this.updateGamepadLabels();
        }
      });
      const def = this.createElement("option");
      def.setAttribute("value", "notconnected");
      def.innerText = "Not Connected";
      gamepadName.appendChild(def);
      gamepadTitle.appendChild(gamepadName);
      gamepadTitle.classList.add("ejs_gamepad_section");

      const leftPadding = this.createElement("div");
      leftPadding.style = "width:25%;float:left;";
      leftPadding.innerHTML = "&nbsp;";

      const aboutParent = this.createElement("div");
      aboutParent.style = "font-size:12px;width:50%;float:left;";
      const gamepad = this.createElement("div");
      gamepad.style = "text-align:center;width:50%;float:left;";
      gamepad.innerText = this.localization("Gamepad");
      aboutParent.appendChild(gamepad);
      const keyboard = this.createElement("div");
      keyboard.style = "text-align:center;width:50%;float:left;";
      keyboard.innerText = this.localization("Keyboard");
      aboutParent.appendChild(keyboard);

      const headingPadding = this.createElement("div");
      headingPadding.style = "clear:both;";

      playerTitle.appendChild(gamepadTitle);
      playerTitle.appendChild(leftPadding);
      playerTitle.appendChild(aboutParent);

      if ((this.touch || this.hasTouchScreen) && i === 0) {
        const vgp = this.createElement("div");
        vgp.style =
          "width:25%;float:right;clear:none;padding:0;font-size: 11px;padding-left: 2.25rem;";
        vgp.classList.add("ejs_control_row");
        vgp.classList.add("ejs_cheat_row");
        const input = this.createElement("input");
        input.type = "checkbox";
        input.checked = true;
        input.value = "o";
        input.id = "ejs_vp";
        vgp.appendChild(input);
        const label = this.createElement("label");
        label.for = "ejs_vp";
        label.innerText = "Virtual Gamepad";
        vgp.appendChild(label);
        label.addEventListener("click", (e) => {
          input.checked = !input.checked;
          this.changeSettingOption(
            "virtual-gamepad",
            input.checked ? "enabled" : "disabled",
          );
        });
        this.on("start", (e) => {
          if (this.getSettingValue("virtual-gamepad") === "disabled") {
            input.checked = false;
          }
        });
        playerTitle.appendChild(vgp);
      }

      playerTitle.appendChild(headingPadding);

      player.appendChild(playerTitle);

      for (const buttonIdx in buttons) {
        const k = buttons[buttonIdx].id;
        const controlLabel = buttons[buttonIdx].label;

        const buttonText = this.createElement("div");
        buttonText.setAttribute("data-id", k);
        buttonText.setAttribute("data-index", i);
        buttonText.setAttribute("data-label", controlLabel);
        buttonText.style = "margin-bottom:10px;";
        buttonText.classList.add("ejs_control_bar");

        const title = this.createElement("div");
        title.style = "width:25%;float:left;font-size:12px;";
        const label = this.createElement("label");
        label.innerText = controlLabel + ":";
        title.appendChild(label);

        const textBoxes = this.createElement("div");
        textBoxes.style = "width:50%;float:left;";

        const textBox1Parent = this.createElement("div");
        textBox1Parent.style = "width:50%;float:left;padding: 0 5px;";
        const textBox1 = this.createElement("input");
        textBox1.style = "text-align:center;height:25px;width: 100%;";
        textBox1.type = "text";
        textBox1.setAttribute("readonly", "");
        textBox1.setAttribute("placeholder", "");
        textBox1Parent.appendChild(textBox1);

        const textBox2Parent = this.createElement("div");
        textBox2Parent.style = "width:50%;float:left;padding: 0 5px;";
        const textBox2 = this.createElement("input");
        textBox2.style = "text-align:center;height:25px;width: 100%;";
        textBox2.type = "text";
        textBox2.setAttribute("readonly", "");
        textBox2.setAttribute("placeholder", "");
        textBox2Parent.appendChild(textBox2);

        buttonListeners.push(() => {
          textBox2.value = "";
          textBox1.value = "";
          if (this.controls[i][k] && this.controls[i][k].value !== undefined) {
            let value = this.keyMap[this.controls[i][k].value];
            value = this.localization(value);
            textBox2.value = value;
          }
          if (
            this.controls[i][k] &&
            this.controls[i][k].value2 !== undefined &&
            this.controls[i][k].value2 !== ""
          ) {
            let value2 = this.controls[i][k].value2.toString();
            if (value2.includes(":")) {
              value2 = value2.split(":");
              value2 =
                this.localization(value2[0]) +
                ":" +
                this.localization(value2[1]);
            } else if (!isNaN(value2)) {
              value2 =
                this.localization("BUTTON") + " " + this.localization(value2);
            } else {
              value2 = this.localization(value2);
            }
            textBox1.value = value2;
          }
        });

        if (this.controls[i][k] && this.controls[i][k].value) {
          let value = this.keyMap[this.controls[i][k].value];
          value = this.localization(value);
          textBox2.value = value;
        }
        if (this.controls[i][k] && this.controls[i][k].value2) {
          let value2 = this.controls[i][k].value2.toString();
          if (value2.includes(":")) {
            value2 = value2.split(":");
            value2 =
              this.localization(value2[0]) + ":" + this.localization(value2[1]);
          } else if (!isNaN(value2)) {
            value2 =
              this.localization("BUTTON") + " " + this.localization(value2);
          } else {
            value2 = this.localization(value2);
          }
          textBox1.value = value2;
        }

        textBoxes.appendChild(textBox1Parent);
        textBoxes.appendChild(textBox2Parent);

        const padding = this.createElement("div");
        padding.style = "clear:both;";
        textBoxes.appendChild(padding);

        const setButton = this.createElement("div");
        setButton.style = "width:25%;float:left;";
        const button = this.createElement("a");
        button.classList.add("ejs_control_set_button");
        button.innerText = this.localization("Set");
        setButton.appendChild(button);

        const padding2 = this.createElement("div");
        padding2.style = "clear:both;";

        buttonText.appendChild(title);
        buttonText.appendChild(textBoxes);
        buttonText.appendChild(setButton);
        buttonText.appendChild(padding2);

        player.appendChild(buttonText);

        this.addEventListener(buttonText, "mousedown", (e) => {
          e.preventDefault();
          this.controlPopup.parentElement.parentElement.removeAttribute(
            "hidden",
          );
          this.controlPopup.innerText =
            "[ " + controlLabel + " ]\n" + this.localization("Press Keyboard");
          this.controlPopup.setAttribute("button-num", k);
          this.controlPopup.setAttribute("player-num", i);
        });
      }
      controls.appendChild(player);
      player.setAttribute("hidden", "");
      playerDivs.push(player);
    }
    body.appendChild(controls);

    selectedPlayer = 0;
    players[0].classList.add("ejs_control_selected");
    playerDivs[0].removeAttribute("hidden");

    const popup = this.createElement("div");
    popup.classList.add("ejs_popup_container");
    const popupMsg = this.createElement("div");
    this.addEventListener(popup, "mousedown click touchstart", (e) => {
      if (this.isChild(popupMsg, e.target)) return;
      this.controlPopup.parentElement.parentElement.setAttribute("hidden", "");
    });
    const btn = this.createElement("a");
    btn.classList.add("ejs_control_set_button");
    btn.innerText = this.localization("Clear");
    this.addEventListener(btn, "mousedown click touchstart", (e) => {
      const num = this.controlPopup.getAttribute("button-num");
      const player = this.controlPopup.getAttribute("player-num");
      if (!this.controls[player][num]) {
        this.controls[player][num] = {};
      }
      this.controls[player][num].value = 0;
      this.controls[player][num].value2 = "";
      this.controlPopup.parentElement.parentElement.setAttribute("hidden", "");
      this.checkGamepadInputs();
      this.saveSettings();
    });
    popupMsg.classList.add("ejs_popup_box");
    popupMsg.innerText = "";
    popup.setAttribute("hidden", "");
    const popMsg = this.createElement("div");
    this.controlPopup = popMsg;
    popup.appendChild(popupMsg);
    popupMsg.appendChild(popMsg);
    popupMsg.appendChild(this.createElement("br"));
    popupMsg.appendChild(btn);
    this.controlMenu.appendChild(popup);
  }
  initControlVars() {
    this.defaultControllers = {
      0: {
        0: {
          value: "x",
          value2: "BUTTON_2",
        },
        1: {
          value: "s",
          value2: "BUTTON_4",
        },
        2: {
          value: "v",
          value2: "SELECT",
        },
        3: {
          value: "enter",
          value2: "START",
        },
        4: {
          value: "up arrow",
          value2: "DPAD_UP",
        },
        5: {
          value: "down arrow",
          value2: "DPAD_DOWN",
        },
        6: {
          value: "left arrow",
          value2: "DPAD_LEFT",
        },
        7: {
          value: "right arrow",
          value2: "DPAD_RIGHT",
        },
        8: {
          value: "z",
          value2: "BUTTON_1",
        },
        9: {
          value: "a",
          value2: "BUTTON_3",
        },
        10: {
          value: "q",
          value2: "LEFT_TOP_SHOULDER",
        },
        11: {
          value: "e",
          value2: "RIGHT_TOP_SHOULDER",
        },
        12: {
          value: "tab",
          value2: "LEFT_BOTTOM_SHOULDER",
        },
        13: {
          value: "r",
          value2: "RIGHT_BOTTOM_SHOULDER",
        },
        14: {
          value: "",
          value2: "LEFT_STICK",
        },
        15: {
          value: "",
          value2: "RIGHT_STICK",
        },
        16: {
          value: "h",
          value2: "LEFT_STICK_X:+1",
        },
        17: {
          value: "f",
          value2: "LEFT_STICK_X:-1",
        },
        18: {
          value: "g",
          value2: "LEFT_STICK_Y:+1",
        },
        19: {
          value: "t",
          value2: "LEFT_STICK_Y:-1",
        },
        20: {
          value: "l",
          value2: "RIGHT_STICK_X:+1",
        },
        21: {
          value: "j",
          value2: "RIGHT_STICK_X:-1",
        },
        22: {
          value: "k",
          value2: "RIGHT_STICK_Y:+1",
        },
        23: {
          value: "i",
          value2: "RIGHT_STICK_Y:-1",
        },
        24: {
          value: "1",
        },
        25: {
          value: "2",
        },
        26: {
          value: "3",
        },
        27: {},
        28: {},
        29: {},
      },
      1: {},
      2: {},
      3: {},
    };
    this.keyMap = {
      0: "",
      8: "backspace",
      9: "tab",
      13: "enter",
      16: "shift",
      17: "ctrl",
      18: "alt",
      19: "pause/break",
      20: "caps lock",
      27: "escape",
      32: "space",
      33: "page up",
      34: "page down",
      35: "end",
      36: "home",
      37: "left arrow",
      38: "up arrow",
      39: "right arrow",
      40: "down arrow",
      45: "insert",
      46: "delete",
      48: "0",
      49: "1",
      50: "2",
      51: "3",
      52: "4",
      53: "5",
      54: "6",
      55: "7",
      56: "8",
      57: "9",
      65: "a",
      66: "b",
      67: "c",
      68: "d",
      69: "e",
      70: "f",
      71: "g",
      72: "h",
      73: "i",
      74: "j",
      75: "k",
      76: "l",
      77: "m",
      78: "n",
      79: "o",
      80: "p",
      81: "q",
      82: "r",
      83: "s",
      84: "t",
      85: "u",
      86: "v",
      87: "w",
      88: "x",
      89: "y",
      90: "z",
      91: "left window key",
      92: "right window key",
      93: "select key",
      96: "numpad 0",
      97: "numpad 1",
      98: "numpad 2",
      99: "numpad 3",
      100: "numpad 4",
      101: "numpad 5",
      102: "numpad 6",
      103: "numpad 7",
      104: "numpad 8",
      105: "numpad 9",
      106: "multiply",
      107: "add",
      109: "subtract",
      110: "decimal point",
      111: "divide",
      112: "f1",
      113: "f2",
      114: "f3",
      115: "f4",
      116: "f5",
      117: "f6",
      118: "f7",
      119: "f8",
      120: "f9",
      121: "f10",
      122: "f11",
      123: "f12",
      144: "num lock",
      145: "scroll lock",
      186: "semi-colon",
      187: "equal sign",
      188: "comma",
      189: "dash",
      190: "period",
      191: "forward slash",
      192: "grave accent",
      219: "open bracket",
      220: "back slash",
      221: "close braket",
      222: "single quote",
    };
  }
  setupKeys() {
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 30; j++) {
        if (this.controls[i][j]) {
          this.controls[i][j].value = parseInt(
            this.keyLookup(this.controls[i][j].value),
          );
          if (this.controls[i][j].value === -1 && this.debug) {
            delete this.controls[i][j].value;
            if (this.debug)
              console.warn("Invalid key for control " + j + " player " + i);
          }
        }
      }
    }
  }
  keyLookup(controllerkey) {
    if (controllerkey === undefined) return 0;
    if (typeof controllerkey === "number") return controllerkey;
    controllerkey = controllerkey.toString().toLowerCase();
    const values = Object.values(this.keyMap);
    if (values.includes(controllerkey)) {
      const index = values.indexOf(controllerkey);
      return Object.keys(this.keyMap)[index];
    }
    return -1;
  }
  keyChange(e) {
    if (e.repeat) return;
    if (!this.started) return;
    if (
      this.controlPopup.parentElement.parentElement.getAttribute("hidden") ===
      null
    ) {
      const num = this.controlPopup.getAttribute("button-num");
      const player = this.controlPopup.getAttribute("player-num");
      if (!this.controls[player][num]) {
        this.controls[player][num] = {};
      }
      this.controls[player][num].value = e.keyCode;
      this.controlPopup.parentElement.parentElement.setAttribute("hidden", "");
      this.checkGamepadInputs();
      this.saveSettings();
      return;
    }
    if (
      this.settingsMenu.style.display !== "none" ||
      this.isPopupOpen() ||
      this.getSettingValue("keyboardInput") === "enabled"
    )
      return;
    e.preventDefault();
    const special = [16, 17, 18, 19, 20, 21, 22, 23];
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 30; j++) {
        if (this.controls[i][j] && this.controls[i][j].value === e.keyCode) {
          // Route through netplay.simulateInput if netplay is active
          if (
            this.netplay &&
            typeof this.netplay.simulateInput === "function"
          ) {
            this.netplay.simulateInput(
              i,
              j,
              e.type === "keyup" ? 0 : special.includes(j) ? 0x7fff : 1,
            );
          } else {
            this.gameManager.simulateInput(
              i,
              j,
              e.type === "keyup" ? 0 : special.includes(j) ? 0x7fff : 1,
            );
          }
        }
      }
    }
  }
  gamepadEvent(e) {
    if (!this.started) return;
    const gamepadIndex = this.gamepadSelection.indexOf(
      this.gamepad.gamepads[e.gamepadIndex].id +
        "_" +
        this.gamepad.gamepads[e.gamepadIndex].index,
    );
    if (gamepadIndex < 0) {
      return; // Gamepad not set anywhere
    }

    // Helper function to route input through netplay or gameManager
    const simulateInput = (playerIndex, inputIndex, value) => {
      if (this.netplay && typeof this.netplay.simulateInput === "function") {
        this.netplay.simulateInput(playerIndex, inputIndex, value);
      } else {
        this.gameManager.simulateInput(playerIndex, inputIndex, value);
      }
    };
    const value = (function (value) {
      if (value > 0.5 || value < -0.5) {
        return value > 0 ? 1 : -1;
      } else {
        return 0;
      }
    })(e.value || 0);
    if (
      this.controlPopup.parentElement.parentElement.getAttribute("hidden") ===
      null
    ) {
      if ("buttonup" === e.type || (e.type === "axischanged" && value === 0))
        return;
      const num = this.controlPopup.getAttribute("button-num");
      const player = parseInt(this.controlPopup.getAttribute("player-num"));
      if (gamepadIndex !== player) return;
      if (!this.controls[player][num]) {
        this.controls[player][num] = {};
      }
      this.controls[player][num].value2 = e.label;
      this.controlPopup.parentElement.parentElement.setAttribute("hidden", "");
      this.checkGamepadInputs();
      this.saveSettings();
      return;
    }
    if (this.settingsMenu.style.display !== "none" || this.isPopupOpen())
      return;
    const special = [16, 17, 18, 19, 20, 21, 22, 23];
    for (let i = 0; i < 4; i++) {
      if (gamepadIndex !== i) continue;
      for (let j = 0; j < 30; j++) {
        if (!this.controls[i][j] || this.controls[i][j].value2 === undefined) {
          continue;
        }
        const controlValue = this.controls[i][j].value2;

        if (
          ["buttonup", "buttondown"].includes(e.type) &&
          (controlValue === e.label || controlValue === e.index)
        ) {
          simulateInput(
            i,
            j,
            e.type === "buttonup" ? 0 : special.includes(j) ? 0x7fff : 1,
          );
        } else if (e.type === "axischanged") {
          if (
            typeof controlValue === "string" &&
            controlValue.split(":")[0] === e.axis
          ) {
            if (special.includes(j)) {
              if (j === 16 || j === 17) {
                if (e.value > 0) {
                  simulateInput(i, 16, 0x7fff * e.value);
                  simulateInput(i, 17, 0);
                } else {
                  simulateInput(i, 17, -0x7fff * e.value);
                  simulateInput(i, 16, 0);
                }
              } else if (j === 18 || j === 19) {
                if (e.value > 0) {
                  simulateInput(i, 18, 0x7fff * e.value);
                  simulateInput(i, 19, 0);
                } else {
                  simulateInput(i, 19, -0x7fff * e.value);
                  simulateInput(i, 18, 0);
                }
              } else if (j === 20 || j === 21) {
                if (e.value > 0) {
                  simulateInput(i, 20, 0x7fff * e.value);
                  simulateInput(i, 21, 0);
                } else {
                  simulateInput(i, 21, -0x7fff * e.value);
                  simulateInput(i, 20, 0);
                }
              } else if (j === 22 || j === 23) {
                if (e.value > 0) {
                  simulateInput(i, 22, 0x7fff * e.value);
                  simulateInput(i, 23, 0);
                } else {
                  simulateInput(i, 23, -0x7fff * e.value);
                  simulateInput(i, 22, 0);
                }
              }
            } else if (
              value === 0 ||
              controlValue === e.label ||
              controlValue === `${e.axis}:${value}`
            ) {
              simulateInput(i, j, value === 0 ? 0 : 1);
            }
          }
        }
      }
    }
  }
  setVirtualGamepad() {
    this.virtualGamepad = this.createElement("div");
    this.toggleVirtualGamepad = (show) => {
      this.virtualGamepad.style.display = show ? "" : "none";
    };
    this.virtualGamepad.classList.add("ejs_virtualGamepad_parent");
    this.elements.parent.appendChild(this.virtualGamepad);

    const speedControlButtons = [
      {
        type: "button",
        text: "Fast",
        id: "speed_fast",
        location: "center",
        left: -35,
        top: 50,
        fontSize: 15,
        block: true,
        input_value: 27,
      },
      {
        type: "button",
        text: "Slow",
        id: "speed_slow",
        location: "center",
        left: 95,
        top: 50,
        fontSize: 15,
        block: true,
        input_value: 29,
      },
    ];
    if (this.rewindEnabled) {
      speedControlButtons.push({
        type: "button",
        text: "Rewind",
        id: "speed_rewind",
        location: "center",
        left: 30,
        top: 50,
        fontSize: 15,
        block: true,
        input_value: 28,
      });
    }

    let info;
    if (
      this.config.VirtualGamepadSettings &&
      (function (set) {
        if (!Array.isArray(set)) {
          if (this.debug)
            console.warn(
              "Virtual gamepad settings is not array! Using default gamepad settings",
            );
          return false;
        }
        if (!set.length) {
          if (this.debug)
            console.warn(
              "Virtual gamepad settings is empty! Using default gamepad settings",
            );
          return false;
        }
        for (let i = 0; i < set.length; i++) {
          if (!set[i].type) continue;
          try {
            if (set[i].type === "zone" || set[i].type === "dpad") {
              if (!set[i].location) {
                console.warn(
                  "Missing location value for " +
                    set[i].type +
                    "! Using default gamepad settings",
                );
                return false;
              } else if (!set[i].inputValues) {
                console.warn(
                  "Missing inputValues for " +
                    set[i].type +
                    "! Using default gamepad settings",
                );
                return false;
              }
              continue;
            }
            if (!set[i].location) {
              console.warn(
                "Missing location value for button " +
                  set[i].text +
                  "! Using default gamepad settings",
              );
              return false;
            } else if (!set[i].type) {
              console.warn(
                "Missing type value for button " +
                  set[i].text +
                  "! Using default gamepad settings",
              );
              return false;
            } else if (!set[i].id.toString()) {
              console.warn(
                "Missing id value for button " +
                  set[i].text +
                  "! Using default gamepad settings",
              );
              return false;
            } else if (!set[i].input_value.toString()) {
              console.warn(
                "Missing input_value for button " +
                  set[i].text +
                  "! Using default gamepad settings",
              );
              return false;
            }
          } catch (e) {
            console.warn(
              "Error checking values! Using default gamepad settings",
            );
            return false;
          }
        }
        return true;
      })(this.config.VirtualGamepadSettings)
    ) {
      info = this.config.VirtualGamepadSettings;
    } else if ("gba" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          left: 10,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          left: 81,
          top: 40,
          bold: true,
          input_value: 8,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          top: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Start",
          id: "start",
          location: "center",
          left: 60,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
        {
          type: "button",
          text: "Select",
          id: "select",
          location: "center",
          left: -5,
          fontSize: 15,
          block: true,
          input_value: 2,
        },
        {
          type: "button",
          text: "L",
          id: "l",
          location: "left",
          left: 3,
          top: -90,
          bold: true,
          block: true,
          input_value: 10,
        },
        {
          type: "button",
          text: "R",
          id: "r",
          location: "right",
          right: 3,
          top: -90,
          bold: true,
          block: true,
          input_value: 11,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("gb" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          left: 81,
          top: 40,
          bold: true,
          input_value: 8,
        },
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          left: 10,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          top: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Start",
          id: "start",
          location: "center",
          left: 60,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
        {
          type: "button",
          text: "Select",
          id: "select",
          location: "center",
          left: -5,
          fontSize: 15,
          block: true,
          input_value: 2,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("nes" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          right: 75,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          right: 5,
          top: 70,
          bold: true,
          input_value: 8,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Start",
          id: "start",
          location: "center",
          left: 60,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
        {
          type: "button",
          text: "Select",
          id: "select",
          location: "center",
          left: -5,
          fontSize: 15,
          block: true,
          input_value: 2,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("n64" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          left: -10,
          top: 95,
          input_value: 1,
          bold: true,
        },
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          left: 40,
          top: 150,
          input_value: 0,
          bold: true,
        },
        {
          type: "zone",
          id: "stick",
          location: "left",
          left: "50%",
          top: "100%",
          joystickInput: true,
          inputValues: [16, 17, 18, 19],
        },
        {
          type: "zone",
          id: "dpad",
          location: "left",
          left: "50%",
          top: "0%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Start",
          id: "start",
          location: "center",
          left: 30,
          top: -10,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
        {
          type: "button",
          text: "L",
          id: "l",
          block: true,
          location: "top",
          left: 10,
          top: -40,
          bold: true,
          input_value: 10,
        },
        {
          type: "button",
          text: "R",
          id: "r",
          block: true,
          location: "top",
          right: 10,
          top: -40,
          bold: true,
          input_value: 11,
        },
        {
          type: "button",
          text: "Z",
          id: "z",
          block: true,
          location: "top",
          left: 10,
          bold: true,
          input_value: 12,
        },
        {
          fontSize: 20,
          type: "button",
          text: "CU",
          id: "cu",
          joystickInput: true,
          location: "right",
          left: 25,
          top: -65,
          input_value: 23,
        },
        {
          fontSize: 20,
          type: "button",
          text: "CD",
          id: "cd",
          joystickInput: true,
          location: "right",
          left: 25,
          top: 15,
          input_value: 22,
        },
        {
          fontSize: 20,
          type: "button",
          text: "CL",
          id: "cl",
          joystickInput: true,
          location: "right",
          left: -15,
          top: -25,
          input_value: 21,
        },
        {
          fontSize: 20,
          type: "button",
          text: "CR",
          id: "cr",
          joystickInput: true,
          location: "right",
          left: 65,
          top: -25,
          input_value: 20,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("nds" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "X",
          id: "x",
          location: "right",
          left: 40,
          bold: true,
          input_value: 9,
        },
        {
          type: "button",
          text: "Y",
          id: "y",
          location: "right",
          top: 40,
          bold: true,
          input_value: 1,
        },
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          left: 81,
          top: 40,
          bold: true,
          input_value: 8,
        },
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          left: 40,
          top: 80,
          bold: true,
          input_value: 0,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          top: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Start",
          id: "start",
          location: "center",
          left: 60,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
        {
          type: "button",
          text: "Select",
          id: "select",
          location: "center",
          left: -5,
          fontSize: 15,
          block: true,
          input_value: 2,
        },
        {
          type: "button",
          text: "L",
          id: "l",
          location: "left",
          left: 3,
          top: -100,
          bold: true,
          block: true,
          input_value: 10,
        },
        {
          type: "button",
          text: "R",
          id: "r",
          location: "right",
          right: 3,
          top: -100,
          bold: true,
          block: true,
          input_value: 11,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("snes" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "X",
          id: "x",
          location: "right",
          left: 40,
          bold: true,
          input_value: 9,
        },
        {
          type: "button",
          text: "Y",
          id: "y",
          location: "right",
          top: 40,
          bold: true,
          input_value: 1,
        },
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          left: 81,
          top: 40,
          bold: true,
          input_value: 8,
        },
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          left: 40,
          top: 80,
          bold: true,
          input_value: 0,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          top: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Start",
          id: "start",
          location: "center",
          left: 60,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
        {
          type: "button",
          text: "Select",
          id: "select",
          location: "center",
          left: -5,
          fontSize: 15,
          block: true,
          input_value: 2,
        },
        {
          type: "button",
          text: "L",
          id: "l",
          location: "left",
          left: 3,
          top: -100,
          bold: true,
          block: true,
          input_value: 10,
        },
        {
          type: "button",
          text: "R",
          id: "r",
          location: "right",
          right: 3,
          top: -100,
          bold: true,
          block: true,
          input_value: 11,
        },
      ];
      info.push(...speedControlButtons);
    } else if (
      ["segaMD", "segaCD", "sega32x"].includes(this.getControlScheme())
    ) {
      info = [
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          right: 145,
          top: 70,
          bold: true,
          input_value: 1,
        },
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          right: 75,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "C",
          id: "c",
          location: "right",
          right: 5,
          top: 70,
          bold: true,
          input_value: 8,
        },
        {
          type: "button",
          text: "X",
          id: "x",
          location: "right",
          right: 145,
          top: 0,
          bold: true,
          input_value: 10,
        },
        {
          type: "button",
          text: "Y",
          id: "y",
          location: "right",
          right: 75,
          top: 0,
          bold: true,
          input_value: 9,
        },
        {
          type: "button",
          text: "Z",
          id: "z",
          location: "right",
          right: 5,
          top: 0,
          bold: true,
          input_value: 11,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Mode",
          id: "mode",
          location: "center",
          left: -5,
          fontSize: 15,
          block: true,
          input_value: 2,
        },
        {
          type: "button",
          text: "Start",
          id: "start",
          location: "center",
          left: 60,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("segaMS" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "1",
          id: "button_1",
          location: "right",
          left: 10,
          top: 40,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "2",
          id: "button_2",
          location: "right",
          left: 81,
          top: 40,
          bold: true,
          input_value: 8,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
      ];
      info.push(...speedControlButtons);
    } else if ("segaGG" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "1",
          id: "button_1",
          location: "right",
          left: 10,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "2",
          id: "button_2",
          location: "right",
          left: 81,
          top: 40,
          bold: true,
          input_value: 8,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          top: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Start",
          id: "start",
          location: "center",
          left: 30,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("segaSaturn" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          right: 145,
          top: 70,
          bold: true,
          input_value: 1,
        },
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          right: 75,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "C",
          id: "c",
          location: "right",
          right: 5,
          top: 70,
          bold: true,
          input_value: 8,
        },
        {
          type: "button",
          text: "X",
          id: "x",
          location: "right",
          right: 145,
          top: 0,
          bold: true,
          input_value: 9,
        },
        {
          type: "button",
          text: "Y",
          id: "y",
          location: "right",
          right: 75,
          top: 0,
          bold: true,
          input_value: 10,
        },
        {
          type: "button",
          text: "Z",
          id: "z",
          location: "right",
          right: 5,
          top: 0,
          bold: true,
          input_value: 11,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "L",
          id: "l",
          location: "left",
          left: 3,
          top: -90,
          bold: true,
          block: true,
          input_value: 12,
        },
        {
          type: "button",
          text: "R",
          id: "r",
          location: "right",
          right: 3,
          top: -90,
          bold: true,
          block: true,
          input_value: 13,
        },
        {
          type: "button",
          text: "Start",
          id: "start",
          location: "center",
          left: 30,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("atari2600" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "",
          id: "button_1",
          location: "right",
          right: 10,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Reset",
          id: "reset",
          location: "center",
          left: 60,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
        {
          type: "button",
          text: "Select",
          id: "select",
          location: "center",
          left: -5,
          fontSize: 15,
          block: true,
          input_value: 2,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("atari7800" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "1",
          id: "button_1",
          location: "right",
          right: 75,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "2",
          id: "button_2",
          location: "right",
          right: 5,
          top: 70,
          bold: true,
          input_value: 8,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Reset",
          id: "reset",
          location: "center",
          left: -35,
          fontSize: 15,
          block: true,
          input_value: 9,
        },
        {
          type: "button",
          text: "Pause",
          id: "pause",
          location: "center",
          left: 95,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
        {
          type: "button",
          text: "Select",
          id: "select",
          location: "center",
          left: 30,
          fontSize: 15,
          block: true,
          input_value: 2,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("lynx" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "B",
          id: "button_1",
          location: "right",
          right: 75,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "A",
          id: "button_2",
          location: "right",
          right: 5,
          top: 70,
          bold: true,
          input_value: 8,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Opt 1",
          id: "option_1",
          location: "center",
          left: -35,
          fontSize: 15,
          block: true,
          input_value: 10,
        },
        {
          type: "button",
          text: "Opt 2",
          id: "option_2",
          location: "center",
          left: 95,
          fontSize: 15,
          block: true,
          input_value: 11,
        },
        {
          type: "button",
          text: "Start",
          id: "start",
          location: "center",
          left: 30,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("jaguar" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          right: 145,
          top: 70,
          bold: true,
          input_value: 8,
        },
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          right: 75,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "C",
          id: "c",
          location: "right",
          right: 5,
          top: 70,
          bold: true,
          input_value: 1,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Option",
          id: "option",
          location: "center",
          left: 60,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
        {
          type: "button",
          text: "Pause",
          id: "pause",
          location: "center",
          left: -5,
          fontSize: 15,
          block: true,
          input_value: 2,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("vb" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          right: 75,
          top: 150,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          right: 5,
          top: 150,
          bold: true,
          input_value: 8,
        },
        {
          type: "dpad",
          id: "left_dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "dpad",
          id: "right_dpad",
          location: "right",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [19, 18, 17, 16],
        },
        {
          type: "button",
          text: "L",
          id: "l",
          location: "left",
          left: 3,
          top: -90,
          bold: true,
          block: true,
          input_value: 10,
        },
        {
          type: "button",
          text: "R",
          id: "r",
          location: "right",
          right: 3,
          top: -90,
          bold: true,
          block: true,
          input_value: 11,
        },
        {
          type: "button",
          text: "Start",
          id: "start",
          location: "center",
          left: 60,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
        {
          type: "button",
          text: "Select",
          id: "select",
          location: "center",
          left: -5,
          fontSize: 15,
          block: true,
          input_value: 2,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("3do" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          right: 145,
          top: 70,
          bold: true,
          input_value: 1,
        },
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          right: 75,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "C",
          id: "c",
          location: "right",
          right: 5,
          top: 70,
          bold: true,
          input_value: 8,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "L",
          id: "l",
          location: "left",
          left: 3,
          top: -90,
          bold: true,
          block: true,
          input_value: 10,
        },
        {
          type: "button",
          text: "R",
          id: "r",
          location: "right",
          right: 3,
          top: -90,
          bold: true,
          block: true,
          input_value: 11,
        },
        {
          type: "button",
          text: "X",
          id: "x",
          location: "center",
          left: -5,
          fontSize: 15,
          block: true,
          bold: true,
          input_value: 2,
        },
        {
          type: "button",
          text: "P",
          id: "p",
          location: "center",
          left: 60,
          fontSize: 15,
          block: true,
          bold: true,
          input_value: 3,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("pce" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "II",
          id: "ii",
          location: "right",
          right: 75,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "I",
          id: "i",
          location: "right",
          right: 5,
          top: 70,
          bold: true,
          input_value: 8,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Run",
          id: "run",
          location: "center",
          left: 60,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
        {
          type: "button",
          text: "Select",
          id: "select",
          location: "center",
          left: -5,
          fontSize: 15,
          block: true,
          input_value: 2,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("ngp" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          right: 75,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          right: 5,
          top: 50,
          bold: true,
          input_value: 8,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Option",
          id: "option",
          location: "center",
          left: 30,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("ws" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          right: 75,
          top: 150,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          right: 5,
          top: 150,
          bold: true,
          input_value: 8,
        },
        {
          type: "dpad",
          id: "x_dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "dpad",
          id: "y_dpad",
          location: "right",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [13, 12, 10, 11],
        },
        {
          type: "button",
          text: "Start",
          id: "start",
          location: "center",
          left: 30,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
      ];
      info.push(...speedControlButtons);
    } else if ("coleco" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "L",
          id: "l",
          location: "right",
          left: 10,
          top: 40,
          bold: true,
          input_value: 8,
        },
        {
          type: "button",
          text: "R",
          id: "r",
          location: "right",
          left: 81,
          top: 40,
          bold: true,
          input_value: 0,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
      ];
      info.push(...speedControlButtons);
    } else if ("pcfx" === this.getControlScheme()) {
      info = [
        {
          type: "button",
          text: "I",
          id: "i",
          location: "right",
          right: 5,
          top: 70,
          bold: true,
          input_value: 8,
        },
        {
          type: "button",
          text: "II",
          id: "ii",
          location: "right",
          right: 75,
          top: 70,
          bold: true,
          input_value: 0,
        },
        {
          type: "button",
          text: "III",
          id: "iii",
          location: "right",
          right: 145,
          top: 70,
          bold: true,
          input_value: 9,
        },
        {
          type: "button",
          text: "IV",
          id: "iv",
          location: "right",
          right: 5,
          top: 0,
          bold: true,
          input_value: 1,
        },
        {
          type: "button",
          text: "V",
          id: "v",
          location: "right",
          right: 75,
          top: 0,
          bold: true,
          input_value: 10,
        },
        {
          type: "button",
          text: "VI",
          id: "vi",
          location: "right",
          right: 145,
          top: 0,
          bold: true,
          input_value: 11,
        },
        {
          type: "dpad",
          id: "dpad",
          location: "left",
          left: "50%",
          right: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Select",
          id: "select",
          location: "center",
          left: -5,
          fontSize: 15,
          block: true,
          input_value: 2,
        },
        {
          type: "button",
          text: "Run",
          id: "run",
          location: "center",
          left: 60,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
      ];
      info.push(...speedControlButtons);
    } else {
      info = [
        {
          type: "button",
          text: "Y",
          id: "y",
          location: "right",
          left: 40,
          bold: true,
          input_value: 9,
        },
        {
          type: "button",
          text: "X",
          id: "x",
          location: "right",
          top: 40,
          bold: true,
          input_value: 1,
        },
        {
          type: "button",
          text: "B",
          id: "b",
          location: "right",
          left: 81,
          top: 40,
          bold: true,
          input_value: 8,
        },
        {
          type: "button",
          text: "A",
          id: "a",
          location: "right",
          left: 40,
          top: 80,
          bold: true,
          input_value: 0,
        },
        {
          type: "zone",
          id: "dpad",
          location: "left",
          left: "50%",
          top: "50%",
          joystickInput: false,
          inputValues: [4, 5, 6, 7],
        },
        {
          type: "button",
          text: "Start",
          id: "start",
          location: "center",
          left: 60,
          fontSize: 15,
          block: true,
          input_value: 3,
        },
        {
          type: "button",
          text: "Select",
          id: "select",
          location: "center",
          left: -5,
          fontSize: 15,
          block: true,
          input_value: 2,
        },
      ];
      info.push(...speedControlButtons);
    }
    for (let i = 0; i < info.length; i++) {
      if (info[i].text) {
        info[i].text = this.localization(info[i].text);
      }
    }
    info = JSON.parse(JSON.stringify(info));

    const up = this.createElement("div");
    up.classList.add("ejs_virtualGamepad_top");
    const down = this.createElement("div");
    down.classList.add("ejs_virtualGamepad_bottom");
    const left = this.createElement("div");
    left.classList.add("ejs_virtualGamepad_left");
    const right = this.createElement("div");
    right.classList.add("ejs_virtualGamepad_right");
    const elems = { top: up, center: down, left, right };

    this.virtualGamepad.appendChild(up);
    this.virtualGamepad.appendChild(down);
    this.virtualGamepad.appendChild(left);
    this.virtualGamepad.appendChild(right);

    this.toggleVirtualGamepadLeftHanded = (enabled) => {
      left.classList.toggle("ejs_virtualGamepad_left", !enabled);
      right.classList.toggle("ejs_virtualGamepad_right", !enabled);
      left.classList.toggle("ejs_virtualGamepad_right", enabled);
      right.classList.toggle("ejs_virtualGamepad_left", enabled);
    };

    const leftHandedMode = false;
    const blockCSS =
      "height:31px;text-align:center;border:1px solid #ccc;border-radius:5px;line-height:31px;";
    const controlSchemeCls = `cs_${this.getControlScheme()}`
      .split(/\s/g)
      .join("_");

    for (let i = 0; i < info.length; i++) {
      if (info[i].type !== "button") continue;
      if (leftHandedMode && ["left", "right"].includes(info[i].location)) {
        info[i].location = info[i].location === "left" ? "right" : "left";
        const amnt = JSON.parse(JSON.stringify(info[i]));
        if (amnt.left) {
          info[i].right = amnt.left;
        }
        if (amnt.right) {
          info[i].left = amnt.right;
        }
      }
      let style = "";
      if (info[i].left) {
        style +=
          "left:" +
          info[i].left +
          (typeof info[i].left === "number" ? "px" : "") +
          ";";
      }
      if (info[i].right) {
        style +=
          "right:" +
          info[i].right +
          (typeof info[i].right === "number" ? "px" : "") +
          ";";
      }
      if (info[i].top) {
        style +=
          "top:" +
          info[i].top +
          (typeof info[i].top === "number" ? "px" : "") +
          ";";
      }
      if (!info[i].bold) {
        style += "font-weight:normal;";
      } else if (info[i].bold) {
        style += "font-weight:bold;";
      }
      info[i].fontSize = info[i].fontSize || 30;
      style += "font-size:" + info[i].fontSize + "px;";
      if (info[i].block) {
        style += blockCSS;
      }
      if (["top", "center", "left", "right"].includes(info[i].location)) {
        const button = this.createElement("div");
        button.style = style;
        button.innerText = info[i].text;
        button.classList.add("ejs_virtualGamepad_button", controlSchemeCls);
        if (info[i].id) {
          button.classList.add(`b_${info[i].id}`);
        }
        elems[info[i].location].appendChild(button);
        const value = info[i].input_new_cores || info[i].input_value;
        let downValue = info[i].joystickInput === true ? 0x7fff : 1;
        this.addEventListener(
          button,
          "touchstart touchend touchcancel",
          (e) => {
            e.preventDefault();
            if (e.type === "touchend" || e.type === "touchcancel") {
              e.target.classList.remove("ejs_virtualGamepad_button_down");
              window.setTimeout(() => {
                this.netplay && typeof this.netplay.simulateInput === "function"
                  ? this.netplay.simulateInput(0, value, 0)
                  : this.gameManager.simulateInput(0, value, 0);
              });
            } else {
              e.target.classList.add("ejs_virtualGamepad_button_down");
              this.netplay && typeof this.netplay.simulateInput === "function"
                ? this.netplay.simulateInput(0, value, downValue)
                : this.gameManager.simulateInput(0, value, downValue);
            }
          },
        );
      }
    }

    const createDPad = (opts) => {
      const container = opts.container;
      const callback = opts.event;
      const dpadMain = this.createElement("div");
      dpadMain.classList.add("ejs_dpad_main");
      const vertical = this.createElement("div");
      vertical.classList.add("ejs_dpad_vertical");
      const horizontal = this.createElement("div");
      horizontal.classList.add("ejs_dpad_horizontal");
      const bar1 = this.createElement("div");
      bar1.classList.add("ejs_dpad_bar");
      const bar2 = this.createElement("div");
      bar2.classList.add("ejs_dpad_bar");

      horizontal.appendChild(bar1);
      vertical.appendChild(bar2);
      dpadMain.appendChild(vertical);
      dpadMain.appendChild(horizontal);

      const updateCb = (e) => {
        e.preventDefault();
        const touch = e.targetTouches[0];
        if (!touch) return;
        const rect = dpadMain.getBoundingClientRect();
        const x = touch.clientX - rect.left - dpadMain.clientWidth / 2;
        const y = touch.clientY - rect.top - dpadMain.clientHeight / 2;
        let up = 0,
          down = 0,
          left = 0,
          right = 0,
          angle = Math.atan(x / y) / (Math.PI / 180);

        if (y <= -10) {
          up = 1;
        }
        if (y >= 10) {
          down = 1;
        }

        if (x >= 10) {
          right = 1;
          left = 0;
          if ((angle < 0 && angle >= -35) || (angle > 0 && angle <= 35)) {
            right = 0;
          }
          up = angle < 0 && angle >= -55 ? 1 : 0;
          down = angle > 0 && angle <= 55 ? 1 : 0;
        }

        if (x <= -10) {
          right = 0;
          left = 1;
          if ((angle < 0 && angle >= -35) || (angle > 0 && angle <= 35)) {
            left = 0;
          }
          up = angle > 0 && angle <= 55 ? 1 : 0;
          down = angle < 0 && angle >= -55 ? 1 : 0;
        }

        dpadMain.classList.toggle("ejs_dpad_up_pressed", up);
        dpadMain.classList.toggle("ejs_dpad_down_pressed", down);
        dpadMain.classList.toggle("ejs_dpad_right_pressed", right);
        dpadMain.classList.toggle("ejs_dpad_left_pressed", left);

        callback(up, down, left, right);
      };
      const cancelCb = (e) => {
        e.preventDefault();
        dpadMain.classList.remove("ejs_dpad_up_pressed");
        dpadMain.classList.remove("ejs_dpad_down_pressed");
        dpadMain.classList.remove("ejs_dpad_right_pressed");
        dpadMain.classList.remove("ejs_dpad_left_pressed");

        callback(0, 0, 0, 0);
      };

      this.addEventListener(dpadMain, "touchstart touchmove", updateCb);
      this.addEventListener(dpadMain, "touchend touchcancel", cancelCb);

      container.appendChild(dpadMain);
    };

    info.forEach((dpad, index) => {
      if (dpad.type !== "dpad") return;
      if (leftHandedMode && ["left", "right"].includes(dpad.location)) {
        dpad.location = dpad.location === "left" ? "right" : "left";
        const amnt = JSON.parse(JSON.stringify(dpad));
        if (amnt.left) {
          dpad.right = amnt.left;
        }
        if (amnt.right) {
          dpad.left = amnt.right;
        }
      }
      const elem = this.createElement("div");
      let style = "";
      if (dpad.left) {
        style += "left:" + dpad.left + ";";
      }
      if (dpad.right) {
        style += "right:" + dpad.right + ";";
      }
      if (dpad.top) {
        style += "top:" + dpad.top + ";";
      }
      elem.classList.add(controlSchemeCls);
      if (dpad.id) {
        elem.classList.add(`b_${dpad.id}`);
      }
      elem.style = style;
      elems[dpad.location].appendChild(elem);
      createDPad({
        container: elem,
        event: (up, down, left, right) => {
          if (dpad.joystickInput) {
            if (up === 1) up = 0x7fff;
            if (down === 1) down = 0x7fff;
            if (left === 1) left = 0x7fff;
            if (right === 1) right = 0x7fff;
          }
          const simulateInput =
            this.netplay && typeof this.netplay.simulateInput === "function"
              ? this.netplay.simulateInput
              : this.gameManager.simulateInput;
          simulateInput(0, dpad.inputValues[0], up);
          simulateInput(0, dpad.inputValues[1], down);
          simulateInput(0, dpad.inputValues[2], left);
          simulateInput(0, dpad.inputValues[3], right);
        },
      });
    });

    info.forEach((zone, index) => {
      if (zone.type !== "zone") return;
      if (leftHandedMode && ["left", "right"].includes(zone.location)) {
        zone.location = zone.location === "left" ? "right" : "left";
        const amnt = JSON.parse(JSON.stringify(zone));
        if (amnt.left) {
          zone.right = amnt.left;
        }
        if (amnt.right) {
          zone.left = amnt.right;
        }
      }
      const elem = this.createElement("div");
      this.addEventListener(
        elem,
        "touchstart touchmove touchend touchcancel",
        (e) => {
          e.preventDefault();
        },
      );
      elem.classList.add(controlSchemeCls);
      if (zone.id) {
        elem.classList.add(`b_${zone.id}`);
      }
      elems[zone.location].appendChild(elem);
      const zoneObj = nipplejs.create({
        zone: elem,
        mode: "static",
        position: {
          left: zone.left,
          top: zone.top,
        },
        color: zone.color || "red",
      });
      zoneObj.on("end", () => {
        const simulateInput =
          this.netplay && typeof this.netplay.simulateInput === "function"
            ? this.netplay.simulateInput
            : this.gameManager.simulateInput;
        simulateInput(0, zone.inputValues[0], 0);
        simulateInput(0, zone.inputValues[1], 0);
        simulateInput(0, zone.inputValues[2], 0);
        simulateInput(0, zone.inputValues[3], 0);
      });
      zoneObj.on("move", (e, info) => {
        const degree = info.angle.degree;
        const distance = info.distance;
        if (zone.joystickInput === true) {
          let x = 0,
            y = 0;
          if (degree > 0 && degree <= 45) {
            x = distance / 50;
            y = (-0.022222222222222223 * degree * distance) / 50;
          }
          if (degree > 45 && degree <= 90) {
            x = (0.022222222222222223 * (90 - degree) * distance) / 50;
            y = -distance / 50;
          }
          if (degree > 90 && degree <= 135) {
            x = (0.022222222222222223 * (90 - degree) * distance) / 50;
            y = -distance / 50;
          }
          if (degree > 135 && degree <= 180) {
            x = -distance / 50;
            y = (-0.022222222222222223 * (180 - degree) * distance) / 50;
          }
          if (degree > 135 && degree <= 225) {
            x = -distance / 50;
            y = (-0.022222222222222223 * (180 - degree) * distance) / 50;
          }
          if (degree > 225 && degree <= 270) {
            x = (-0.022222222222222223 * (270 - degree) * distance) / 50;
            y = distance / 50;
          }
          if (degree > 270 && degree <= 315) {
            x = (-0.022222222222222223 * (270 - degree) * distance) / 50;
            y = distance / 50;
          }
          if (degree > 315 && degree <= 359.9) {
            x = distance / 50;
            y = (0.022222222222222223 * (360 - degree) * distance) / 50;
          }
          const simulateInput =
            this.netplay && typeof this.netplay.simulateInput === "function"
              ? this.netplay.simulateInput
              : this.gameManager.simulateInput;
          if (x > 0) {
            simulateInput(0, zone.inputValues[0], 0x7fff * x);
            simulateInput(0, zone.inputValues[1], 0);
          } else {
            simulateInput(0, zone.inputValues[1], 0x7fff * -x);
            simulateInput(0, zone.inputValues[0], 0);
          }
          if (y > 0) {
            simulateInput(0, zone.inputValues[2], 0x7fff * y);
            simulateInput(0, zone.inputValues[3], 0);
          } else {
            simulateInput(0, zone.inputValues[3], 0x7fff * -y);
            simulateInput(0, zone.inputValues[2], 0);
          }
        } else {
          if (degree >= 30 && degree < 150) {
            simulateInput(0, zone.inputValues[0], 1);
          } else {
            window.setTimeout(() => {
              simulateInput(0, zone.inputValues[0], 0);
            }, 30);
          }
          if (degree >= 210 && degree < 330) {
            simulateInput(0, zone.inputValues[1], 1);
          } else {
            window.setTimeout(() => {
              simulateInput(0, zone.inputValues[1], 0);
            }, 30);
          }
          if (degree >= 120 && degree < 240) {
            simulateInput(0, zone.inputValues[2], 1);
          } else {
            window.setTimeout(() => {
              simulateInput(0, zone.inputValues[2], 0);
            }, 30);
          }
          if (degree >= 300 || (degree >= 0 && degree < 60)) {
            simulateInput(0, zone.inputValues[3], 1);
          } else {
            window.setTimeout(() => {
              simulateInput(0, zone.inputValues[3], 0);
            }, 30);
          }
        }
      });
    });

    if (this.touch || this.hasTouchScreen) {
      const menuButton = this.createElement("div");
      menuButton.innerHTML =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"/></svg>';
      menuButton.classList.add("ejs_virtualGamepad_open");
      menuButton.style.display = "none";
      this.on("start", () => {
        menuButton.style.display = "";
        if (
          matchMedia("(pointer:fine)").matches &&
          this.getSettingValue("menu-bar-button") !== "visible"
        ) {
          menuButton.style.opacity = 0;
          this.changeSettingOption("menu-bar-button", "hidden", true);
        }
      });
      this.elements.parent.appendChild(menuButton);
      let timeout;
      let ready = true;
      this.addEventListener(
        menuButton,
        "touchstart touchend mousedown mouseup click",
        (e) => {
          if (!ready) return;
          clearTimeout(timeout);
          timeout = setTimeout(() => {
            ready = true;
          }, 2000);
          ready = false;
          e.preventDefault();
          this.menu.toggle();
        },
      );
      this.elements.menuToggle = menuButton;
    }

    this.virtualGamepad.style.display = "none";
  }
  handleResize() {
    if (this.virtualGamepad) {
      if (this.virtualGamepad.style.display === "none") {
        this.virtualGamepad.style.opacity = 0;
        this.virtualGamepad.style.display = "";
        setTimeout(() => {
          this.virtualGamepad.style.display = "none";
          this.virtualGamepad.style.opacity = "";
        }, 250);
      }
    }
    const positionInfo = this.elements.parent.getBoundingClientRect();
    this.game.parentElement.classList.toggle(
      "ejs_small_screen",
      positionInfo.width <= 575,
    );
    //This wouldnt work using :not()... strange.
    this.game.parentElement.classList.toggle(
      "ejs_big_screen",
      positionInfo.width > 575,
    );

    if (!this.handleSettingsResize) return;
    this.handleSettingsResize();
  }
  getElementSize(element) {
    let elem = element.cloneNode(true);
    elem.style.position = "absolute";
    elem.style.opacity = 0;
    elem.removeAttribute("hidden");
    element.parentNode.appendChild(elem);
    const res = elem.getBoundingClientRect();
    elem.remove();
    return {
      width: res.width,
      height: res.height,
    };
  }
  saveSettings() {
    if (
      !window.localStorage ||
      this.config.disableLocalStorage ||
      !this.settingsLoaded
    )
      return;
    if (!this.started && !this.failedToStart) return;
    const coreSpecific = {
      controlSettings: this.controls,
      settings: this.settings,
      cheats: this.cheats,
    };
    const ejs_settings = {
      volume: this.volume,
      muted: this.muted,
    };
    localStorage.setItem("ejs-settings", JSON.stringify(ejs_settings));
    localStorage.setItem(
      this.getLocalStorageKey(),
      JSON.stringify(coreSpecific),
    );
  }
  getLocalStorageKey() {
    let identifier = (this.config.gameId || 1) + "-" + this.getCore(true);
    if (typeof this.config.gameName === "string") {
      identifier += "-" + this.config.gameName;
    } else if (
      typeof this.config.gameUrl === "string" &&
      !this.config.gameUrl.toLowerCase().startsWith("blob:")
    ) {
      identifier += "-" + this.config.gameUrl;
    } else if (this.config.gameUrl instanceof File) {
      identifier += "-" + this.config.gameUrl.name;
    } else if (typeof this.config.gameId !== "number") {
      console.warn(
        "gameId (EJS_gameID) is not set. This may result in settings persisting across games.",
      );
    }
    return "ejs-" + identifier + "-settings";
  }
  preGetSetting(setting) {
    if (window.localStorage && !this.config.disableLocalStorage) {
      let coreSpecific = localStorage.getItem(this.getLocalStorageKey());
      try {
        coreSpecific = JSON.parse(coreSpecific);
        if (coreSpecific && coreSpecific.settings) {
          return coreSpecific.settings[setting];
        }
      } catch (e) {
        console.warn("Could not load previous settings", e);
      }
    }
    if (this.config.defaultOptions && this.config.defaultOptions[setting]) {
      return this.config.defaultOptions[setting];
    }
    return null;
  }
  getCoreSettings() {
    if (!window.localStorage || this.config.disableLocalStorage) {
      if (this.config.defaultOptions) {
        let rv = "";
        for (const k in this.config.defaultOptions) {
          let value = isNaN(this.config.defaultOptions[k])
            ? `"${this.config.defaultOptions[k]}"`
            : this.config.defaultOptions[k];
          rv += `${k} = ${value}\n`;
        }
        return rv;
      }
      return "";
    }
    let coreSpecific = localStorage.getItem(this.getLocalStorageKey());
    if (coreSpecific) {
      try {
        coreSpecific = JSON.parse(coreSpecific);
        if (!(coreSpecific.settings instanceof Object))
          throw new Error("Not a JSON object");
        let rv = "";
        for (const k in coreSpecific.settings) {
          let value = isNaN(coreSpecific.settings[k])
            ? `"${coreSpecific.settings[k]}"`
            : coreSpecific.settings[k];
          rv += `${k} = ${value}\n`;
        }
        for (const k in this.config.defaultOptions) {
          if (rv.includes(k)) continue;
          let value = isNaN(this.config.defaultOptions[k])
            ? `"${this.config.defaultOptions[k]}"`
            : this.config.defaultOptions[k];
          rv += `${k} = ${value}\n`;
        }
        return rv;
      } catch (e) {
        console.warn("Could not load previous settings", e);
      }
    }
    return "";
  }
  loadSettings() {
    if (!window.localStorage || this.config.disableLocalStorage) return;
    this.settingsLoaded = true;
    let ejs_settings = localStorage.getItem("ejs-settings");
    let coreSpecific = localStorage.getItem(this.getLocalStorageKey());
    if (coreSpecific) {
      try {
        coreSpecific = JSON.parse(coreSpecific);
        if (
          !(coreSpecific.controlSettings instanceof Object) ||
          !(coreSpecific.settings instanceof Object) ||
          !Array.isArray(coreSpecific.cheats)
        )
          return;
        this.controls = coreSpecific.controlSettings;
        this.checkGamepadInputs();
        for (const k in coreSpecific.settings) {
          this.changeSettingOption(k, coreSpecific.settings[k]);
        }
        for (let i = 0; i < coreSpecific.cheats.length; i++) {
          const cheat = coreSpecific.cheats[i];
          let includes = false;
          for (let j = 0; j < this.cheats.length; j++) {
            if (
              this.cheats[j].desc === cheat.desc &&
              this.cheats[j].code === cheat.code
            ) {
              this.cheats[j].checked = cheat.checked;
              includes = true;
              break;
            }
          }
          if (includes) continue;
          this.cheats.push(cheat);
        }
      } catch (e) {
        console.warn("Could not load previous settings", e);
      }
    }
    if (ejs_settings) {
      try {
        ejs_settings = JSON.parse(ejs_settings);
        if (
          typeof ejs_settings.volume !== "number" ||
          typeof ejs_settings.muted !== "boolean"
        )
          return;
        this.volume = ejs_settings.volume;
        this.muted = ejs_settings.muted;
        this.setVolume(this.muted ? 0 : this.volume);
      } catch (e) {
        console.warn("Could not load previous settings", e);
      }
    }
  }
  enableShader(value) {
    // Store the shader setting - actual shader application would be implemented here
    this.currentShader = value;
    // TODO: Implement actual shader loading and application
    console.log("Shader enabled:", value);
  }

  handleSpecialOptions(option, value) {
    if (option === "shader") {
      this.enableShader(value);
    } else if (option === "disk") {
      this.gameManager.setCurrentDisk(value);
    } else if (option === "virtual-gamepad") {
      this.toggleVirtualGamepad(value !== "disabled");
    } else if (option === "menu-bar-button") {
      this.elements.menuToggle.style.display = "";
      this.elements.menuToggle.style.opacity = value === "visible" ? 0.5 : 0;
    } else if (option === "virtual-gamepad-left-handed-mode") {
      this.toggleVirtualGamepadLeftHanded(value !== "disabled");
    } else if (option === "ff-ratio") {
      if (this.isFastForward) this.gameManager.toggleFastForward(0);
      if (value === "unlimited") {
        this.gameManager.setFastForwardRatio(0);
      } else if (!isNaN(value)) {
        this.gameManager.setFastForwardRatio(parseFloat(value));
      }
      setTimeout(() => {
        if (this.isFastForward) this.gameManager.toggleFastForward(1);
      }, 10);
    } else if (option === "fastForward") {
      if (value === "enabled") {
        this.isFastForward = true;
        this.gameManager.toggleFastForward(1);
      } else if (value === "disabled") {
        this.isFastForward = false;
        this.gameManager.toggleFastForward(0);
      }
    } else if (option === "sm-ratio") {
      if (this.isSlowMotion) this.gameManager.toggleSlowMotion(0);
      this.gameManager.setSlowMotionRatio(parseFloat(value));
      setTimeout(() => {
        if (this.isSlowMotion) this.gameManager.toggleSlowMotion(1);
      }, 10);
    } else if (option === "slowMotion") {
      if (value === "enabled") {
        this.isSlowMotion = true;
        this.gameManager.toggleSlowMotion(1);
      } else if (value === "disabled") {
        this.isSlowMotion = false;
        this.gameManager.toggleSlowMotion(0);
      }
    } else if (option === "rewind-granularity") {
      if (this.rewindEnabled) {
        this.gameManager.setRewindGranularity(parseInt(value));
      }
    } else if (option === "vsync") {
      this.gameManager.setVSync(value === "enabled");
    } else if (option === "videoRotation") {
      value = parseInt(value);
      if (this.videoRotationChanged === true || value !== 0) {
        this.gameManager.setVideoRotation(value);
        this.videoRotationChanged = true;
      } else if (this.videoRotationChanged === true && value === 0) {
        this.gameManager.setVideoRotation(0);
        this.videoRotationChanged = true;
      }
    } else if (
      option === "save-save-interval" &&
      !this.config.fixedSaveInterval
    ) {
      value = parseInt(value);
      this.startSaveInterval(value * 1000);
    } else if (option === "menubarBehavior") {
      this.createBottomMenuBarListeners();
    } else if (option === "keyboardInput") {
      this.gameManager.setKeyboardEnabled(value === "enabled");
    } else if (option === "altKeyboardInput") {
      this.gameManager.setAltKeyEnabled(value === "enabled");
    } else if (option === "lockMouse") {
      this.enableMouseLock = value === "enabled";
    } else if (option === "netplayVP9SVC") {
      const normalizeVP9SVCMode = (v) => {
        const s = typeof v === "string" ? v.trim() : "";
        const sl = s.toLowerCase();
        if (sl === "l1t1") return "L1T1";
        if (sl === "l1t3") return "L1T3";
        if (sl === "l2t3") return "L2T3";
        return "L1T1";
      };
      this.netplayVP9SVCMode = normalizeVP9SVCMode(value);
      window.EJS_NETPLAY_VP9_SVC_MODE = this.netplayVP9SVCMode;

      // Only the host can apply encode changes immediately.
      try {
        if (
          this.isNetplay &&
          this.netplay &&
          this.netplay.owner &&
          typeof this.netplayReproduceHostVideoToSFU === "function"
        ) {
          const isVp9Producer = (() => {
            try {
              const p = this.netplay.producer;
              const codecs =
                p && p.rtpParameters && Array.isArray(p.rtpParameters.codecs)
                  ? p.rtpParameters.codecs
                  : [];
              return codecs.some(
                (c) =>
                  c &&
                  typeof c.mimeType === "string" &&
                  c.mimeType.toLowerCase() === "video/vp9",
              );
            } catch (e) {
              return false;
            }
          })();
          if (isVp9Producer) {
            setTimeout(() => {
              try {
                this.netplayReproduceHostVideoToSFU("vp9-svc-change");
              } catch (e) {}
            }, 0);
          }
        }
      } catch (e) {}
    } else if (option === "netplaySimulcast") {
      this.netplaySimulcastEnabled = value === "enabled";
      window.EJS_NETPLAY_SIMULCAST = this.netplaySimulcastEnabled;
    } else if (option === "netplayHostCodec") {
      const normalizeHostCodec = (v) => {
        const s = typeof v === "string" ? v.trim().toLowerCase() : "";
        if (s === "vp9" || s === "h264" || s === "vp8" || s === "auto")
          return s;
        return "auto";
      };
      this.netplayHostCodec = normalizeHostCodec(value);
      window.EJS_NETPLAY_HOST_CODEC = this.netplayHostCodec;

      // If host is currently producing SFU video, re-produce so codec takes effect.
      try {
        if (
          this.isNetplay &&
          this.netplay &&
          this.netplay.owner &&
          typeof this.netplayReproduceHostVideoToSFU === "function"
        ) {
          setTimeout(() => {
            try {
              this.netplayReproduceHostVideoToSFU("host-codec-change");
            } catch (e) {}
          }, 0);
        }
      } catch (e) {}
    } else if (
      option === "netplayClientSimulcastQuality" ||
      option === "netplayClientMaxResolution"
    ) {
      const normalizeSimulcastQuality = (v) => {
        const s = typeof v === "string" ? v.trim().toLowerCase() : "";
        if (s === "high" || s === "low") return s;
        if (s === "medium") return "low";
        if (s === "720p") return "high";
        if (s === "360p") return "low";
        if (s === "180p") return "low";
        return "high";
      };
      const simulcastQualityToLegacyRes = (q) => {
        const s = normalizeSimulcastQuality(q);
        return s === "low" ? "360p" : "720p";
      };

      this.netplayClientSimulcastQuality = normalizeSimulcastQuality(value);
      window.EJS_NETPLAY_CLIENT_SIMULCAST_QUALITY =
        this.netplayClientSimulcastQuality;
      window.EJS_NETPLAY_CLIENT_PREFERRED_QUALITY =
        this.netplayClientSimulcastQuality;
      window.EJS_NETPLAY_CLIENT_MAX_RESOLUTION = simulcastQualityToLegacyRes(
        this.netplayClientSimulcastQuality,
      );
    } else if (option === "netplayRetryConnectionTimer") {
      let retrySeconds = parseInt(value, 10);
      if (isNaN(retrySeconds)) retrySeconds = 3;
      if (retrySeconds < 0) retrySeconds = 0;
      if (retrySeconds > 5) retrySeconds = 5;
      this.netplayRetryConnectionTimerSeconds = retrySeconds;
      window.EJS_NETPLAY_RETRY_CONNECTION_TIMER = retrySeconds;
    } else if (option === "netplayUnorderedRetries") {
      let unorderedRetries = parseInt(value, 10);
      if (isNaN(unorderedRetries)) unorderedRetries = 0;
      if (unorderedRetries < 0) unorderedRetries = 0;
      if (unorderedRetries > 2) unorderedRetries = 2;
      this.netplayUnorderedRetries = unorderedRetries;
      window.EJS_NETPLAY_UNORDERED_RETRIES = unorderedRetries;

      try {
        if (
          this.isNetplay &&
          this.netplay &&
          typeof this.netplayApplyInputMode === "function"
        ) {
          setTimeout(() => {
            try {
              this.netplayApplyInputMode("unordered-retries-change");
            } catch (e) {}
          }, 0);
        }
      } catch (e) {}
    } else if (option === "netplayInputMode") {
      const mode = typeof value === "string" ? value : "";
      this.netplayInputMode =
        mode === "orderedRelay" ||
        mode === "unorderedRelay" ||
        mode === "unorderedP2P"
          ? mode
          : "unorderedRelay";
      window.EJS_NETPLAY_INPUT_MODE = this.netplayInputMode;

      try {
        if (
          this.isNetplay &&
          this.netplay &&
          typeof this.netplayApplyInputMode === "function"
        ) {
          setTimeout(() => {
            try {
              this.netplayApplyInputMode("setting-change");
            } catch (e) {}
          }, 0);
        }
      } catch (e) {}
    }
  }
  menuOptionChanged(option, value) {
    this.saveSettings();
    this.allSettings[option] = value;
    if (this.debug) console.log(option, value);
    if (!this.gameManager) return;
    this.handleSpecialOptions(option, value);
    this.gameManager.setVariable(option, value);
    this.saveSettings();
  }
  setupDisksMenu() {
    this.disksMenu = this.createElement("div");
    this.disksMenu.classList.add("ejs_settings_parent");
    const nested = this.createElement("div");
    nested.classList.add("ejs_settings_transition");
    this.disks = {};

    const home = this.createElement("div");
    home.style.overflow = "auto";
    const menus = [];
    this.handleDisksResize = () => {
      let needChange = false;
      if (this.disksMenu.style.display !== "") {
        this.disksMenu.style.opacity = "0";
        this.disksMenu.style.display = "";
        needChange = true;
      }
      let height = this.elements.parent.getBoundingClientRect().height;
      let w2 = this.diskParent.parentElement.getBoundingClientRect().width;
      let disksX = this.diskParent.getBoundingClientRect().x;
      if (w2 > window.innerWidth) disksX += w2 - window.innerWidth;
      const onTheRight = disksX > (w2 - 15) / 2;
      if (height > 375) height = 375;
      home.style["max-height"] = height - 95 + "px";
      nested.style["max-height"] = height - 95 + "px";
      for (let i = 0; i < menus.length; i++) {
        menus[i].style["max-height"] = height - 95 + "px";
      }
      this.disksMenu.classList.toggle("ejs_settings_center_left", !onTheRight);
      this.disksMenu.classList.toggle("ejs_settings_center_right", onTheRight);
      if (needChange) {
        this.disksMenu.style.display = "none";
        this.disksMenu.style.opacity = "";
      }
    };

    home.classList.add("ejs_setting_menu");
    nested.appendChild(home);
    let funcs = [];
    this.changeDiskOption = (title, newValue) => {
      this.disks[title] = newValue;
      funcs.forEach((e) => e(title));
    };
    let allOpts = {};

    // TODO - Why is this duplicated?
    const addToMenu = (title, id, options, defaultOption) => {
      const span = this.createElement("span");
      span.innerText = title;

      const current = this.createElement("div");
      current.innerText = "";
      current.classList.add("ejs_settings_main_bar_selected");
      span.appendChild(current);

      const menu = this.createElement("div");
      menus.push(menu);
      menu.setAttribute("hidden", "");
      menu.classList.add("ejs_parent_option_div");
      const button = this.createElement("button");
      const goToHome = () => {
        const homeSize = this.getElementSize(home);
        nested.style.width = homeSize.width + 20 + "px";
        nested.style.height = homeSize.height + "px";
        menu.setAttribute("hidden", "");
        home.removeAttribute("hidden");
      };
      this.addEventListener(button, "click", goToHome);

      button.type = "button";
      button.classList.add("ejs_back_button");
      menu.appendChild(button);
      const pageTitle = this.createElement("span");
      pageTitle.innerText = title;
      pageTitle.classList.add("ejs_menu_text_a");
      button.appendChild(pageTitle);

      const optionsMenu = this.createElement("div");
      optionsMenu.classList.add("ejs_setting_menu");

      let buttons = [];
      let opts = options;
      if (Array.isArray(options)) {
        opts = {};
        for (let i = 0; i < options.length; i++) {
          opts[options[i]] = options[i];
        }
      }
      allOpts[id] = opts;

      funcs.push((title) => {
        if (id !== title) return;
        for (let j = 0; j < buttons.length; j++) {
          buttons[j].classList.toggle(
            "ejs_option_row_selected",
            buttons[j].getAttribute("ejs_value") === this.disks[id],
          );
        }
        this.menuOptionChanged(id, this.disks[id]);
        current.innerText = opts[this.disks[id]];
      });

      for (const opt in opts) {
        const optionButton = this.createElement("button");
        buttons.push(optionButton);
        optionButton.setAttribute("ejs_value", opt);
        optionButton.type = "button";
        optionButton.value = opts[opt];
        optionButton.classList.add("ejs_option_row");
        optionButton.classList.add("ejs_button_style");

        this.addEventListener(optionButton, "click", (e) => {
          this.disks[id] = opt;
          for (let j = 0; j < buttons.length; j++) {
            buttons[j].classList.remove("ejs_option_row_selected");
          }
          optionButton.classList.add("ejs_option_row_selected");
          this.menuOptionChanged(id, opt);
          current.innerText = opts[opt];
          goToHome();
        });
        if (defaultOption === opt) {
          optionButton.classList.add("ejs_option_row_selected");
          this.menuOptionChanged(id, opt);
          current.innerText = opts[opt];
        }

        const msg = this.createElement("span");
        msg.innerText = opts[opt];
        optionButton.appendChild(msg);

        optionsMenu.appendChild(optionButton);
      }

      home.appendChild(optionsMenu);

      nested.appendChild(menu);
    };

    if (this.gameManager.getDiskCount() > 1) {
      const diskLabels = {};
      let isM3U = false;
      let disks = {};
      if (this.fileName.split(".").pop() === "m3u") {
        disks = this.gameManager.Module.FS.readFile(this.fileName, {
          encoding: "utf8",
        }).split("\n");
        isM3U = true;
      }
      for (let i = 0; i < this.gameManager.getDiskCount(); i++) {
        // default if not an m3u loaded rom is "Disk x"
        // if m3u, then use the file name without the extension
        // if m3u, and contains a |, then use the string after the | as the disk label
        if (!isM3U) {
          diskLabels[i.toString()] = "Disk " + (i + 1);
        } else {
          // get disk name from m3u
          const diskLabelValues = disks[i].split("|");
          // remove the file extension from the disk file name
          let diskLabel = diskLabelValues[0].replace(
            "." + diskLabelValues[0].split(".").pop(),
            "",
          );
          if (diskLabelValues.length >= 2) {
            // has a label - use that instead
            diskLabel = diskLabelValues[1];
          }
          diskLabels[i.toString()] = diskLabel;
        }
      }
      addToMenu(
        this.localization("Disk"),
        "disk",
        diskLabels,
        this.gameManager.getCurrentDisk().toString(),
      );
    }

    this.disksMenu.appendChild(nested);

    this.diskParent.appendChild(this.disksMenu);
    this.diskParent.style.position = "relative";

    const homeSize = this.getElementSize(home);
    nested.style.width = homeSize.width + 20 + "px";
    nested.style.height = homeSize.height + "px";

    this.disksMenu.style.display = "none";

    if (this.debug) {
      console.log("Available core options", allOpts);
    }

    if (this.config.defaultOptions) {
      for (const k in this.config.defaultOptions) {
        this.changeDiskOption(k, this.config.defaultOptions[k]);
      }
    }
  }
  getSettingValue(id) {
    return this.allSettings[id] || this.settings[id] || null;
  }
  setupSettingsMenu() {
    this.settingsMenu = this.createElement("div");
    this.settingsMenu.classList.add("ejs_settings_parent");
    const nested = this.createElement("div");
    nested.classList.add("ejs_settings_transition");
    this.settings = {};
    const menus = [];
    let parentMenuCt = 0;

    const createSettingParent = (child, title, parentElement) => {
      const rv = this.createElement("div");
      rv.classList.add("ejs_setting_menu");

      if (child) {
        const menuOption = this.createElement("div");
        menuOption.classList.add("ejs_settings_main_bar");
        const span = this.createElement("span");
        span.innerText = title;

        menuOption.appendChild(span);
        parentElement.appendChild(menuOption);

        const menu = this.createElement("div");
        const menuChild = this.createElement("div");
        menus.push(menu);
        parentMenuCt++;
        menu.setAttribute("hidden", "");
        menuChild.classList.add("ejs_parent_option_div");
        const button = this.createElement("button");
        const goToHome = () => {
          const homeSize = this.getElementSize(parentElement);
          nested.style.width = homeSize.width + 20 + "px";
          nested.style.height = homeSize.height + "px";
          menu.setAttribute("hidden", "");
          parentElement.removeAttribute("hidden");
        };
        this.addEventListener(menuOption, "click", (e) => {
          const targetSize = this.getElementSize(menu);
          nested.style.width = targetSize.width + 20 + "px";
          nested.style.height = targetSize.height + "px";
          menu.removeAttribute("hidden");
          rv.scrollTo(0, 0);
          parentElement.setAttribute("hidden", "");
        });
        const observer = new MutationObserver((list) => {
          for (const k of list) {
            for (const removed of k.removedNodes) {
              if (removed === menu) {
                menuOption.remove();
                observer.disconnect();
                const index = menus.indexOf(menu);
                if (index !== -1) menus.splice(index, 1);
                this.settingsMenu.style.display = "";
                const homeSize = this.getElementSize(parentElement);
                nested.style.width = homeSize.width + 20 + "px";
                nested.style.height = homeSize.height + "px";
                // This SHOULD always be called before the game started - this SHOULD never be an issue
                this.settingsMenu.style.display = "none";
              }
            }
          }
        });
        this.addEventListener(button, "click", goToHome);

        button.type = "button";
        button.classList.add("ejs_back_button");
        menuChild.appendChild(button);
        const pageTitle = this.createElement("span");
        pageTitle.innerText = title;
        pageTitle.classList.add("ejs_menu_text_a");
        button.appendChild(pageTitle);

        // const optionsMenu = this.createElement("div");
        // optionsMenu.classList.add("ejs_setting_menu");
        // menu.appendChild(optionsMenu);

        menuChild.appendChild(rv);
        menu.appendChild(menuChild);
        nested.appendChild(menu);
        observer.observe(nested, {
          childList: true,
          subtree: true,
        });
      }

      return rv;
    };

    const checkForEmptyMenu = (element) => {
      if (element.firstChild === null) {
        element.parentElement.remove(); // No point in keeping an empty menu
        parentMenuCt--;
      }
    };

    const home = createSettingParent();

    this.handleSettingsResize = () => {
      let needChange = false;
      if (this.settingsMenu.style.display !== "") {
        this.settingsMenu.style.opacity = "0";
        this.settingsMenu.style.display = "";
        needChange = true;
      }
      let height = this.elements.parent.getBoundingClientRect().height;
      let w2 = this.settingParent.parentElement.getBoundingClientRect().width;
      let settingsX = this.settingParent.getBoundingClientRect().x;
      if (w2 > window.innerWidth) settingsX += w2 - window.innerWidth;
      const onTheRight = settingsX > (w2 - 15) / 2;
      if (height > 375) height = 375;
      home.style["max-height"] = height - 95 + "px";
      nested.style["max-height"] = height - 95 + "px";
      for (let i = 0; i < menus.length; i++) {
        menus[i].style["max-height"] = height - 95 + "px";
      }
      this.settingsMenu.classList.toggle(
        "ejs_settings_center_left",
        !onTheRight,
      );
      this.settingsMenu.classList.toggle(
        "ejs_settings_center_right",
        onTheRight,
      );
      if (needChange) {
        this.settingsMenu.style.display = "none";
        this.settingsMenu.style.opacity = "";
      }
    };
    nested.appendChild(home);

    let funcs = [];
    let settings = {};
    this.changeSettingOption = (title, newValue, startup) => {
      this.allSettings[title] = newValue;
      if (startup !== true) {
        this.settings[title] = newValue;
      }
      settings[title] = newValue;
      funcs.forEach((e) => e(title));
    };
    let allOpts = {};

    const addToMenu = (
      title,
      id,
      options,
      defaultOption,
      parentElement,
      useParentParent,
    ) => {
      if (
        Array.isArray(this.config.hideSettings) &&
        this.config.hideSettings.includes(id)
      ) {
        return;
      }
      parentElement = parentElement || home;
      const transitionElement = useParentParent
        ? parentElement.parentElement.parentElement
        : parentElement;
      const menuOption = this.createElement("div");
      menuOption.classList.add("ejs_settings_main_bar");
      const span = this.createElement("span");
      span.innerText = title;

      const current = this.createElement("div");
      current.innerText = "";
      current.classList.add("ejs_settings_main_bar_selected");
      span.appendChild(current);

      menuOption.appendChild(span);
      parentElement.appendChild(menuOption);

      const menu = this.createElement("div");
      menus.push(menu);
      const menuChild = this.createElement("div");
      menu.setAttribute("hidden", "");
      menuChild.classList.add("ejs_parent_option_div");

      const optionsMenu = this.createElement("div");
      optionsMenu.classList.add("ejs_setting_menu");

      const button = this.createElement("button");
      const goToHome = () => {
        transitionElement.removeAttribute("hidden");
        menu.setAttribute("hidden", "");
        const homeSize = this.getElementSize(transitionElement);
        nested.style.width = homeSize.width + 20 + "px";
        nested.style.height = homeSize.height + "px";
        transitionElement.removeAttribute("hidden");
      };
      this.addEventListener(menuOption, "click", (e) => {
        const targetSize = this.getElementSize(menu);
        nested.style.width = targetSize.width + 20 + "px";
        nested.style.height = targetSize.height + "px";
        menu.removeAttribute("hidden");
        optionsMenu.scrollTo(0, 0);
        transitionElement.setAttribute("hidden", "");
        transitionElement.setAttribute("hidden", "");
      });
      this.addEventListener(button, "click", goToHome);

      button.type = "button";
      button.classList.add("ejs_back_button");
      menuChild.appendChild(button);
      const pageTitle = this.createElement("span");
      pageTitle.innerText = title;
      pageTitle.classList.add("ejs_menu_text_a");
      button.appendChild(pageTitle);

      let buttons = [];
      let opts = options;
      if (Array.isArray(options)) {
        opts = {};
        for (let i = 0; i < options.length; i++) {
          opts[options[i]] = options[i];
        }
      }
      allOpts[id] = opts;

      funcs.push((title) => {
        if (id !== title) return;
        for (let j = 0; j < buttons.length; j++) {
          buttons[j].classList.toggle(
            "ejs_option_row_selected",
            buttons[j].getAttribute("ejs_value") === settings[id],
          );
        }
        this.menuOptionChanged(id, settings[id]);
        current.innerText = opts[settings[id]];
      });

      for (const opt in opts) {
        const optionButton = this.createElement("button");
        buttons.push(optionButton);
        optionButton.setAttribute("ejs_value", opt);
        optionButton.type = "button";
        optionButton.value = opts[opt];
        optionButton.classList.add("ejs_option_row");
        optionButton.classList.add("ejs_button_style");

        this.addEventListener(optionButton, "click", (e) => {
          this.changeSettingOption(id, opt);
          for (let j = 0; j < buttons.length; j++) {
            buttons[j].classList.remove("ejs_option_row_selected");
          }
          optionButton.classList.add("ejs_option_row_selected");
          this.menuOptionChanged(id, opt);
          current.innerText = opts[opt];
          goToHome();
        });
        if (defaultOption === opt) {
          optionButton.classList.add("ejs_option_row_selected");
          this.menuOptionChanged(id, opt);
          current.innerText = opts[opt];
        }

        const msg = this.createElement("span");
        msg.innerText = opts[opt];
        optionButton.appendChild(msg);

        optionsMenu.appendChild(optionButton);
      }

      menuChild.appendChild(optionsMenu);

      menu.appendChild(menuChild);
      nested.appendChild(menu);
    };
    const cores = this.getCores();
    const core = cores[this.getCore(true)];
    if (core && core.length > 1) {
      addToMenu(
        this.localization(
          "Core" + " (" + this.localization("Requires restart") + ")",
        ),
        "retroarch_core",
        core,
        this.getCore(),
        home,
      );
    }
    if (
      typeof window.SharedArrayBuffer === "function" &&
      !this.requiresThreads(this.getCore())
    ) {
      addToMenu(
        this.localization("Threads"),
        "ejs_threads",
        {
          enabled: this.localization("Enabled"),
          disabled: this.localization("Disabled"),
        },
        this.config.threads ? "enabled" : "disabled",
        home,
      );
    }

    const graphicsOptions = createSettingParent(
      true,
      "Graphics Settings",
      home,
    );

    if (this.config.shaders) {
      const builtinShaders = {
        "2xScaleHQ.glslp": this.localization("2xScaleHQ"),
        "4xScaleHQ.glslp": this.localization("4xScaleHQ"),
        "crt-aperture.glslp": this.localization("CRT aperture"),
        "crt-beam": this.localization("CRT beam"),
        "crt-caligari": this.localization("CRT caligari"),
        "crt-easymode.glslp": this.localization("CRT easymode"),
        "crt-geom.glslp": this.localization("CRT geom"),
        "crt-lottes": this.localization("CRT lottes"),
        "crt-mattias.glslp": this.localization("CRT mattias"),
        "crt-yeetron": this.localization("CRT yeetron"),
        "crt-zfast": this.localization("CRT zfast"),
        sabr: this.localization("SABR"),
        bicubic: this.localization("Bicubic"),
        "mix-frames": this.localization("Mix frames"),
      };
      let shaderMenu = {
        disabled: this.localization("Disabled"),
      };
      for (const shaderName in this.config.shaders) {
        if (builtinShaders[shaderName]) {
          shaderMenu[shaderName] = builtinShaders[shaderName];
        } else {
          shaderMenu[shaderName] = shaderName;
        }
      }
      addToMenu(
        this.localization("Shaders"),
        "shader",
        shaderMenu,
        "disabled",
        graphicsOptions,
        true,
      );
    }

    if (this.supportsWebgl2 && !this.requiresWebGL2(this.getCore())) {
      addToMenu(
        this.localization("WebGL2") +
          " (" +
          this.localization("Requires restart") +
          ")",
        "webgl2Enabled",
        {
          enabled: this.localization("Enabled"),
          disabled: this.localization("Disabled"),
        },
        this.webgl2Enabled ? "enabled" : "disabled",
        graphicsOptions,
        true,
      );
    }

    addToMenu(
      this.localization("FPS"),
      "fps",
      {
        show: this.localization("show"),
        hide: this.localization("hide"),
      },
      "hide",
      graphicsOptions,
      true,
    );

    addToMenu(
      this.localization("VSync"),
      "vsync",
      {
        enabled: this.localization("Enabled"),
        disabled: this.localization("Disabled"),
      },
      "disabled",
      graphicsOptions,
      true,
    );

    addToMenu(
      this.localization("Video Rotation"),
      "videoRotation",
      {
        0: "0 deg",
        1: "90 deg",
        2: "180 deg",
        3: "270 deg",
      },
      this.videoRotation.toString(),
      graphicsOptions,
      true,
    );

    const screenCaptureOptions = createSettingParent(
      true,
      "Screen Capture",
      home,
    );

    addToMenu(
      this.localization("Screenshot Source"),
      "screenshotSource",
      {
        canvas: "canvas",
        retroarch: "retroarch",
      },
      this.capture.photo.source,
      screenCaptureOptions,
      true,
    );

    let screenshotFormats = {
      png: "png",
      jpeg: "jpeg",
      webp: "webp",
    };
    if (this.isSafari) {
      delete screenshotFormats["webp"];
    }
    if (!(this.capture.photo.format in screenshotFormats)) {
      this.capture.photo.format = "png";
    }
    addToMenu(
      this.localization("Screenshot Format"),
      "screenshotFormat",
      screenshotFormats,
      this.capture.photo.format,
      screenCaptureOptions,
      true,
    );

    const screenshotUpscale = this.capture.photo.upscale.toString();
    let screenshotUpscales = {
      0: "native",
      1: "1x",
      2: "2x",
      3: "3x",
    };
    if (!(screenshotUpscale in screenshotUpscales)) {
      screenshotUpscales[screenshotUpscale] = screenshotUpscale + "x";
    }
    addToMenu(
      this.localization("Screenshot Upscale"),
      "screenshotUpscale",
      screenshotUpscales,
      screenshotUpscale,
      screenCaptureOptions,
      true,
    );

    const screenRecordFPS = this.capture.video.fps.toString();
    let screenRecordFPSs = {
      30: "30",
      60: "60",
    };
    if (!(screenRecordFPS in screenRecordFPSs)) {
      screenRecordFPSs[screenRecordFPS] = screenRecordFPS;
    }
    addToMenu(
      this.localization("Screen Recording FPS"),
      "screenRecordFPS",
      screenRecordFPSs,
      screenRecordFPS,
      screenCaptureOptions,
      true,
    );

    let screenRecordFormats = {
      mp4: "mp4",
      webm: "webm",
    };
    for (const format in screenRecordFormats) {
      if (!MediaRecorder.isTypeSupported("video/" + format)) {
        delete screenRecordFormats[format];
      }
    }
    if (!(this.capture.video.format in screenRecordFormats)) {
      this.capture.video.format = Object.keys(screenRecordFormats)[0];
    }
    addToMenu(
      this.localization("Screen Recording Format"),
      "screenRecordFormat",
      screenRecordFormats,
      this.capture.video.format,
      screenCaptureOptions,
      true,
    );

    const screenRecordUpscale = this.capture.video.upscale.toString();
    let screenRecordUpscales = {
      1: "1x",
      2: "2x",
      3: "3x",
      4: "4x",
    };
    if (!(screenRecordUpscale in screenRecordUpscales)) {
      screenRecordUpscales[screenRecordUpscale] = screenRecordUpscale + "x";
    }
    addToMenu(
      this.localization("Screen Recording Upscale"),
      "screenRecordUpscale",
      screenRecordUpscales,
      screenRecordUpscale,
      screenCaptureOptions,
      true,
    );

    const screenRecordVideoBitrate = this.capture.video.videoBitrate.toString();
    let screenRecordVideoBitrates = {
      1048576: "1 Mbit/sec",
      2097152: "2 Mbit/sec",
      2621440: "2.5 Mbit/sec",
      3145728: "3 Mbit/sec",
      4194304: "4 Mbit/sec",
    };
    if (!(screenRecordVideoBitrate in screenRecordVideoBitrates)) {
      screenRecordVideoBitrates[screenRecordVideoBitrate] =
        screenRecordVideoBitrate + " Bits/sec";
    }
    addToMenu(
      this.localization("Screen Recording Video Bitrate"),
      "screenRecordVideoBitrate",
      screenRecordVideoBitrates,
      screenRecordVideoBitrate,
      screenCaptureOptions,
      true,
    );

    const screenRecordAudioBitrate = this.capture.video.audioBitrate.toString();
    let screenRecordAudioBitrates = {
      65536: "64 Kbit/sec",
      131072: "128 Kbit/sec",
      196608: "192 Kbit/sec",
      262144: "256 Kbit/sec",
      327680: "320 Kbit/sec",
    };
    if (!(screenRecordAudioBitrate in screenRecordAudioBitrates)) {
      screenRecordAudioBitrates[screenRecordAudioBitrate] =
        screenRecordAudioBitrate + " Bits/sec";
    }
    addToMenu(
      this.localization("Screen Recording Audio Bitrate"),
      "screenRecordAudioBitrate",
      screenRecordAudioBitrates,
      screenRecordAudioBitrate,
      screenCaptureOptions,
      true,
    );

    checkForEmptyMenu(screenCaptureOptions);

    const speedOptions = createSettingParent(true, "Speed Options", home);

    addToMenu(
      this.localization("Fast Forward"),
      "fastForward",
      {
        enabled: this.localization("Enabled"),
        disabled: this.localization("Disabled"),
      },
      "disabled",
      speedOptions,
      true,
    );

    addToMenu(
      this.localization("Fast Forward Ratio"),
      "ff-ratio",
      [
        "1.5",
        "2.0",
        "2.5",
        "3.0",
        "3.5",
        "4.0",
        "4.5",
        "5.0",
        "5.5",
        "6.0",
        "6.5",
        "7.0",
        "7.5",
        "8.0",
        "8.5",
        "9.0",
        "9.5",
        "10.0",
        "unlimited",
      ],
      "3.0",
      speedOptions,
      true,
    );

    addToMenu(
      this.localization("Slow Motion"),
      "slowMotion",
      {
        enabled: this.localization("Enabled"),
        disabled: this.localization("Disabled"),
      },
      "disabled",
      speedOptions,
      true,
    );

    addToMenu(
      this.localization("Slow Motion Ratio"),
      "sm-ratio",
      [
        "1.5",
        "2.0",
        "2.5",
        "3.0",
        "3.5",
        "4.0",
        "4.5",
        "5.0",
        "5.5",
        "6.0",
        "6.5",
        "7.0",
        "7.5",
        "8.0",
        "8.5",
        "9.0",
        "9.5",
        "10.0",
      ],
      "3.0",
      speedOptions,
      true,
    );

    addToMenu(
      this.localization(
        "Rewind Enabled" + " (" + this.localization("Requires restart") + ")",
      ),
      "rewindEnabled",
      {
        enabled: this.localization("Enabled"),
        disabled: this.localization("Disabled"),
      },
      "disabled",
      speedOptions,
      true,
    );

    if (this.rewindEnabled) {
      addToMenu(
        this.localization("Rewind Granularity"),
        "rewind-granularity",
        ["1", "3", "6", "12", "25", "50", "100"],
        "6",
        speedOptions,
        true,
      );
    }

    const inputOptions = createSettingParent(true, "Input Options", home);

    addToMenu(
      this.localization("Menubar Mouse Trigger"),
      "menubarBehavior",
      {
        downward: this.localization("Downward Movement"),
        anywhere: this.localization("Movement Anywhere"),
      },
      "downward",
      inputOptions,
      true,
    );

    addToMenu(
      this.localization("Direct Keyboard Input"),
      "keyboardInput",
      {
        disabled: this.localization("Disabled"),
        enabled: this.localization("Enabled"),
      },
      this.defaultCoreOpts && this.defaultCoreOpts.useKeyboard === true
        ? "enabled"
        : "disabled",
      inputOptions,
      true,
    );

    addToMenu(
      this.localization("Forward Alt key"),
      "altKeyboardInput",
      {
        disabled: this.localization("Disabled"),
        enabled: this.localization("Enabled"),
      },
      "disabled",
      inputOptions,
      true,
    );

    addToMenu(
      this.localization("Lock Mouse"),
      "lockMouse",
      {
        disabled: this.localization("Disabled"),
        enabled: this.localization("Enabled"),
      },
      this.enableMouseLock === true ? "enabled" : "disabled",
      inputOptions,
      true,
    );

    checkForEmptyMenu(inputOptions);

    if (this.saveInBrowserSupported()) {
      const saveStateOpts = createSettingParent(true, "Save States", home);
      addToMenu(
        this.localization("Save State Slot"),
        "save-state-slot",
        ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
        "1",
        saveStateOpts,
        true,
      );
      addToMenu(
        this.localization("Save State Location"),
        "save-state-location",
        {
          download: this.localization("Download"),
          browser: this.localization("Keep in Browser"),
        },
        "download",
        saveStateOpts,
        true,
      );
      if (!this.config.fixedSaveInterval) {
        addToMenu(
          this.localization("System Save interval"),
          "save-save-interval",
          {
            0: "Disabled",
            30: "30 seconds",
            60: "1 minute",
            300: "5 minutes",
            600: "10 minutes",
            900: "15 minutes",
            1800: "30 minutes",
          },
          "300",
          saveStateOpts,
          true,
        );
      }
      checkForEmptyMenu(saveStateOpts);
    }

    if (this.touch || this.hasTouchScreen) {
      const virtualGamepad = createSettingParent(true, "Virtual Gamepad", home);
      addToMenu(
        this.localization("Virtual Gamepad"),
        "virtual-gamepad",
        {
          enabled: this.localization("Enabled"),
          disabled: this.localization("Disabled"),
        },
        this.isMobile ? "enabled" : "disabled",
        virtualGamepad,
        true,
      );
      addToMenu(
        this.localization("Menu Bar Button"),
        "menu-bar-button",
        {
          visible: this.localization("visible"),
          hidden: this.localization("hidden"),
        },
        "visible",
        virtualGamepad,
        true,
      );
      addToMenu(
        this.localization("Left Handed Mode"),
        "virtual-gamepad-left-handed-mode",
        {
          enabled: this.localization("Enabled"),
          disabled: this.localization("Disabled"),
        },
        "disabled",
        virtualGamepad,
        true,
      );
      checkForEmptyMenu(virtualGamepad);
    }

    let coreOpts;
    try {
      coreOpts = this.gameManager.getCoreOptions();
    } catch (e) {}
    if (coreOpts) {
      const coreOptions = createSettingParent(
        true,
        "Backend Core Options",
        home,
      );
      coreOpts.split("\n").forEach((line, index) => {
        let option = line.split("; ");
        let name = option[0];
        let options = option[1].split("|"),
          optionName = name
            .split("|")[0]
            .replace(/_/g, " ")
            .replace(/.+\-(.+)/, "$1");
        options.slice(1, -1);
        if (options.length === 1) return;
        let availableOptions = {};
        for (let i = 0; i < options.length; i++) {
          availableOptions[options[i]] = this.localization(
            options[i],
            this.config.settingsLanguage,
          );
        }
        addToMenu(
          this.localization(optionName, this.config.settingsLanguage),
          name.split("|")[0],
          availableOptions,
          name.split("|").length > 1
            ? name.split("|")[1]
            : options[0].replace("(Default) ", ""),
          coreOptions,
          true,
        );
      });
      checkForEmptyMenu(coreOptions);
    }

    /*
        this.retroarchOpts = [
            {
                title: "Audio Latency", // String
                name: "audio_latency", // String - value to be set in retroarch.cfg
                // options should ALWAYS be strings here...
                options: ["8", "16", "32", "64", "128"], // values
                options: {"8": "eight", "16": "sixteen", "32": "thirty-two", "64": "sixty-four", "128": "one hundred-twenty-eight"}, // This also works
                default: "128", // Default
                isString: false // Surround value with quotes in retroarch.cfg file?
            }
        ];*/

    if (this.retroarchOpts && Array.isArray(this.retroarchOpts)) {
      const retroarchOptsMenu = createSettingParent(
        true,
        "RetroArch Options" +
          " (" +
          this.localization("Requires restart") +
          ")",
        home,
      );
      this.retroarchOpts.forEach((option) => {
        addToMenu(
          this.localization(option.title, this.config.settingsLanguage),
          option.name,
          option.options,
          option.default,
          retroarchOptsMenu,
          true,
        );
      });
      checkForEmptyMenu(retroarchOptsMenu);
    }

    checkForEmptyMenu(graphicsOptions);
    checkForEmptyMenu(speedOptions);

    this.settingsMenu.appendChild(nested);

    this.settingParent.appendChild(this.settingsMenu);
    this.settingParent.style.position = "relative";

    this.settingsMenu.style.display = "";
    const homeSize = this.getElementSize(home);
    nested.style.width = homeSize.width + 20 + "px";
    nested.style.height = homeSize.height + "px";

    this.settingsMenu.style.display = "none";

    if (this.debug) {
      console.log("Available core options", allOpts);
    }

    if (this.config.defaultOptions) {
      for (const k in this.config.defaultOptions) {
        this.changeSettingOption(k, this.config.defaultOptions[k], true);
      }
    }

    if (parentMenuCt === 0) {
      this.on("start", () => {
        this.elements.bottomBar.settings[0][0].style.display = "none";
      });
    }
  }
  createSubPopup(hidden) {
    const popup = this.createElement("div");
    popup.classList.add("ejs_popup_container");
    popup.classList.add("ejs_popup_container_box");
    const popupMsg = this.createElement("div");
    popupMsg.innerText = "";
    if (hidden) popup.setAttribute("hidden", "");
    popup.appendChild(popupMsg);
    return [popup, popupMsg];
  }

  updateCheatUI() {
    if (!this.cheatsMenu) return;

    const body = this.cheatsMenu.querySelector(".ejs_popup_body");
    if (!body) return;

    // Clear existing content
    body.innerHTML = "";

    if (this.cheats.length === 0) {
      body.innerHTML =
        '<div style="text-align: center; padding: 20px; color: #666;">No cheats available</div>';
      return;
    }

    // Add cheat toggles
    this.cheats.forEach((cheat, index) => {
      const cheatDiv = this.createElement("div");
      cheatDiv.style.marginBottom = "10px";

      const checkbox = this.createElement("input");
      checkbox.type = "checkbox";
      checkbox.id = `cheat_${index}`;
      checkbox.checked = cheat.checked || false;
      checkbox.onchange = () => {
        cheat.checked = checkbox.checked;
        // TODO: Apply/remove cheat code
        console.log(
          `Cheat "${cheat.desc}" ${cheat.checked ? "enabled" : "disabled"}`,
        );
      };

      const label = this.createElement("label");
      label.htmlFor = `cheat_${index}`;
      label.textContent = cheat.desc;
      label.style.marginLeft = "8px";

      cheatDiv.appendChild(checkbox);
      cheatDiv.appendChild(label);
      body.appendChild(cheatDiv);
    });
  }

  createCheatsMenu() {
    const body = this.createPopup("Cheats", {}, true);
    this.cheatsMenu = body.parentElement;
    this.updateCheatUI();
  }

  /**
   * Get the audio output node for netplay audio capture.
   * This provides access to the WebAudio node that feeds AudioContext.destination.
   * Used by netplay systems to tap into emulator audio for streaming.
   * @returns {AudioNode|null} The audio node feeding the speakers, or null if not available
   */
  getAudioOutputNode() {
    console.log("[EmulatorJS] getAudioOutputNode called");

    // Try to find the audio node that feeds into AudioContext.destination
    // This varies by emulator core and WebAudio setup

    // First, check if there's a direct reference to an audio context and destination node
    if (this.Module && this.Module.AL && this.Module.AL.currentCtx) {
      const openALCtx = this.Module.AL.currentCtx;
      console.log(
        "[EmulatorJS] Found OpenAL context, checking for audio nodes:",
        {
          hasAudioDestination: !!openALCtx.audioDestination,
          hasMasterGain: !!openALCtx.masterGain,
          hasOutputNode: !!openALCtx.outputNode,
          contextKeys: Object.keys(openALCtx).filter(
            (k) =>
              k.toLowerCase().includes("audio") ||
              k.toLowerCase().includes("node"),
          ),
        },
      );

      // Some cores store the WebAudio destination node here
      if (openALCtx.audioDestination) {
        console.log("[EmulatorJS] Returning audioDestination node");
        return openALCtx.audioDestination;
      }
      // Some cores have a master gain node before destination
      if (openALCtx.masterGain) {
        console.log("[EmulatorJS] Returning masterGain node");
        return openALCtx.masterGain;
      }
      // Some cores have an explicit output node
      if (openALCtx.outputNode) {
        console.log("[EmulatorJS] Returning outputNode");
        return openALCtx.outputNode;
      }

      // Look for ScriptProcessor or AudioWorklet nodes (common in emscripten OpenAL)
      if (openALCtx.scriptProcessor) {
        console.log("[EmulatorJS] Returning scriptProcessor node");
        return openALCtx.scriptProcessor;
      }
      if (openALCtx.audioWorklet) {
        console.log("[EmulatorJS] Returning audioWorklet node");
        return openALCtx.audioWorklet;
      }

      // Check for other common audio node patterns in OpenAL context
      // Some cores might have differently named properties
      const potentialNodes = [
        "gainNode",
        "outputGain",
        "mainGain",
        "audioGain",
        "masterVolume",
      ];
      for (const nodeName of potentialNodes) {
        if (
          openALCtx[nodeName] &&
          typeof openALCtx[nodeName].connect === "function"
        ) {
          console.log(`[EmulatorJS] Found potential audio node '${nodeName}'`);
          return openALCtx[nodeName];
        }
      }
    }

    // Second, try to inspect the global WebAudio state for emulator audio
    // This is more aggressive but may find the audio node
    try {
      console.log("[EmulatorJS] Attempting global WebAudio inspection...");

      // Get all audio contexts (browsers may have multiple)
      // We can't directly enumerate contexts, but we can look for active audio nodes

      // Some emscripten builds expose their audio context globally
      const potentialContexts = [
        window.AudioContext?.prototype,
        window.webkitAudioContext?.prototype,
        // Check for any global audio contexts that might be from the emulator
        ...Object.values(window).filter(
          (obj) =>
            obj &&
            typeof obj === "object" &&
            (obj.constructor?.name?.includes("AudioContext") ||
              obj.toString?.().includes("AudioContext")),
        ),
      ];

      console.log(
        "[EmulatorJS] Found potential audio contexts:",
        potentialContexts.length,
      );

      // This is a fallback that won't work reliably but shows we're trying
      // The real fix is for cores to expose their audioDestination/masterGain
      console.log(
        "[EmulatorJS] getAudioOutputNode: No direct audio node access found",
      );
      console.log(
        "[EmulatorJS] Emulator cores need to expose audioDestination or masterGain in Module.AL.currentCtx",
      );
    } catch (e) {
      console.warn(
        "[EmulatorJS] getAudioOutputNode: Error during WebAudio inspection:",
        e,
      );
    }

    console.log(
      "[EmulatorJS] getAudioOutputNode: No suitable audio output node found",
    );
    console.log("[EmulatorJS] Audio capture will fall back to silent track");
    return null;
  }

  // Calculate and store ROM metadata for netplay
  async calculateAndStoreRomMetadata(romData, romFilename) {
    try {
      // Calculate ROM hash
      const romHash = await this.calculateRomHash(romData);

      // Detect platform from filename
      const platform = this.getPlatformFromFilename(romFilename);

      // Store metadata in config
      this.config.romHash = romHash;
      this.config.romFilename = romFilename;
      this.config.romName = romFilename;
      this.config.platform = platform;
      this.config.core = this.config.system; // Ensure core is set
      this.config.coreVersion = this.coreName || null;

      console.log("[Emulator] ROM metadata stored:", {
        romHash: this.config.romHash,
        romFilename: this.config.romFilename,
        platform: this.config.platform,
        core: this.config.core,
        coreVersion: this.config.coreVersion,
      });
    } catch (error) {
      console.warn("[Emulator] Failed to calculate ROM metadata:", error);
      // Set defaults even if calculation fails
      this.config.romHash = null;
      this.config.platform = "unknown";
      this.config.core = this.config.system;
    }
    // Update player metadata if in netplay session
    if (this.netplay?.engine && this.netplay.currentRoomId) {
      console.log("[Emulator] Updating player metadata with ROM data");
      this.netplay.engine.roomManager
        .updatePlayerMetadata(this.netplay.currentRoomId, {
          coreId: this.config.system || null,
          coreVersion: this.config.coreVersion || null,
          romHash: this.config.romHash || null,
          systemType: this.config.system || null,
          platform: this.config.platform || null,
        })
        .catch((err) => {
          console.warn(
            "[Emulator] Failed to update player metadata after ROM load:",
            err,
          );
        });
    }
  }

  // Calculate ROM hash using SHA-256
  async calculateRomHash(data) {
    try {
      // Convert data to ArrayBuffer if it's not already
      let arrayBuffer;
      if (data instanceof ArrayBuffer) {
        arrayBuffer = data;
      } else if (data instanceof Uint8Array) {
        arrayBuffer = data.buffer.slice(
          data.byteOffset,
          data.byteOffset + data.byteLength,
        );
      } else {
        // Convert other array types to Uint8Array
        arrayBuffer = new Uint8Array(data).buffer;
      }

      const hashBuffer = await crypto.subtle.digest("SHA-256", arrayBuffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("")
        .substring(0, 16);
    } catch (error) {
      console.warn("[Emulator] Hash calculation failed:", error);
      return null;
    }
  }

  // Detect platform from filename extension
  getPlatformFromFilename(filename) {
    if (!filename) return "unknown";

    const ext = filename.split(".").pop().toLowerCase();
    const platformMap = {
      // NES
      nes: "nes",
      fds: "nes",
      unf: "nes",
      unif: "nes",
      // SNES
      sfc: "snes",
      smc: "snes",
      fig: "snes",
      // Game Boy
      gb: "gb",
      gbc: "gb",
      // Game Boy Advance
      gba: "gba",
      // Nintendo 64
      n64: "n64",
      z64: "n64",
      v64: "n64",
      // PlayStation
      bin: "psx",
      cue: "psx",
      iso: "psx",
      // Sega Genesis/Mega Drive
      md: "genesis",
      smd: "genesis",
      gen: "genesis",
      // Sega Master System
      sms: "sms",
      // Sega Game Gear
      gg: "gamegear",
      // TurboGrafx-16/PC Engine
      pce: "pce",
      // Neo Geo Pocket
      ngp: "ngp",
      ngc: "ngp",
      // WonderSwan
      ws: "wswan",
      wsc: "wswan",
      // Atari 2600
      a26: "atari2600",
      // Atari 7800
      a78: "atari7800",
      // ColecoVision
      col: "coleco",
      // MSX
      rom: "msx",
      // DOS
      exe: "dos",
      com: "dos",
      bat: "dos",
    };

    return platformMap[ext] || "unknown";
  }
}

class GamepadHandler {
    gamepads;
    timeout;
    listeners;
    constructor() {
        this.buttonLabels = {
            0: 'BUTTON_1',
            1: 'BUTTON_2',
            2: 'BUTTON_3',
            3: 'BUTTON_4',
            4: 'LEFT_TOP_SHOULDER',
            5: 'RIGHT_TOP_SHOULDER',
            6: 'LEFT_BOTTOM_SHOULDER',
            7: 'RIGHT_BOTTOM_SHOULDER',
            8: 'SELECT',
            9: 'START',
            10: 'LEFT_STICK',
            11: 'RIGHT_STICK',
            12: 'DPAD_UP',
            13: 'DPAD_DOWN',
            14: 'DPAD_LEFT',
            15: 'DPAD_RIGHT',
        };
        this.gamepads = [];
        this.listeners = {};
        this.timeout = null;
        this.loop();
    }
    terminate() {
        window.clearTimeout(this.timeout);
    }
    getGamepads() {
        return navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
    }
    loop() {
        this.updateGamepadState();
        this.timeout = setTimeout(this.loop.bind(this), 10);
    }
    updateGamepadState() {
        let gamepads = Array.from(this.getGamepads());
        if (!gamepads) return;
        if (!Array.isArray(gamepads) && gamepads.length) {
            let gp = [];
            for (let i=0; i<gamepads.length; i++) {
                gp.push(gamepads[i]);
            }
            gamepads = gp;
        } else if (!Array.isArray(gamepads)) return;

        gamepads.forEach((gamepad, index) => {
            if (!gamepad) return;
            let hasGamepad = false;
            this.gamepads.forEach((oldGamepad, oldIndex) => {
                if (oldGamepad.index !== gamepad.index) return;
                const gamepadToSave = {
                    axes: [],
                    buttons: {},
                    index: oldGamepad.index,
                    id: oldGamepad.id
                }
                hasGamepad = true;

                oldGamepad.axes.forEach((axis, axisIndex) => {
                    const val = (axis < 0.01 && axis > -0.01) ? 0 : axis;
                    const newVal = (gamepad.axes[axisIndex] < 0.01 && gamepad.axes[axisIndex] > -0.01) ? 0 : gamepad.axes[axisIndex];
                    if (newVal !== val) {
                        let axis = ['LEFT_STICK_X', 'LEFT_STICK_Y', 'RIGHT_STICK_X', 'RIGHT_STICK_Y'][axisIndex];
                        if (!axis) {
                            axis = "EXTRA_STICK_" + axisIndex;
                        }
                        this.dispatchEvent('axischanged', {
                            axis: axis,
                            value: newVal,
                            index: gamepad.index,
                            label: this.getAxisLabel(axis, newVal),
                            gamepadIndex: gamepad.index,
                        });
                    }
                    gamepadToSave.axes[axisIndex] = newVal;
                })

                gamepad.buttons.forEach((button, buttonIndex) => {
                    let pressed = oldGamepad.buttons[buttonIndex] === 1.0;
                    if (typeof oldGamepad.buttons[buttonIndex] === "object") {
                        pressed = oldGamepad.buttons[buttonIndex].pressed;
                    }
                    let pressed2 = button === 1.0;
                    if (typeof button === "object") {
                        pressed2 = button.pressed;
                    }
                    gamepadToSave.buttons[buttonIndex] = {pressed:pressed2};
                    if (pressed !== pressed2) {
                        if (pressed2) {
                            this.dispatchEvent('buttondown', {index: buttonIndex, label: this.getButtonLabel(buttonIndex), gamepadIndex: gamepad.index});
                        } else {
                            this.dispatchEvent('buttonup', {index: buttonIndex, label:this.getButtonLabel(buttonIndex), gamepadIndex: gamepad.index});
                        }
                    }

                })
                this.gamepads[oldIndex] = gamepadToSave;
            })
            if (!hasGamepad) {
                this.gamepads.push(gamepads[index]);
                this.gamepads.sort((a, b) => {
                    if (a == null && b == null) return 0;
                    if (a == null) return 1;
                    if (b == null) return -1;
                    return a.index - b.index;
                });
                this.dispatchEvent('connected', {gamepadIndex: gamepad.index});
            }
        });

        for (let j=0; j<this.gamepads.length; j++) {
            if (!this.gamepads[j]) continue;
            let has = false;
            for (let i=0; i<gamepads.length; i++) {
                if (!gamepads[i]) continue;
                if (this.gamepads[j].index === gamepads[i].index) {
                    has = true;
                    break;
                }
            }
            if (!has) {
                this.dispatchEvent('disconnected', {gamepadIndex: this.gamepads[j].index});
                this.gamepads.splice(j, 1);
                j--;
            }
        }
    }
    dispatchEvent(name, arg) {
        if (typeof this.listeners[name] !== 'function') return;
        if (!arg) arg={};
        arg.type = name;
        this.listeners[name](arg);
    }
    on(name, cb) {
        this.listeners[name.toLowerCase()] = cb;
    }

    getButtonLabel(index) {
        if (index === null || index === undefined) {
            return null;
        }
        if (this.buttonLabels[index] === undefined) {
            return `GAMEPAD_${index}`;
        }
        return this.buttonLabels[index];
    }
    getAxisLabel(axis, value) {
        let valueLabel = null;
        if (value > 0.5 || value < -0.5) {
            if (value > 0) {
                valueLabel = '+1';
            } else {
                valueLabel = '-1';
            }
        }
        if (!axis || !valueLabel) {
            return null;
        }
        return `${axis}:${valueLabel}`;
    }
}

window.GamepadHandler = GamepadHandler;

!function(t,i){"object"==typeof exports&&"object"==typeof module?module.exports=i():"function"==typeof define&&define.amd?define("nipplejs",[],i):"object"==typeof exports?exports.nipplejs=i():t.nipplejs=i()}(window,function(){return function(t){var i={};function e(o){if(i[o])return i[o].exports;var n=i[o]={i:o,l:!1,exports:{}};return t[o].call(n.exports,n,n.exports,e),n.l=!0,n.exports}return e.m=t,e.c=i,e.d=function(t,i,o){e.o(t,i)||Object.defineProperty(t,i,{enumerable:!0,get:o})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,i){if(1&i&&(t=e(t)),8&i)return t;if(4&i&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(e.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&i&&"string"!=typeof t)for(var n in t)e.d(o,n,function(i){return t[i]}.bind(null,n));return o},e.n=function(t){var i=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(i,"a",i),i},e.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},e.p="",e(e.s=0)}([function(t,i,e){"use strict";e.r(i);var o,n=function(t,i){var e=i.x-t.x,o=i.y-t.y;return Math.sqrt(e*e+o*o)},s=function(t){return t*(Math.PI/180)},r=function(t){return t*(180/Math.PI)},d=new Map,a=function(t){d.has(t)&&clearTimeout(d.get(t)),d.set(t,setTimeout(t,100))},p=function(t,i,e){for(var o,n=i.split(/[ ,]+/g),s=0;s<n.length;s+=1)o=n[s],t.addEventListener?t.addEventListener(o,e,!1):t.attachEvent&&t.attachEvent(o,e)},c=function(t,i,e){for(var o,n=i.split(/[ ,]+/g),s=0;s<n.length;s+=1)o=n[s],t.removeEventListener?t.removeEventListener(o,e):t.detachEvent&&t.detachEvent(o,e)},l=function(t){return t.preventDefault(),t.type.match(/^touch/)?t.changedTouches:t},h=function(){return{x:void 0!==window.pageXOffset?window.pageXOffset:(document.documentElement||document.body.parentNode||document.body).scrollLeft,y:void 0!==window.pageYOffset?window.pageYOffset:(document.documentElement||document.body.parentNode||document.body).scrollTop}},u=function(t,i){i.top||i.right||i.bottom||i.left?(t.style.top=i.top,t.style.right=i.right,t.style.bottom=i.bottom,t.style.left=i.left):(t.style.left=i.x+"px",t.style.top=i.y+"px")},f=function(t,i,e){var o=y(t);for(var n in o)if(o.hasOwnProperty(n))if("string"==typeof i)o[n]=i+" "+e;else{for(var s="",r=0,d=i.length;r<d;r+=1)s+=i[r]+" "+e+", ";o[n]=s.slice(0,-2)}return o},y=function(t){var i={};i[t]="";return["webkit","Moz","o"].forEach(function(e){i[e+t.charAt(0).toUpperCase()+t.slice(1)]=""}),i},m=function(t,i){for(var e in i)i.hasOwnProperty(e)&&(t[e]=i[e]);return t},v=function(t,i){if(t.length)for(var e=0,o=t.length;e<o;e+=1)i(t[e]);else i(t)},g=!!("ontouchstart"in window),b=!!window.PointerEvent,x=!!window.MSPointerEvent,O={start:"mousedown",move:"mousemove",end:"mouseup"},w={};function _(){}b?o={start:"pointerdown",move:"pointermove",end:"pointerup, pointercancel"}:x?o={start:"MSPointerDown",move:"MSPointerMove",end:"MSPointerUp"}:g?(o={start:"touchstart",move:"touchmove",end:"touchend, touchcancel"},w=O):o=O,_.prototype.on=function(t,i){var e,o=t.split(/[ ,]+/g);this._handlers_=this._handlers_||{};for(var n=0;n<o.length;n+=1)e=o[n],this._handlers_[e]=this._handlers_[e]||[],this._handlers_[e].push(i);return this},_.prototype.off=function(t,i){return this._handlers_=this._handlers_||{},void 0===t?this._handlers_={}:void 0===i?this._handlers_[t]=null:this._handlers_[t]&&this._handlers_[t].indexOf(i)>=0&&this._handlers_[t].splice(this._handlers_[t].indexOf(i),1),this},_.prototype.trigger=function(t,i){var e,o=this,n=t.split(/[ ,]+/g);o._handlers_=o._handlers_||{};for(var s=0;s<n.length;s+=1)e=n[s],o._handlers_[e]&&o._handlers_[e].length&&o._handlers_[e].forEach(function(t){t.call(o,{type:e,target:o},i)})},_.prototype.config=function(t){this.options=this.defaults||{},t&&(this.options=function(t,i){var e={};for(var o in t)t.hasOwnProperty(o)&&i.hasOwnProperty(o)?e[o]=i[o]:t.hasOwnProperty(o)&&(e[o]=t[o]);return e}(this.options,t))},_.prototype.bindEvt=function(t,i){var e=this;return e._domHandlers_=e._domHandlers_||{},e._domHandlers_[i]=function(){"function"==typeof e["on"+i]?e["on"+i].apply(e,arguments):console.warn('[WARNING] : Missing "on'+i+'" handler.')},p(t,o[i],e._domHandlers_[i]),w[i]&&p(t,w[i],e._domHandlers_[i]),e},_.prototype.unbindEvt=function(t,i){return this._domHandlers_=this._domHandlers_||{},c(t,o[i],this._domHandlers_[i]),w[i]&&c(t,w[i],this._domHandlers_[i]),delete this._domHandlers_[i],this};var T=_;function k(t,i){return this.identifier=i.identifier,this.position=i.position,this.frontPosition=i.frontPosition,this.collection=t,this.defaults={size:100,threshold:.1,color:"white",fadeTime:250,dataOnly:!1,restJoystick:!0,restOpacity:.5,mode:"dynamic",zone:document.body,lockX:!1,lockY:!1,shape:"circle"},this.config(i),"dynamic"===this.options.mode&&(this.options.restOpacity=0),this.id=k.id,k.id+=1,this.buildEl().stylize(),this.instance={el:this.ui.el,on:this.on.bind(this),off:this.off.bind(this),show:this.show.bind(this),hide:this.hide.bind(this),add:this.addToDom.bind(this),remove:this.removeFromDom.bind(this),destroy:this.destroy.bind(this),setPosition:this.setPosition.bind(this),resetDirection:this.resetDirection.bind(this),computeDirection:this.computeDirection.bind(this),trigger:this.trigger.bind(this),position:this.position,frontPosition:this.frontPosition,ui:this.ui,identifier:this.identifier,id:this.id,options:this.options},this.instance}k.prototype=new T,k.constructor=k,k.id=0,k.prototype.buildEl=function(t){return this.ui={},this.options.dataOnly?this:(this.ui.el=document.createElement("div"),this.ui.back=document.createElement("div"),this.ui.front=document.createElement("div"),this.ui.el.className="nipple collection_"+this.collection.id,this.ui.back.className="back",this.ui.front.className="front",this.ui.el.setAttribute("id","nipple_"+this.collection.id+"_"+this.id),this.ui.el.appendChild(this.ui.back),this.ui.el.appendChild(this.ui.front),this)},k.prototype.stylize=function(){if(this.options.dataOnly)return this;var t=this.options.fadeTime+"ms",i=function(t,i){var e=y(t);for(var o in e)e.hasOwnProperty(o)&&(e[o]=i);return e}("borderRadius","50%"),e=f("transition","opacity",t),o={};return o.el={position:"absolute",opacity:this.options.restOpacity,display:"block",zIndex:999},o.back={position:"absolute",display:"block",width:this.options.size+"px",height:this.options.size+"px",left:0,marginLeft:-this.options.size/2+"px",marginTop:-this.options.size/2+"px",background:this.options.color,opacity:".5"},o.front={width:this.options.size/2+"px",height:this.options.size/2+"px",position:"absolute",display:"block",left:0,marginLeft:-this.options.size/4+"px",marginTop:-this.options.size/4+"px",background:this.options.color,opacity:".5",transform:"translate(0px, 0px)"},m(o.el,e),"circle"===this.options.shape&&m(o.back,i),m(o.front,i),this.applyStyles(o),this},k.prototype.applyStyles=function(t){for(var i in this.ui)if(this.ui.hasOwnProperty(i))for(var e in t[i])this.ui[i].style[e]=t[i][e];return this},k.prototype.addToDom=function(){return this.options.dataOnly||document.body.contains(this.ui.el)?this:(this.options.zone.appendChild(this.ui.el),this)},k.prototype.removeFromDom=function(){return this.options.dataOnly||!document.body.contains(this.ui.el)?this:(this.options.zone.removeChild(this.ui.el),this)},k.prototype.destroy=function(){clearTimeout(this.removeTimeout),clearTimeout(this.showTimeout),clearTimeout(this.restTimeout),this.trigger("destroyed",this.instance),this.removeFromDom(),this.off()},k.prototype.show=function(t){var i=this;return i.options.dataOnly?i:(clearTimeout(i.removeTimeout),clearTimeout(i.showTimeout),clearTimeout(i.restTimeout),i.addToDom(),i.restCallback(),setTimeout(function(){i.ui.el.style.opacity=1},0),i.showTimeout=setTimeout(function(){i.trigger("shown",i.instance),"function"==typeof t&&t.call(this)},i.options.fadeTime),i)},k.prototype.hide=function(t){var i=this;if(i.options.dataOnly)return i;if(i.ui.el.style.opacity=i.options.restOpacity,clearTimeout(i.removeTimeout),clearTimeout(i.showTimeout),clearTimeout(i.restTimeout),i.removeTimeout=setTimeout(function(){var e="dynamic"===i.options.mode?"none":"block";i.ui.el.style.display=e,"function"==typeof t&&t.call(i),i.trigger("hidden",i.instance)},i.options.fadeTime),i.options.restJoystick){var e=i.options.restJoystick,o={};o.x=!0===e||!1!==e.x?0:i.instance.frontPosition.x,o.y=!0===e||!1!==e.y?0:i.instance.frontPosition.y,i.setPosition(t,o)}return i},k.prototype.setPosition=function(t,i){var e=this;e.frontPosition={x:i.x,y:i.y};var o=e.options.fadeTime+"ms",n={};n.front=f("transition",["transform"],o);var s={front:{}};s.front={transform:"translate("+e.frontPosition.x+"px,"+e.frontPosition.y+"px)"},e.applyStyles(n),e.applyStyles(s),e.restTimeout=setTimeout(function(){"function"==typeof t&&t.call(e),e.restCallback()},e.options.fadeTime)},k.prototype.restCallback=function(){var t={};t.front=f("transition","none",""),this.applyStyles(t),this.trigger("rested",this.instance)},k.prototype.resetDirection=function(){this.direction={x:!1,y:!1,angle:!1}},k.prototype.computeDirection=function(t){var i,e,o,n=t.angle.radian,s=Math.PI/4,r=Math.PI/2;if(n>s&&n<3*s&&!t.lockX?i="up":n>-s&&n<=s&&!t.lockY?i="left":n>3*-s&&n<=-s&&!t.lockX?i="down":t.lockY||(i="right"),t.lockY||(e=n>-r&&n<r?"left":"right"),t.lockX||(o=n>0?"up":"down"),t.force>this.options.threshold){var d,a={};for(d in this.direction)this.direction.hasOwnProperty(d)&&(a[d]=this.direction[d]);var p={};for(d in this.direction={x:e,y:o,angle:i},t.direction=this.direction,a)a[d]===this.direction[d]&&(p[d]=!0);if(p.x&&p.y&&p.angle)return t;p.x&&p.y||this.trigger("plain",t),p.x||this.trigger("plain:"+e,t),p.y||this.trigger("plain:"+o,t),p.angle||this.trigger("dir dir:"+i,t)}else this.resetDirection();return t};var P=k;function E(t,i){this.nipples=[],this.idles=[],this.actives=[],this.ids=[],this.pressureIntervals={},this.manager=t,this.id=E.id,E.id+=1,this.defaults={zone:document.body,multitouch:!1,maxNumberOfNipples:10,mode:"dynamic",position:{top:0,left:0},catchDistance:200,size:100,threshold:.1,color:"white",fadeTime:250,dataOnly:!1,restJoystick:!0,restOpacity:.5,lockX:!1,lockY:!1,shape:"circle",dynamicPage:!1,follow:!1},this.config(i),"static"!==this.options.mode&&"semi"!==this.options.mode||(this.options.multitouch=!1),this.options.multitouch||(this.options.maxNumberOfNipples=1);var e=getComputedStyle(this.options.zone.parentElement);return e&&"flex"===e.display&&(this.parentIsFlex=!0),this.updateBox(),this.prepareNipples(),this.bindings(),this.begin(),this.nipples}E.prototype=new T,E.constructor=E,E.id=0,E.prototype.prepareNipples=function(){var t=this.nipples;t.on=this.on.bind(this),t.off=this.off.bind(this),t.options=this.options,t.destroy=this.destroy.bind(this),t.ids=this.ids,t.id=this.id,t.processOnMove=this.processOnMove.bind(this),t.processOnEnd=this.processOnEnd.bind(this),t.get=function(i){if(void 0===i)return t[0];for(var e=0,o=t.length;e<o;e+=1)if(t[e].identifier===i)return t[e];return!1}},E.prototype.bindings=function(){this.bindEvt(this.options.zone,"start"),this.options.zone.style.touchAction="none",this.options.zone.style.msTouchAction="none"},E.prototype.begin=function(){var t=this.options;if("static"===t.mode){var i=this.createNipple(t.position,this.manager.getIdentifier());i.add(),this.idles.push(i)}},E.prototype.createNipple=function(t,i){var e=this.manager.scroll,o={},n=this.options,s=this.parentIsFlex?e.x:e.x+this.box.left,r=this.parentIsFlex?e.y:e.y+this.box.top;if(t.x&&t.y)o={x:t.x-s,y:t.y-r};else if(t.top||t.right||t.bottom||t.left){var d=document.createElement("DIV");d.style.display="hidden",d.style.top=t.top,d.style.right=t.right,d.style.bottom=t.bottom,d.style.left=t.left,d.style.position="absolute",n.zone.appendChild(d);var a=d.getBoundingClientRect();n.zone.removeChild(d),o=t,t={x:a.left+e.x,y:a.top+e.y}}var p=new P(this,{color:n.color,size:n.size,threshold:n.threshold,fadeTime:n.fadeTime,dataOnly:n.dataOnly,restJoystick:n.restJoystick,restOpacity:n.restOpacity,mode:n.mode,identifier:i,position:t,zone:n.zone,frontPosition:{x:0,y:0},shape:n.shape});return n.dataOnly||(u(p.ui.el,o),u(p.ui.front,p.frontPosition)),this.nipples.push(p),this.trigger("added "+p.identifier+":added",p),this.manager.trigger("added "+p.identifier+":added",p),this.bindNipple(p),p},E.prototype.updateBox=function(){this.box=this.options.zone.getBoundingClientRect()},E.prototype.bindNipple=function(t){var i,e=this,o=function(t,o){i=t.type+" "+o.id+":"+t.type,e.trigger(i,o)};t.on("destroyed",e.onDestroyed.bind(e)),t.on("shown hidden rested dir plain",o),t.on("dir:up dir:right dir:down dir:left",o),t.on("plain:up plain:right plain:down plain:left",o)},E.prototype.pressureFn=function(t,i,e){var o=this,n=0;clearInterval(o.pressureIntervals[e]),o.pressureIntervals[e]=setInterval(function(){var e=t.force||t.pressure||t.webkitForce||0;e!==n&&(i.trigger("pressure",e),o.trigger("pressure "+i.identifier+":pressure",e),n=e)}.bind(o),100)},E.prototype.onstart=function(t){var i=this,e=i.options,o=t;t=l(t),i.updateBox();return v(t,function(n){i.actives.length<e.maxNumberOfNipples?i.processOnStart(n):o.type.match(/^touch/)&&(Object.keys(i.manager.ids).forEach(function(e){if(Object.values(o.touches).findIndex(function(t){return t.identifier===e})<0){var n=[t[0]];n.identifier=e,i.processOnEnd(n)}}),i.actives.length<e.maxNumberOfNipples&&i.processOnStart(n))}),i.manager.bindDocument(),!1},E.prototype.processOnStart=function(t){var i,e=this,o=e.options,s=e.manager.getIdentifier(t),r=t.force||t.pressure||t.webkitForce||0,d={x:t.pageX,y:t.pageY},a=e.getOrCreate(s,d);a.identifier!==s&&e.manager.removeIdentifier(a.identifier),a.identifier=s;var p=function(i){i.trigger("start",i),e.trigger("start "+i.id+":start",i),i.show(),r>0&&e.pressureFn(t,i,i.identifier),e.processOnMove(t)};if((i=e.idles.indexOf(a))>=0&&e.idles.splice(i,1),e.actives.push(a),e.ids.push(a.identifier),"semi"!==o.mode)p(a);else{if(!(n(d,a.position)<=o.catchDistance))return a.destroy(),void e.processOnStart(t);p(a)}return a},E.prototype.getOrCreate=function(t,i){var e,o=this.options;return/(semi|static)/.test(o.mode)?(e=this.idles[0])?(this.idles.splice(0,1),e):"semi"===o.mode?this.createNipple(i,t):(console.warn("Coudln't find the needed nipple."),!1):e=this.createNipple(i,t)},E.prototype.processOnMove=function(t){var i=this.options,e=this.manager.getIdentifier(t),o=this.nipples.get(e),d=this.manager.scroll;if(function(t){return isNaN(t.buttons)?0!==t.pressure:0!==t.buttons}(t)){if(!o)return console.error("Found zombie joystick with ID "+e),void this.manager.removeIdentifier(e);if(i.dynamicPage){var a=o.el.getBoundingClientRect();o.position={x:d.x+a.left,y:d.y+a.top}}o.identifier=e;var p=o.options.size/2,c={x:t.pageX,y:t.pageY};i.lockX&&(c.y=o.position.y),i.lockY&&(c.x=o.position.x);var l,h,u,f,y,m,v,g,b,x,O=n(c,o.position),w=(l=c,h=o.position,u=h.x-l.x,f=h.y-l.y,r(Math.atan2(f,u))),_=s(w),T=O/p,k={distance:O,position:c};if("circle"===o.options.shape?(y=Math.min(O,p),v=o.position,g=y,x={x:0,y:0},b=s(b=w),x.x=v.x-g*Math.cos(b),x.y=v.y-g*Math.sin(b),m=x):(m=function(t,i,e){return{x:Math.min(Math.max(t.x,i.x-e),i.x+e),y:Math.min(Math.max(t.y,i.y-e),i.y+e)}}(c,o.position,p),y=n(m,o.position)),i.follow){if(O>p){var P=c.x-m.x,E=c.y-m.y;o.position.x+=P,o.position.y+=E,o.el.style.top=o.position.y-(this.box.top+d.y)+"px",o.el.style.left=o.position.x-(this.box.left+d.x)+"px",O=n(c,o.position)}}else c=m,O=y;var I=c.x-o.position.x,z=c.y-o.position.y;o.frontPosition={x:I,y:z},i.dataOnly||(o.ui.front.style.transform="translate("+I+"px,"+z+"px)");var D={identifier:o.identifier,position:c,force:T,pressure:t.force||t.pressure||t.webkitForce||0,distance:O,angle:{radian:_,degree:w},vector:{x:I/p,y:-z/p},raw:k,instance:o,lockX:i.lockX,lockY:i.lockY};(D=o.computeDirection(D)).angle={radian:s(180-w),degree:180-w},o.trigger("move",D),this.trigger("move "+o.id+":move",D)}else this.processOnEnd(t)},E.prototype.processOnEnd=function(t){var i=this,e=i.options,o=i.manager.getIdentifier(t),n=i.nipples.get(o),s=i.manager.removeIdentifier(n.identifier);n&&(e.dataOnly||n.hide(function(){"dynamic"===e.mode&&(n.trigger("removed",n),i.trigger("removed "+n.id+":removed",n),i.manager.trigger("removed "+n.id+":removed",n),n.destroy())}),clearInterval(i.pressureIntervals[n.identifier]),n.resetDirection(),n.trigger("end",n),i.trigger("end "+n.id+":end",n),i.ids.indexOf(n.identifier)>=0&&i.ids.splice(i.ids.indexOf(n.identifier),1),i.actives.indexOf(n)>=0&&i.actives.splice(i.actives.indexOf(n),1),/(semi|static)/.test(e.mode)?i.idles.push(n):i.nipples.indexOf(n)>=0&&i.nipples.splice(i.nipples.indexOf(n),1),i.manager.unbindDocument(),/(semi|static)/.test(e.mode)&&(i.manager.ids[s.id]=s.identifier))},E.prototype.onDestroyed=function(t,i){this.nipples.indexOf(i)>=0&&this.nipples.splice(this.nipples.indexOf(i),1),this.actives.indexOf(i)>=0&&this.actives.splice(this.actives.indexOf(i),1),this.idles.indexOf(i)>=0&&this.idles.splice(this.idles.indexOf(i),1),this.ids.indexOf(i.identifier)>=0&&this.ids.splice(this.ids.indexOf(i.identifier),1),this.manager.removeIdentifier(i.identifier),this.manager.unbindDocument()},E.prototype.destroy=function(){for(var t in this.unbindEvt(this.options.zone,"start"),this.nipples.forEach(function(t){t.destroy()}),this.pressureIntervals)this.pressureIntervals.hasOwnProperty(t)&&clearInterval(this.pressureIntervals[t]);this.trigger("destroyed",this.nipples),this.manager.unbindDocument(),this.off()};var I=E;function z(t){var i=this;i.ids={},i.index=0,i.collections=[],i.scroll=h(),i.config(t),i.prepareCollections();var e=function(){var t;i.collections.forEach(function(e){e.forEach(function(e){t=e.el.getBoundingClientRect(),e.position={x:i.scroll.x+t.left,y:i.scroll.y+t.top}})})};p(window,"resize",function(){a(e)});var o=function(){i.scroll=h()};return p(window,"scroll",function(){a(o)}),i.collections}z.prototype=new T,z.constructor=z,z.prototype.prepareCollections=function(){var t=this;t.collections.create=t.create.bind(t),t.collections.on=t.on.bind(t),t.collections.off=t.off.bind(t),t.collections.destroy=t.destroy.bind(t),t.collections.get=function(i){var e;return t.collections.every(function(t){return!(e=t.get(i))}),e}},z.prototype.create=function(t){return this.createCollection(t)},z.prototype.createCollection=function(t){var i=new I(this,t);return this.bindCollection(i),this.collections.push(i),i},z.prototype.bindCollection=function(t){var i,e=this,o=function(t,o){i=t.type+" "+o.id+":"+t.type,e.trigger(i,o)};t.on("destroyed",e.onDestroyed.bind(e)),t.on("shown hidden rested dir plain",o),t.on("dir:up dir:right dir:down dir:left",o),t.on("plain:up plain:right plain:down plain:left",o)},z.prototype.bindDocument=function(){this.binded||(this.bindEvt(document,"move").bindEvt(document,"end"),this.binded=!0)},z.prototype.unbindDocument=function(t){Object.keys(this.ids).length&&!0!==t||(this.unbindEvt(document,"move").unbindEvt(document,"end"),this.binded=!1)},z.prototype.getIdentifier=function(t){var i;return t?void 0===(i=void 0===t.identifier?t.pointerId:t.identifier)&&(i=this.latest||0):i=this.index,void 0===this.ids[i]&&(this.ids[i]=this.index,this.index+=1),this.latest=i,this.ids[i]},z.prototype.removeIdentifier=function(t){var i={};for(var e in this.ids)if(this.ids[e]===t){i.id=e,i.identifier=this.ids[e],delete this.ids[e];break}return i},z.prototype.onmove=function(t){return this.onAny("move",t),!1},z.prototype.onend=function(t){return this.onAny("end",t),!1},z.prototype.oncancel=function(t){return this.onAny("end",t),!1},z.prototype.onAny=function(t,i){var e,o=this,n="processOn"+t.charAt(0).toUpperCase()+t.slice(1);i=l(i);return v(i,function(t){e=o.getIdentifier(t),v(o.collections,function(t,i,e){e.ids.indexOf(i)>=0&&(e[n](t),t._found_=!0)}.bind(null,t,e)),t._found_||o.removeIdentifier(e)}),!1},z.prototype.destroy=function(){this.unbindDocument(!0),this.ids={},this.index=0,this.collections.forEach(function(t){t.destroy()}),this.off()},z.prototype.onDestroyed=function(t,i){if(this.collections.indexOf(i)<0)return!1;this.collections.splice(this.collections.indexOf(i),1)};var D=new z;i.default={create:function(t){return D.create(t)},factory:D}}]).default});

/**
 * Shader configuration format:
 *
 * Default format, shader code in string:
 * "shader_name": "...",
 *
 * Advanced format, shader code in multiple files:
 * "shader_name": {
 *    //main shader file
 *    "shader": {
 *      "type": "text|base64",  //value type, "text" - plain text, "base64" - encoded with Base64
 *      "value": "...",         //main shader file value
 *    },
 *    //additional resources
 *    "resources": [
 *        {
 *            "name": "resource_file_name", //file name of resource. Note: all files will be placed in the same directory
 *            "type": "text|base64",        //resource value type, see "type" of main shader file
 *            "value": "...",               //resource file value
 *        },
 *        ...
 *    ],
 *  }
 */
window.EJS_SHADERS = {
    //https://github.com/libretro/glsl-shaders/blob/master/scalehq/2xScaleHQ.glslp
    "2xScaleHQ.glslp": {
        "shader": {
            "type": "text",
            "value": "shaders = 1\n\nshader0 = \"2xScaleHQ.glsl\"\nfilter_linear0 = false\nscale_type_0 = source\n",
        },
        "resources": [
            {
                "name": "2xScaleHQ.glsl",
                "type": "base64",
                "value": "LyoKICAgMnhHTFNMSHFGaWx0ZXIgc2hhZGVyCiAgIAogICBDb3B5cmlnaHQgKEMpIDIwMDUgZ3Vlc3QocikgLSBndWVzdC5yQGdtYWlsLmNvbQoKICAgVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vcgogICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogICBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyIHZlcnNpb24gMgogICBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi4KCiAgIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLAogICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZgogICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlCiAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuCgogICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogICBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZQogICBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgIDAyMTExLTEzMDcsIFVTQS4KKi8KCiNpZiBkZWZpbmVkKFZFUlRFWCkKCiNpZiBfX1ZFUlNJT05fXyA+PSAxMzAKI2RlZmluZSBDT01QQVRfVkFSWUlORyBvdXQKI2RlZmluZSBDT01QQVRfQVRUUklCVVRFIGluCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZQojZWxzZQojZGVmaW5lIENPTVBBVF9WQVJZSU5HIHZhcnlpbmcgCiNkZWZpbmUgQ09NUEFUX0FUVFJJQlVURSBhdHRyaWJ1dGUgCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZTJECiNlbmRpZgoKI2lmZGVmIEdMX0VTCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTiBtZWRpdW1wCiNlbHNlCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTgojZW5kaWYKCkNPTVBBVF9BVFRSSUJVVEUgdmVjNCBWZXJ0ZXhDb29yZDsKQ09NUEFUX0FUVFJJQlVURSB2ZWM0IENPTE9SOwpDT01QQVRfQVRUUklCVVRFIHZlYzQgVGV4Q29vcmQ7CkNPTVBBVF9WQVJZSU5HIHZlYzQgQ09MMDsKQ09NUEFUX1ZBUllJTkcgdmVjNCBURVgwOwpDT01QQVRfVkFSWUlORyB2ZWM0IHQxOwpDT01QQVRfVkFSWUlORyB2ZWM0IHQyOwpDT01QQVRfVkFSWUlORyB2ZWM0IHQzOwpDT01QQVRfVkFSWUlORyB2ZWM0IHQ0OwoKdmVjNCBfb1Bvc2l0aW9uMTsgCnVuaWZvcm0gbWF0NCBNVlBNYXRyaXg7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVEaXJlY3Rpb247CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVDb3VudDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgT3V0cHV0U2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgVGV4dHVyZVNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIElucHV0U2l6ZTsKCi8vIGNvbXBhdGliaWxpdHkgI2RlZmluZXMKI2RlZmluZSB2VGV4Q29vcmQgVEVYMC54eQojZGVmaW5lIFNvdXJjZVNpemUgdmVjNChUZXh0dXJlU2l6ZSwgMS4wIC8gVGV4dHVyZVNpemUpIC8vZWl0aGVyIFRleHR1cmVTaXplIG9yIElucHV0U2l6ZQojZGVmaW5lIE91dFNpemUgdmVjNChPdXRwdXRTaXplLCAxLjAgLyBPdXRwdXRTaXplKQoKdm9pZCBtYWluKCkKewogICAgZ2xfUG9zaXRpb24gPSBNVlBNYXRyaXggKiBWZXJ0ZXhDb29yZDsKICAgIFRFWDAueHkgPSBUZXhDb29yZC54eTsKICAgZmxvYXQgeCA9IDAuNSAqIFNvdXJjZVNpemUuejsKICAgZmxvYXQgeSA9IDAuNSAqIFNvdXJjZVNpemUudzsKICAgdmVjMiBkZzEgPSB2ZWMyKCB4LCB5KTsKICAgdmVjMiBkZzIgPSB2ZWMyKC14LCB5KTsKICAgdmVjMiBkeCA9IHZlYzIoeCwgMC4wKTsKICAgdmVjMiBkeSA9IHZlYzIoMC4wLCB5KTsKICAgdDEgPSB2ZWM0KHZUZXhDb29yZCAtIGRnMSwgdlRleENvb3JkIC0gZHkpOwogICB0MiA9IHZlYzQodlRleENvb3JkIC0gZGcyLCB2VGV4Q29vcmQgKyBkeCk7CiAgIHQzID0gdmVjNCh2VGV4Q29vcmQgKyBkZzEsIHZUZXhDb29yZCArIGR5KTsKICAgdDQgPSB2ZWM0KHZUZXhDb29yZCArIGRnMiwgdlRleENvb3JkIC0gZHgpOwp9CgojZWxpZiBkZWZpbmVkKEZSQUdNRU5UKQoKI2lmIF9fVkVSU0lPTl9fID49IDEzMAojZGVmaW5lIENPTVBBVF9WQVJZSU5HIGluCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZQpvdXQgdmVjNCBGcmFnQ29sb3I7CiNlbHNlCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgdmFyeWluZwojZGVmaW5lIEZyYWdDb2xvciBnbF9GcmFnQ29sb3IKI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlMkQKI2VuZGlmCgojaWZkZWYgR0xfRVMKI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdICnByZWNpc2lvbiBoaWdocCBmbG9hdDsKI2Vsc2UKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CiNlbmRpZgojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04gbWVkaXVtcAojZWxzZQojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04KI2VuZGlmCgp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lRGlyZWN0aW9uOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lQ291bnQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIE91dHB1dFNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIFRleHR1cmVTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBJbnB1dFNpemU7CnVuaWZvcm0gc2FtcGxlcjJEIFRleHR1cmU7CkNPTVBBVF9WQVJZSU5HIHZlYzQgVEVYMDsKQ09NUEFUX1ZBUllJTkcgdmVjNCB0MTsKQ09NUEFUX1ZBUllJTkcgdmVjNCB0MjsKQ09NUEFUX1ZBUllJTkcgdmVjNCB0MzsKQ09NUEFUX1ZBUllJTkcgdmVjNCB0NDsKCi8vIGNvbXBhdGliaWxpdHkgI2RlZmluZXMKI2RlZmluZSBTb3VyY2UgVGV4dHVyZQojZGVmaW5lIHZUZXhDb29yZCBURVgwLnh5CgojZGVmaW5lIFNvdXJjZVNpemUgdmVjNChUZXh0dXJlU2l6ZSwgMS4wIC8gVGV4dHVyZVNpemUpIC8vZWl0aGVyIFRleHR1cmVTaXplIG9yIElucHV0U2l6ZQojZGVmaW5lIE91dFNpemUgdmVjNChPdXRwdXRTaXplLCAxLjAgLyBPdXRwdXRTaXplKQoKZmxvYXQgbXggPSAwLjMyNTsgICAgICAvLyBzdGFydCBzbW9vdGhpbmcgd3QuCmZsb2F0IGsgPSAtMC4yNTA7ICAgICAgLy8gd3QuIGRlY3JlYXNlIGZhY3RvcgpmbG9hdCBtYXhfdyA9IDAuMjU7ICAgIC8vIG1heCBmaWx0ZXIgd2VpZ2h0CmZsb2F0IG1pbl93ID0tMC4wNTsgICAgLy8gbWluIGZpbHRlciB3ZWlnaHQKZmxvYXQgbHVtX2FkZCA9IDAuMjU7ICAvLyBhZmZlY3RzIHNtb290aGluZwp2ZWMzIGR0ID0gdmVjMygxLjApOwoKdm9pZCBtYWluKCkKewogICB2ZWMzIGMwMCA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgdDEueHkpLnh5ejsgCiAgIHZlYzMgYzEwID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB0MS56dykueHl6OyAKICAgdmVjMyBjMjAgPSBDT01QQVRfVEVYVFVSRShTb3VyY2UsIHQyLnh5KS54eXo7IAogICB2ZWMzIGMwMSA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgdDQuencpLnh5ejsgCiAgIHZlYzMgYzExID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB2VGV4Q29vcmQpLnh5ejsgCiAgIHZlYzMgYzIxID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB0Mi56dykueHl6OyAKICAgdmVjMyBjMDIgPSBDT01QQVRfVEVYVFVSRShTb3VyY2UsIHQ0Lnh5KS54eXo7IAogICB2ZWMzIGMxMiA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgdDMuencpLnh5ejsgCiAgIHZlYzMgYzIyID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB0My54eSkueHl6OyAKCiAgIGZsb2F0IG1kMSA9IGRvdChhYnMoYzAwIC0gYzIyKSwgZHQpOwogICBmbG9hdCBtZDIgPSBkb3QoYWJzKGMwMiAtIGMyMCksIGR0KTsKCiAgIGZsb2F0IHcxID0gZG90KGFicyhjMjIgLSBjMTEpLCBkdCkgKiBtZDI7CiAgIGZsb2F0IHcyID0gZG90KGFicyhjMDIgLSBjMTEpLCBkdCkgKiBtZDE7CiAgIGZsb2F0IHczID0gZG90KGFicyhjMDAgLSBjMTEpLCBkdCkgKiBtZDI7CiAgIGZsb2F0IHc0ID0gZG90KGFicyhjMjAgLSBjMTEpLCBkdCkgKiBtZDE7CgogICBmbG9hdCB0MSA9IHcxICsgdzM7CiAgIGZsb2F0IHQyID0gdzIgKyB3NDsKICAgZmxvYXQgd3cgPSBtYXgodDEsIHQyKSArIDAuMDAwMTsKCiAgIGMxMSA9ICh3MSAqIGMwMCArIHcyICogYzIwICsgdzMgKiBjMjIgKyB3NCAqIGMwMiArIHd3ICogYzExKSAvICh0MSArIHQyICsgd3cpOwoKICAgZmxvYXQgbGMxID0gayAvICgwLjEyICogZG90KGMxMCArIGMxMiArIGMxMSwgZHQpICsgbHVtX2FkZCk7CiAgIGZsb2F0IGxjMiA9IGsgLyAoMC4xMiAqIGRvdChjMDEgKyBjMjEgKyBjMTEsIGR0KSArIGx1bV9hZGQpOwoKICAgdzEgPSBjbGFtcChsYzEgKiBkb3QoYWJzKGMxMSAtIGMxMCksIGR0KSArIG14LCBtaW5fdywgbWF4X3cpOwogICB3MiA9IGNsYW1wKGxjMiAqIGRvdChhYnMoYzExIC0gYzIxKSwgZHQpICsgbXgsIG1pbl93LCBtYXhfdyk7CiAgIHczID0gY2xhbXAobGMxICogZG90KGFicyhjMTEgLSBjMTIpLCBkdCkgKyBteCwgbWluX3csIG1heF93KTsKICAgdzQgPSBjbGFtcChsYzIgKiBkb3QoYWJzKGMxMSAtIGMwMSksIGR0KSArIG14LCBtaW5fdywgbWF4X3cpOwogICBGcmFnQ29sb3IgPSB2ZWM0KHcxICogYzEwICsgdzIgKiBjMjEgKyB3MyAqIGMxMiArIHc0ICogYzAxICsgKDEuMCAtIHcxIC0gdzIgLSB3MyAtIHc0KSAqIGMxMSwgMS4wKTsKfSAKI2VuZGlmCg==",
            }
        ],
    },

    //https://github.com/libretro/glsl-shaders/blob/master/scalehq/4xScaleHQ.glslp
    "4xScaleHQ.glslp": {
        "shader": {
            "type": "text",
            "value": "shaders = 1\n\nshader0 = \"4xScaleHQ.glsl\"\nfilter_linear0 = false\nscale_type_0 = source\n",
        },
        "resources": [
            {
                "name": "4xScaleHQ.glsl",
                "type": "base64",
                "value": "LyoKICAgNHhHTFNMSHFGaWx0ZXIgc2hhZGVyCiAgIAogICBDb3B5cmlnaHQgKEMpIDIwMDUgZ3Vlc3QocikgLSBndWVzdC5yQGdtYWlsLmNvbQoKICAgVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vcgogICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogICBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyIHZlcnNpb24gMgogICBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi4KCiAgIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLAogICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZgogICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlCiAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuCgogICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQogICBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZQogICBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgIDAyMTExLTEzMDcsIFVTQS4KKi8KCiNpZiBkZWZpbmVkKFZFUlRFWCkKCiNpZiBfX1ZFUlNJT05fXyA+PSAxMzAKI2RlZmluZSBDT01QQVRfVkFSWUlORyBvdXQKI2RlZmluZSBDT01QQVRfQVRUUklCVVRFIGluCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZQojZWxzZQojZGVmaW5lIENPTVBBVF9WQVJZSU5HIHZhcnlpbmcgCiNkZWZpbmUgQ09NUEFUX0FUVFJJQlVURSBhdHRyaWJ1dGUgCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZTJECiNlbmRpZgoKI2lmZGVmIEdMX0VTCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTiBtZWRpdW1wCiNlbHNlCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTgojZW5kaWYKCkNPTVBBVF9BVFRSSUJVVEUgdmVjNCBWZXJ0ZXhDb29yZDsKQ09NUEFUX0FUVFJJQlVURSB2ZWM0IENPTE9SOwpDT01QQVRfQVRUUklCVVRFIHZlYzQgVGV4Q29vcmQ7CkNPTVBBVF9WQVJZSU5HIHZlYzQgQ09MMDsKQ09NUEFUX1ZBUllJTkcgdmVjNCBURVgwOwpDT01QQVRfVkFSWUlORyB2ZWM0IHQxOwpDT01QQVRfVkFSWUlORyB2ZWM0IHQyOwpDT01QQVRfVkFSWUlORyB2ZWM0IHQzOwpDT01QQVRfVkFSWUlORyB2ZWM0IHQ0OwpDT01QQVRfVkFSWUlORyB2ZWM0IHQ1OwpDT01QQVRfVkFSWUlORyB2ZWM0IHQ2OwoKdmVjNCBfb1Bvc2l0aW9uMTsgCnVuaWZvcm0gbWF0NCBNVlBNYXRyaXg7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVEaXJlY3Rpb247CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVDb3VudDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgT3V0cHV0U2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgVGV4dHVyZVNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIElucHV0U2l6ZTsKCi8vIGNvbXBhdGliaWxpdHkgI2RlZmluZXMKI2RlZmluZSB2VGV4Q29vcmQgVEVYMC54eQojZGVmaW5lIFNvdXJjZVNpemUgdmVjNChUZXh0dXJlU2l6ZSwgMS4wIC8gVGV4dHVyZVNpemUpIC8vZWl0aGVyIFRleHR1cmVTaXplIG9yIElucHV0U2l6ZQojZGVmaW5lIE91dFNpemUgdmVjNChPdXRwdXRTaXplLCAxLjAgLyBPdXRwdXRTaXplKQoKdm9pZCBtYWluKCkKewogICAgZ2xfUG9zaXRpb24gPSBNVlBNYXRyaXggKiBWZXJ0ZXhDb29yZDsKICAgIFRFWDAueHkgPSBUZXhDb29yZC54eTsKICAgZmxvYXQgeCA9IDAuNSAqIFNvdXJjZVNpemUuejsKICAgZmxvYXQgeSA9IDAuNSAqIFNvdXJjZVNpemUudzsKICAgdmVjMiBkZzEgPSB2ZWMyKCB4LCB5KTsKICAgdmVjMiBkZzIgPSB2ZWMyKC14LCB5KTsKICAgdmVjMiBzZDEgPSBkZzEgKiAwLjU7CiAgIHZlYzIgc2QyID0gZGcyICogMC41OwogICB2ZWMyIGRkeCA9IHZlYzIoeCwgMC4wKTsKICAgdmVjMiBkZHkgPSB2ZWMyKDAuMCwgeSk7CiAgIHQxID0gdmVjNCh2VGV4Q29vcmQgLSBzZDEsIHZUZXhDb29yZCAtIGRkeSk7CiAgIHQyID0gdmVjNCh2VGV4Q29vcmQgLSBzZDIsIHZUZXhDb29yZCArIGRkeCk7CiAgIHQzID0gdmVjNCh2VGV4Q29vcmQgKyBzZDEsIHZUZXhDb29yZCArIGRkeSk7CiAgIHQ0ID0gdmVjNCh2VGV4Q29vcmQgKyBzZDIsIHZUZXhDb29yZCAtIGRkeCk7CiAgIHQ1ID0gdmVjNCh2VGV4Q29vcmQgLSBkZzEsIHZUZXhDb29yZCAtIGRnMik7CiAgIHQ2ID0gdmVjNCh2VGV4Q29vcmQgKyBkZzEsIHZUZXhDb29yZCArIGRnMik7Cn0KCiNlbGlmIGRlZmluZWQoRlJBR01FTlQpCgojaWYgX19WRVJTSU9OX18gPj0gMTMwCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgaW4KI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlCm91dCB2ZWM0IEZyYWdDb2xvcjsKI2Vsc2UKI2RlZmluZSBDT01QQVRfVkFSWUlORyB2YXJ5aW5nCiNkZWZpbmUgRnJhZ0NvbG9yIGdsX0ZyYWdDb2xvcgojZGVmaW5lIENPTVBBVF9URVhUVVJFIHRleHR1cmUyRAojZW5kaWYKCiNpZmRlZiBHTF9FUwojaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gKcHJlY2lzaW9uIGhpZ2hwIGZsb2F0OwojZWxzZQpwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKI2VuZGlmCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTiBtZWRpdW1wCiNlbHNlCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTgojZW5kaWYKCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVEaXJlY3Rpb247CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVDb3VudDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgT3V0cHV0U2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgVGV4dHVyZVNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIElucHV0U2l6ZTsKdW5pZm9ybSBzYW1wbGVyMkQgVGV4dHVyZTsKQ09NUEFUX1ZBUllJTkcgdmVjNCBURVgwOwpDT01QQVRfVkFSWUlORyB2ZWM0IHQxOwpDT01QQVRfVkFSWUlORyB2ZWM0IHQyOwpDT01QQVRfVkFSWUlORyB2ZWM0IHQzOwpDT01QQVRfVkFSWUlORyB2ZWM0IHQ0OwpDT01QQVRfVkFSWUlORyB2ZWM0IHQ1OwpDT01QQVRfVkFSWUlORyB2ZWM0IHQ2OwoKLy8gY29tcGF0aWJpbGl0eSAjZGVmaW5lcwojZGVmaW5lIFNvdXJjZSBUZXh0dXJlCiNkZWZpbmUgdlRleENvb3JkIFRFWDAueHkKCiNkZWZpbmUgU291cmNlU2l6ZSB2ZWM0KFRleHR1cmVTaXplLCAxLjAgLyBUZXh0dXJlU2l6ZSkgLy9laXRoZXIgVGV4dHVyZVNpemUgb3IgSW5wdXRTaXplCiNkZWZpbmUgT3V0U2l6ZSB2ZWM0KE91dHB1dFNpemUsIDEuMCAvIE91dHB1dFNpemUpCgpmbG9hdCBteCA9IDEuMDsgICAgICAvLyBzdGFydCBzbW9vdGhpbmcgd3QuCmZsb2F0IGsgPSAtMS4xMDsgICAgICAvLyB3dC4gZGVjcmVhc2UgZmFjdG9yCmZsb2F0IG1heF93ID0gMC43NTsgICAgLy8gbWF4IGZpbHRlciB3ZWlnaHQKZmxvYXQgbWluX3cgPSAwLjAzOyAgICAvLyBtaW4gZmlsdGVyIHdlaWdodApmbG9hdCBsdW1fYWRkID0gMC4zMzsgIC8vIGFmZmVjdHMgc21vb3RoaW5nCnZlYzMgZHQgPSB2ZWMzKDEuMCk7Cgp2b2lkIG1haW4oKQp7CiAgIHZlYzMgYyAgPSBDT01QQVRfVEVYVFVSRShTb3VyY2UsIHZUZXhDb29yZCkueHl6OwogICB2ZWMzIGkxID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB0MS54eSkueHl6OyAKICAgdmVjMyBpMiA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgdDIueHkpLnh5ejsgCiAgIHZlYzMgaTMgPSBDT01QQVRfVEVYVFVSRShTb3VyY2UsIHQzLnh5KS54eXo7IAogICB2ZWMzIGk0ID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB0NC54eSkueHl6OyAKICAgdmVjMyBvMSA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgdDUueHkpLnh5ejsgCiAgIHZlYzMgbzMgPSBDT01QQVRfVEVYVFVSRShTb3VyY2UsIHQ2Lnh5KS54eXo7IAogICB2ZWMzIG8yID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB0NS56dykueHl6OwogICB2ZWMzIG80ID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB0Ni56dykueHl6OwogICB2ZWMzIHMxID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB0MS56dykueHl6OyAKICAgdmVjMyBzMiA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgdDIuencpLnh5ejsgCiAgIHZlYzMgczMgPSBDT01QQVRfVEVYVFVSRShTb3VyY2UsIHQzLnp3KS54eXo7IAogICB2ZWMzIHM0ID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB0NC56dykueHl6OyAKCiAgIGZsb2F0IGtvMT1kb3QoYWJzKG8xLWMpLGR0KTsKICAgZmxvYXQga28yPWRvdChhYnMobzItYyksZHQpOwogICBmbG9hdCBrbzM9ZG90KGFicyhvMy1jKSxkdCk7CiAgIGZsb2F0IGtvND1kb3QoYWJzKG80LWMpLGR0KTsKCiAgIGZsb2F0IGsxPW1pbihkb3QoYWJzKGkxLWkzKSxkdCksbWF4KGtvMSxrbzMpKTsKICAgZmxvYXQgazI9bWluKGRvdChhYnMoaTItaTQpLGR0KSxtYXgoa28yLGtvNCkpOwoKICAgZmxvYXQgdzEgPSBrMjsgaWYoa28zPGtvMSkgdzEqPWtvMy9rbzE7CiAgIGZsb2F0IHcyID0gazE7IGlmKGtvNDxrbzIpIHcyKj1rbzQva28yOwogICBmbG9hdCB3MyA9IGsyOyBpZihrbzE8a28zKSB3Myo9a28xL2tvMzsKICAgZmxvYXQgdzQgPSBrMTsgaWYoa28yPGtvNCkgdzQqPWtvMi9rbzQ7CgogICBjPSh3MSpvMSt3MipvMit3MypvMyt3NCpvNCswLjAwMSpjKS8odzErdzIrdzMrdzQrMC4wMDEpOwogICB3MSA9IGsqZG90KGFicyhpMS1jKSthYnMoaTMtYyksZHQpLygwLjEyNSpkb3QoaTEraTMsZHQpK2x1bV9hZGQpOwogICB3MiA9IGsqZG90KGFicyhpMi1jKSthYnMoaTQtYyksZHQpLygwLjEyNSpkb3QoaTIraTQsZHQpK2x1bV9hZGQpOwogICB3MyA9IGsqZG90KGFicyhzMS1jKSthYnMoczMtYyksZHQpLygwLjEyNSpkb3QoczErczMsZHQpK2x1bV9hZGQpOwogICB3NCA9IGsqZG90KGFicyhzMi1jKSthYnMoczQtYyksZHQpLygwLjEyNSpkb3QoczIrczQsZHQpK2x1bV9hZGQpOwoKICAgdzEgPSBjbGFtcCh3MStteCxtaW5fdyxtYXhfdyk7IAogICB3MiA9IGNsYW1wKHcyK214LG1pbl93LG1heF93KTsKICAgdzMgPSBjbGFtcCh3MytteCxtaW5fdyxtYXhfdyk7IAogICB3NCA9IGNsYW1wKHc0K214LG1pbl93LG1heF93KTsKCiAgIEZyYWdDb2xvciA9IHZlYzQoKHcxKihpMStpMykrdzIqKGkyK2k0KSt3MyooczErczMpK3c0KihzMitzNCkrYykvKDIuMCoodzErdzIrdzMrdzQpKzEuMCksIDEuMCk7Cn0gCiNlbmRpZgo=",
            },
        ],
    },

    //https://github.com/libretro/glsl-shaders/blob/master/sabr/sabr.glslp
    "sabr": {
        "shader": {
            "type": "text",
            "value": "shaders = 1\n\nshader0 = sabr-v3.0.glsl\nfilter_linear0 = false\n",
        },
        "resources": [
            {
                "name": "sabr-v3.0.glsl",
                "type": "base64",
                "value": "LyoKCVNBQlIgdjMuMCBTaGFkZXIKCUpvc2h1YSBTdHJlZXQKCQoJUG9ydGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gd2VyZSB0YWtlbiBmcm9tIEh5bGxpYW4ncyA1eEJSIHYzLjdjCglzaGFkZXIuCgkKCVRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IKCW1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlCglhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyIHZlcnNpb24gMgoJb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uCgoJVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsCglidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZgoJTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZQoJR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy4KCglZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQoJYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmUKCUZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAgMDIxMTEtMTMwNywgVVNBLgoKKi8KCiNpZiBkZWZpbmVkKFZFUlRFWCkKCiNpZiBfX1ZFUlNJT05fXyA+PSAxMzAKI2RlZmluZSBDT01QQVRfVkFSWUlORyBvdXQKI2RlZmluZSBDT01QQVRfQVRUUklCVVRFIGluCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZQojZWxzZQojZGVmaW5lIENPTVBBVF9WQVJZSU5HIHZhcnlpbmcgCiNkZWZpbmUgQ09NUEFUX0FUVFJJQlVURSBhdHRyaWJ1dGUgCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZTJECiNlbmRpZgoKI2lmZGVmIEdMX0VTCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTiBtZWRpdW1wCiNlbHNlCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTgojZW5kaWYKCkNPTVBBVF9BVFRSSUJVVEUgdmVjNCBWZXJ0ZXhDb29yZDsKQ09NUEFUX0FUVFJJQlVURSB2ZWM0IENPTE9SOwpDT01QQVRfQVRUUklCVVRFIHZlYzQgVGV4Q29vcmQ7CkNPTVBBVF9WQVJZSU5HIHZlYzQgQ09MMDsKQ09NUEFUX1ZBUllJTkcgdmVjNCBURVgwOwoKdW5pZm9ybSBtYXQ0IE1WUE1hdHJpeDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZURpcmVjdGlvbjsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZUNvdW50Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBPdXRwdXRTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBUZXh0dXJlU2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgSW5wdXRTaXplOwpDT01QQVRfVkFSWUlORyB2ZWMyIHRjOwpDT01QQVRfVkFSWUlORyB2ZWM0IHh5cF8xXzJfMzsKQ09NUEFUX1ZBUllJTkcgdmVjNCB4eXBfNV8xMF8xNTsKQ09NUEFUX1ZBUllJTkcgdmVjNCB4eXBfNl83Xzg7CkNPTVBBVF9WQVJZSU5HIHZlYzQgeHlwXzlfMTRfOTsKQ09NUEFUX1ZBUllJTkcgdmVjNCB4eXBfMTFfMTJfMTM7CkNPTVBBVF9WQVJZSU5HIHZlYzQgeHlwXzE2XzE3XzE4OwpDT01QQVRfVkFSWUlORyB2ZWM0IHh5cF8yMV8yMl8yMzsKCi8vIHZlcnRleCBjb21wYXRpYmlsaXR5ICNkZWZpbmVzCiNkZWZpbmUgdlRleENvb3JkIFRFWDAueHkKI2RlZmluZSBTb3VyY2VTaXplIHZlYzQoVGV4dHVyZVNpemUsIDEuMCAvIFRleHR1cmVTaXplKSAvL2VpdGhlciBUZXh0dXJlU2l6ZSBvciBJbnB1dFNpemUKI2RlZmluZSBvdXRzaXplIHZlYzQoT3V0cHV0U2l6ZSwgMS4wIC8gT3V0cHV0U2l6ZSkKCnZvaWQgbWFpbigpCnsKICAgIGdsX1Bvc2l0aW9uID0gTVZQTWF0cml4ICogVmVydGV4Q29vcmQ7CiAgICBDT0wwID0gQ09MT1I7CiAgICBURVgwLnh5ID0gVGV4Q29vcmQueHk7CiAgIAlmbG9hdCB4ID0gU291cmNlU2l6ZS56Oy8vMS4wIC8gSU4udGV4dHVyZV9zaXplLng7CglmbG9hdCB5ID0gU291cmNlU2l6ZS53Oy8vMS4wIC8gSU4udGV4dHVyZV9zaXplLnk7CgkKCXRjID0gVEVYMC54eSAqIHZlYzIoMS4wMDA0LCAxLjApOwoJeHlwXzFfMl8zICAgID0gdGMueHh4eSArIHZlYzQoICAgICAgLXgsIDAuMCwgICB4LCAtMi4wICogeSk7Cgl4eXBfNl83XzggICAgPSB0Yy54eHh5ICsgdmVjNCggICAgICAteCwgMC4wLCAgIHgsICAgICAgIC15KTsKCXh5cF8xMV8xMl8xMyA9IHRjLnh4eHkgKyB2ZWM0KCAgICAgIC14LCAwLjAsICAgeCwgICAgICAwLjApOwoJeHlwXzE2XzE3XzE4ID0gdGMueHh4eSArIHZlYzQoICAgICAgLXgsIDAuMCwgICB4LCAgICAgICAgeSk7Cgl4eXBfMjFfMjJfMjMgPSB0Yy54eHh5ICsgdmVjNCggICAgICAteCwgMC4wLCAgIHgsICAyLjAgKiB5KTsKCXh5cF81XzEwXzE1ICA9IHRjLnh5eXkgKyB2ZWM0KC0yLjAgKiB4LCAgLXksIDAuMCwgICAgICAgIHkpOwoJeHlwXzlfMTRfOSAgID0gdGMueHl5eSArIHZlYzQoIDIuMCAqIHgsICAteSwgMC4wLCAgICAgICAgeSk7Cn0KCiNlbGlmIGRlZmluZWQoRlJBR01FTlQpCgojaWYgX19WRVJTSU9OX18gPj0gMTMwCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgaW4KI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlCm91dCB2ZWM0IEZyYWdDb2xvcjsKI2Vsc2UKI2RlZmluZSBDT01QQVRfVkFSWUlORyB2YXJ5aW5nCiNkZWZpbmUgRnJhZ0NvbG9yIGdsX0ZyYWdDb2xvcgojZGVmaW5lIENPTVBBVF9URVhUVVJFIHRleHR1cmUyRAojZW5kaWYKCiNpZmRlZiBHTF9FUwojaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gKcHJlY2lzaW9uIGhpZ2hwIGZsb2F0OwojZWxzZQpwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKI2VuZGlmCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTiBtZWRpdW1wCiNlbHNlCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTgojZW5kaWYKCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVEaXJlY3Rpb247CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVDb3VudDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgT3V0cHV0U2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgVGV4dHVyZVNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIElucHV0U2l6ZTsKdW5pZm9ybSBzYW1wbGVyMkQgVGV4dHVyZTsKQ09NUEFUX1ZBUllJTkcgdmVjNCBURVgwOwpDT01QQVRfVkFSWUlORyB2ZWMyIHRjOwpDT01QQVRfVkFSWUlORyB2ZWM0IHh5cF8xXzJfMzsKQ09NUEFUX1ZBUllJTkcgdmVjNCB4eXBfNV8xMF8xNTsKQ09NUEFUX1ZBUllJTkcgdmVjNCB4eXBfNl83Xzg7CkNPTVBBVF9WQVJZSU5HIHZlYzQgeHlwXzlfMTRfOTsKQ09NUEFUX1ZBUllJTkcgdmVjNCB4eXBfMTFfMTJfMTM7CkNPTVBBVF9WQVJZSU5HIHZlYzQgeHlwXzE2XzE3XzE4OwpDT01QQVRfVkFSWUlORyB2ZWM0IHh5cF8yMV8yMl8yMzsKCi8vIGZyYWdtZW50IGNvbXBhdGliaWxpdHkgI2RlZmluZXMKI2RlZmluZSBTb3VyY2UgVGV4dHVyZQojZGVmaW5lIHZUZXhDb29yZCBURVgwLnh5CgojZGVmaW5lIFNvdXJjZVNpemUgdmVjNChUZXh0dXJlU2l6ZSwgMS4wIC8gVGV4dHVyZVNpemUpIC8vZWl0aGVyIFRleHR1cmVTaXplIG9yIElucHV0U2l6ZQojZGVmaW5lIG91dHNpemUgdmVjNChPdXRwdXRTaXplLCAxLjAgLyBPdXRwdXRTaXplKQoKLyoKCUNvbnN0YW50cwoqLwovKgoJSW5lcXVhdGlvbiBjb2VmZmljaWVudHMgZm9yIGludGVycG9sYXRpb24KRXF1YXRpb25zIGFyZSBpbiB0aGUgZm9ybTogQXkgKyBCeCA9IEMKNDUsIDMwLCBhbmQgNjAgZGVub3RlIHRoZSBhbmdsZSBmcm9tIHggZWFjaCBsaW5lIHRoZSBjb29lZmljaWVudCB2YXJpYWJsZSBzZXQgYnVpbGRzCiovCmNvbnN0IHZlYzQgQWkgID0gdmVjNCggMS4wLCAtMS4wLCAtMS4wLCAgMS4wKTsKY29uc3QgdmVjNCBCNDUgPSB2ZWM0KCAxLjAsICAxLjAsIC0xLjAsIC0xLjApOwpjb25zdCB2ZWM0IEM0NSA9IHZlYzQoIDEuNSwgIDAuNSwgLTAuNSwgIDAuNSk7CmNvbnN0IHZlYzQgQjMwID0gdmVjNCggMC41LCAgMi4wLCAtMC41LCAtMi4wKTsKY29uc3QgdmVjNCBDMzAgPSB2ZWM0KCAxLjAsICAxLjAsIC0wLjUsICAwLjApOwpjb25zdCB2ZWM0IEI2MCA9IHZlYzQoIDIuMCwgIDAuNSwgLTIuMCwgLTAuNSk7CmNvbnN0IHZlYzQgQzYwID0gdmVjNCggMi4wLCAgMC4wLCAtMS4wLCAgMC41KTsKCmNvbnN0IHZlYzQgTTQ1ID0gdmVjNCgwLjQsIDAuNCwgMC40LCAwLjQpOwpjb25zdCB2ZWM0IE0zMCA9IHZlYzQoMC4yLCAwLjQsIDAuMiwgMC40KTsKY29uc3QgdmVjNCBNNjAgPSBNMzAueXh3ejsKY29uc3QgdmVjNCBNc2hpZnQgPSB2ZWM0KDAuMik7CgovLyBDb2VmZmljaWVudCBmb3Igd2VpZ2h0ZWQgZWRnZSBkZXRlY3Rpb24KY29uc3QgZmxvYXQgY29lZiA9IDIuMDsKLy8gVGhyZXNob2xkIGZvciBpZiBsdW1pbmFuY2UgdmFsdWVzIGFyZSAiZXF1YWwiCmNvbnN0IHZlYzQgdGhyZXNob2xkID0gdmVjNCgwLjMyKTsKCi8vIENvbnZlcnNpb24gZnJvbSBSR0IgdG8gTHVtaW5hbmNlIChmcm9tIEdJTVApCmNvbnN0IHZlYzMgbHVtID0gdmVjMygwLjIxLCAwLjcyLCAwLjA3KTsKCi8vIFBlcmZvcm1zIHNhbWUgbG9naWMgb3BlcmF0aW9uIGFzICYmIGZvciB2ZWN0b3JzCmJ2ZWM0IF9hbmRfKGJ2ZWM0IEEsIGJ2ZWM0IEIpIHsKCXJldHVybiBidmVjNChBLnggJiYgQi54LCBBLnkgJiYgQi55LCBBLnogJiYgQi56LCBBLncgJiYgQi53KTsKfQoKLy8gUGVyZm9ybXMgc2FtZSBsb2dpYyBvcGVyYXRpb24gYXMgfHwgZm9yIHZlY3RvcnMKYnZlYzQgX29yXyhidmVjNCBBLCBidmVjNCBCKSB7CglyZXR1cm4gYnZlYzQoQS54IHx8IEIueCwgQS55IHx8IEIueSwgQS56IHx8IEIueiwgQS53IHx8IEIudyk7Cn0KCi8vIENvbnZlcnRzIDQgMy1jb2xvciB2ZWN0b3JzIGludG8gMSA0LXZhbHVlIGx1bWluYW5jZSB2ZWN0b3IKdmVjNCBsdW1fdG8odmVjMyB2MCwgdmVjMyB2MSwgdmVjMyB2MiwgdmVjMyB2MykgewoJcmV0dXJuIHZlYzQoZG90KGx1bSwgdjApLCBkb3QobHVtLCB2MSksIGRvdChsdW0sIHYyKSwgZG90KGx1bSwgdjMpKTsKfQoKLy8gR2V0cyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIDIgNC12YWx1ZSBsdW1pbmFuY2UgdmVjdG9ycwp2ZWM0IGx1bV9kZih2ZWM0IEEsIHZlYzQgQikgewoJcmV0dXJuIGFicyhBIC0gQik7Cn0KCi8vIERldGVybWluZXMgaWYgMiA0LXZhbHVlIGx1bWluYW5jZSB2ZWN0b3JzIGFyZSAiZXF1YWwiIGJhc2VkIG9uIHRocmVzaG9sZApidmVjNCBsdW1fZXEodmVjNCBBLCB2ZWM0IEIpIHsKCXJldHVybiBsZXNzVGhhbihsdW1fZGYoQSwgQiksIHRocmVzaG9sZCk7Cn0KCnZlYzQgbHVtX3dkKHZlYzQgYSwgdmVjNCBiLCB2ZWM0IGMsIHZlYzQgZCwgdmVjNCBlLCB2ZWM0IGYsIHZlYzQgZywgdmVjNCBoKSB7CglyZXR1cm4gbHVtX2RmKGEsIGIpICsgbHVtX2RmKGEsIGMpICsgbHVtX2RmKGQsIGUpICsgbHVtX2RmKGQsIGYpICsgNC4wICogbHVtX2RmKGcsIGgpOwp9CgovLyBHZXRzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gMiAzLXZhbHVlIHJnYiBjb2xvcnMKZmxvYXQgY19kZih2ZWMzIGMxLCB2ZWMzIGMyKSB7Cgl2ZWMzIGRmID0gYWJzKGMxIC0gYzIpOwoJcmV0dXJuIGRmLnIgKyBkZi5nICsgZGYuYjsKfQoKdm9pZCBtYWluKCkKewovKgpNYXNrIGZvciBhbGdvcml0aG0KKy0tLS0tKy0tLS0tKy0tLS0tKy0tLS0tKy0tLS0tKwp8ICAgICB8ICAxICB8ICAyICB8ICAzICB8ICAgICB8CistLS0tLSstLS0tLSstLS0tLSstLS0tLSstLS0tLSsKfCAgNSAgfCAgNiAgfCAgNyAgfCAgOCAgfCAgOSAgfAorLS0tLS0rLS0tLS0rLS0tLS0rLS0tLS0rLS0tLS0rCnwgMTAgIHwgMTEgIHwgMTIgIHwgMTMgIHwgMTQgIHwKKy0tLS0tKy0tLS0tKy0tLS0tKy0tLS0tKy0tLS0tKwp8IDE1ICB8IDE2ICB8IDE3ICB8IDE4ICB8IDE5ICB8CistLS0tLSstLS0tLSstLS0tLSstLS0tLSstLS0tLSsKfCAgICAgfCAyMSAgfCAyMiAgfCAyMyAgfCAgICAgfAorLS0tLS0rLS0tLS0rLS0tLS0rLS0tLS0rLS0tLS0rCgkqLwoJLy8gR2V0IG1hc2sgdmFsdWVzIGJ5IHBlcmZvcm1pbmcgdGV4dHVyZSBsb29rdXAgd2l0aCB0aGUgdW5pZm9ybSBzYW1wbGVyCgl2ZWMzIFAxICA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgeHlwXzFfMl8zLnh3ICAgKS5yZ2I7Cgl2ZWMzIFAyICA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgeHlwXzFfMl8zLnl3ICAgKS5yZ2I7Cgl2ZWMzIFAzICA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgeHlwXzFfMl8zLnp3ICAgKS5yZ2I7CgkKCXZlYzMgUDYgID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB4eXBfNl83XzgueHcgICApLnJnYjsKCXZlYzMgUDcgID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB4eXBfNl83XzgueXcgICApLnJnYjsKCXZlYzMgUDggID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB4eXBfNl83XzguencgICApLnJnYjsKCQoJdmVjMyBQMTEgPSBDT01QQVRfVEVYVFVSRShTb3VyY2UsIHh5cF8xMV8xMl8xMy54dykucmdiOwoJdmVjMyBQMTIgPSBDT01QQVRfVEVYVFVSRShTb3VyY2UsIHh5cF8xMV8xMl8xMy55dykucmdiOwoJdmVjMyBQMTMgPSBDT01QQVRfVEVYVFVSRShTb3VyY2UsIHh5cF8xMV8xMl8xMy56dykucmdiOwoJCgl2ZWMzIFAxNiA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgeHlwXzE2XzE3XzE4Lnh3KS5yZ2I7Cgl2ZWMzIFAxNyA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgeHlwXzE2XzE3XzE4Lnl3KS5yZ2I7Cgl2ZWMzIFAxOCA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgeHlwXzE2XzE3XzE4Lnp3KS5yZ2I7CgkKCXZlYzMgUDIxID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB4eXBfMjFfMjJfMjMueHcpLnJnYjsKCXZlYzMgUDIyID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB4eXBfMjFfMjJfMjMueXcpLnJnYjsKCXZlYzMgUDIzID0gQ09NUEFUX1RFWFRVUkUoU291cmNlLCB4eXBfMjFfMjJfMjMuencpLnJnYjsKCQoJdmVjMyBQNSAgPSBDT01QQVRfVEVYVFVSRShTb3VyY2UsIHh5cF81XzEwXzE1Lnh5ICkucmdiOwoJdmVjMyBQMTAgPSBDT01QQVRfVEVYVFVSRShTb3VyY2UsIHh5cF81XzEwXzE1Lnh6ICkucmdiOwoJdmVjMyBQMTUgPSBDT01QQVRfVEVYVFVSRShTb3VyY2UsIHh5cF81XzEwXzE1Lnh3ICkucmdiOwoJCgl2ZWMzIFA5ICA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgeHlwXzlfMTRfOS54eSAgKS5yZ2I7Cgl2ZWMzIFAxNCA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgeHlwXzlfMTRfOS54eiAgKS5yZ2I7Cgl2ZWMzIFAxOSA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgeHlwXzlfMTRfOS54dyAgKS5yZ2I7CgkKCS8vIFN0b3JlIGx1bWluYW5jZSB2YWx1ZXMgb2YgZWFjaCBwb2ludCBpbiBncm91cHMgb2YgNAoJLy8gc28gdGhhdCB3ZSBtYXkgb3BlcmF0ZSBvbiBhbGwgZm91ciBjb3JuZXJzIGF0IG9uY2UKCXZlYzQgcDcgID0gbHVtX3RvKFA3LCAgUDExLCBQMTcsIFAxMyk7Cgl2ZWM0IHA4ICA9IGx1bV90byhQOCwgIFA2LCAgUDE2LCBQMTgpOwoJdmVjNCBwMTEgPSBwNy55end4OyAgICAgICAgICAgICAgICAgICAgICAvLyBQMTEsIFAxNywgUDEzLCBQNwoJdmVjNCBwMTIgPSBsdW1fdG8oUDEyLCBQMTIsIFAxMiwgUDEyKTsKCXZlYzQgcDEzID0gcDcud3h5ejsgICAgICAgICAgICAgICAgICAgICAgLy8gUDEzLCBQNywgIFAxMSwgUDE3Cgl2ZWM0IHAxNCA9IGx1bV90byhQMTQsIFAyLCAgUDEwLCBQMjIpOwoJdmVjNCBwMTYgPSBwOC56d3h5OyAgICAgICAgICAgICAgICAgICAgICAvLyBQMTYsIFAxOCwgUDgsICBQNgoJdmVjNCBwMTcgPSBwNy56d3h5OyAgICAgICAgICAgICAgICAgICAgICAvLyBQMTcsIFAxMywgUDcsICBQMTEKCXZlYzQgcDE4ID0gcDgud3h5ejsgICAgICAgICAgICAgICAgICAgICAgLy8gUDE4LCBQOCwgIFA2LCAgUDE2Cgl2ZWM0IHAxOSA9IGx1bV90byhQMTksIFAzLCAgUDUsICBQMjEpOwoJdmVjNCBwMjIgPSBwMTQud3h5ejsgICAgICAgICAgICAgICAgICAgICAvLyBQMjIsIFAxNCwgUDIsICBQMTAKCXZlYzQgcDIzID0gbHVtX3RvKFAyMywgUDksICBQMSwgIFAxNSk7CgkKCS8vIFNjYWxlIGN1cnJlbnQgdGV4ZWwgY29vcmRpbmF0ZSB0byBbMC4uMV0KCXZlYzIgZnAgPSBmcmFjdCh0YyAqIFNvdXJjZVNpemUueHkpOwoJCgkvLyBEZXRlcm1pbmUgYW1vdW50IG9mICJzbW9vdGhpbmciIG9yIG1peGluZyB0aGF0IGNvdWxkIGJlIGRvbmUgb24gdGV4ZWwgY29ybmVycwoJdmVjNCBtYTQ1ID0gc21vb3Roc3RlcChDNDUgLSBNNDUsIEM0NSArIE00NSwgQWkgKiBmcC55ICsgQjQ1ICogZnAueCk7Cgl2ZWM0IG1hMzAgPSBzbW9vdGhzdGVwKEMzMCAtIE0zMCwgQzMwICsgTTMwLCBBaSAqIGZwLnkgKyBCMzAgKiBmcC54KTsKCXZlYzQgbWE2MCA9IHNtb290aHN0ZXAoQzYwIC0gTTYwLCBDNjAgKyBNNjAsIEFpICogZnAueSArIEI2MCAqIGZwLngpOwoJdmVjNCBtYXJuID0gc21vb3Roc3RlcChDNDUgLSBNNDUgKyBNc2hpZnQsIEM0NSArIE00NSArIE1zaGlmdCwgQWkgKiBmcC55ICsgQjQ1ICogZnAueCk7CgkKCS8vIFBlcmZvcm0gZWRnZSB3ZWlnaHQgY2FsY3VsYXRpb25zCgl2ZWM0IGU0NSAgID0gbHVtX3dkKHAxMiwgcDgsIHAxNiwgcDE4LCBwMjIsIHAxNCwgcDE3LCBwMTMpOwoJdmVjNCBlY29udCA9IGx1bV93ZChwMTcsIHAxMSwgcDIzLCBwMTMsIHA3LCBwMTksIHAxMiwgcDE4KTsKCXZlYzQgZTMwICAgPSBsdW1fZGYocDEzLCBwMTYpOwoJdmVjNCBlNjAgICA9IGx1bV9kZihwOCwgcDE3KTsKCQoJLy8gQ2FsY3VsYXRlIHJ1bGUgcmVzdWx0cyBmb3IgaW50ZXJwb2xhdGlvbgoJYnZlYzQgcjQ1XzEgICA9IF9hbmRfKG5vdEVxdWFsKHAxMiwgcDEzKSwgbm90RXF1YWwocDEyLCBwMTcpKTsKCWJ2ZWM0IHI0NV8yICAgPSBfYW5kXyhub3QobHVtX2VxKHAxMywgcDcpKSwgbm90KGx1bV9lcShwMTMsIHA4KSkpOwoJYnZlYzQgcjQ1XzMgICA9IF9hbmRfKG5vdChsdW1fZXEocDE3LCBwMTEpKSwgbm90KGx1bV9lcShwMTcsIHAxNikpKTsKCWJ2ZWM0IHI0NV80XzEgPSBfYW5kXyhub3QobHVtX2VxKHAxMywgcDE0KSksIG5vdChsdW1fZXEocDEzLCBwMTkpKSk7CglidmVjNCByNDVfNF8yID0gX2FuZF8obm90KGx1bV9lcShwMTcsIHAyMikpLCBub3QobHVtX2VxKHAxNywgcDIzKSkpOwoJYnZlYzQgcjQ1XzQgICA9IF9hbmRfKGx1bV9lcShwMTIsIHAxOCksIF9vcl8ocjQ1XzRfMSwgcjQ1XzRfMikpOwoJYnZlYzQgcjQ1XzUgICA9IF9vcl8obHVtX2VxKHAxMiwgcDE2KSwgbHVtX2VxKHAxMiwgcDgpKTsKCWJ2ZWM0IHI0NSAgICAgPSBfYW5kXyhyNDVfMSwgX29yXyhfb3JfKF9vcl8ocjQ1XzIsIHI0NV8zKSwgcjQ1XzQpLCByNDVfNSkpOwoJYnZlYzQgcjMwID0gX2FuZF8obm90RXF1YWwocDEyLCBwMTYpLCBub3RFcXVhbChwMTEsIHAxNikpOwoJYnZlYzQgcjYwID0gX2FuZF8obm90RXF1YWwocDEyLCBwOCksIG5vdEVxdWFsKHA3LCBwOCkpOwoJCgkvLyBDb21iaW5lIHJ1bGVzIHdpdGggZWRnZSB3ZWlnaHRzCglidmVjNCBlZHI0NSA9IF9hbmRfKGxlc3NUaGFuKGU0NSwgZWNvbnQpLCByNDUpOwoJYnZlYzQgZWRycm4gPSBsZXNzVGhhbkVxdWFsKGU0NSwgZWNvbnQpOwoJYnZlYzQgZWRyMzAgPSBfYW5kXyhsZXNzVGhhbkVxdWFsKGNvZWYgKiBlMzAsIGU2MCksIHIzMCk7CglidmVjNCBlZHI2MCA9IF9hbmRfKGxlc3NUaGFuRXF1YWwoY29lZiAqIGU2MCwgZTMwKSwgcjYwKTsKCQoJLy8gRmluYWxpemUgaW50ZXJwb2xhdGlvbiBydWxlcyBhbmQgY2FzdCB0byBmbG9hdCAoMC4wIGZvciBmYWxzZSwgMS4wIGZvciB0cnVlKQoJdmVjNCBmaW5hbDQ1ID0gdmVjNChfYW5kXyhfYW5kXyhub3QoZWRyMzApLCBub3QoZWRyNjApKSwgZWRyNDUpKTsKCXZlYzQgZmluYWwzMCA9IHZlYzQoX2FuZF8oX2FuZF8oZWRyNDUsIG5vdChlZHI2MCkpLCBlZHIzMCkpOwoJdmVjNCBmaW5hbDYwID0gdmVjNChfYW5kXyhfYW5kXyhlZHI0NSwgbm90KGVkcjMwKSksIGVkcjYwKSk7Cgl2ZWM0IGZpbmFsMzYgPSB2ZWM0KF9hbmRfKF9hbmRfKGVkcjYwLCBlZHIzMCksIGVkcjQ1KSk7Cgl2ZWM0IGZpbmFscm4gPSB2ZWM0KF9hbmRfKG5vdChlZHI0NSksIGVkcnJuKSk7CgkKCS8vIERldGVybWluZSB0aGUgY29sb3IgdG8gbWl4IHdpdGggZm9yIGVhY2ggY29ybmVyCgl2ZWM0IHB4ID0gc3RlcChsdW1fZGYocDEyLCBwMTcpLCBsdW1fZGYocDEyLCBwMTMpKTsKCQoJLy8gRGV0ZXJtaW5lIHRoZSBtaXggYW1vdW50cyBieSBjb21iaW5pbmcgdGhlIGZpbmFsIHJ1bGUgcmVzdWx0IGFuZCBjb3JyZXNwb25kaW5nCgkvLyBtaXggYW1vdW50IGZvciB0aGUgcnVsZSBpbiBlYWNoIGNvcm5lcgoJdmVjNCBtYWMgPSBmaW5hbDM2ICogbWF4KG1hMzAsIG1hNjApICsgZmluYWwzMCAqIG1hMzAgKyBmaW5hbDYwICogbWE2MCArIGZpbmFsNDUgKiBtYTQ1ICsgZmluYWxybiAqIG1hcm47CgkKLyoKQ2FsY3VsYXRlIHRoZSByZXN1bHRpbmcgY29sb3IgYnkgdHJhdmVyc2luZyBjbG9ja3dpc2UgYW5kIGNvdW50ZXItY2xvY2t3aXNlIGFyb3VuZAp0aGUgY29ybmVycyBvZiB0aGUgdGV4ZWwKCkZpbmFsbHkgY2hvb3NlIHRoZSByZXN1bHQgdGhhdCBoYXMgdGhlIGxhcmdlc3QgZGlmZmVyZW5jZSBmcm9tIHRoZSB0ZXhlbCdzIG9yaWdpbmFsCmNvbG9yCiovCgl2ZWMzIHJlczEgPSBQMTI7CglyZXMxID0gbWl4KHJlczEsIG1peChQMTMsIFAxNywgcHgueCksIG1hYy54KTsKCXJlczEgPSBtaXgocmVzMSwgbWl4KFA3LCBQMTMsIHB4LnkpLCBtYWMueSk7CglyZXMxID0gbWl4KHJlczEsIG1peChQMTEsIFA3LCBweC56KSwgbWFjLnopOwoJcmVzMSA9IG1peChyZXMxLCBtaXgoUDE3LCBQMTEsIHB4LncpLCBtYWMudyk7CgkKCXZlYzMgcmVzMiA9IFAxMjsKCXJlczIgPSBtaXgocmVzMiwgbWl4KFAxNywgUDExLCBweC53KSwgbWFjLncpOwoJcmVzMiA9IG1peChyZXMyLCBtaXgoUDExLCBQNywgcHgueiksIG1hYy56KTsKCXJlczIgPSBtaXgocmVzMiwgbWl4KFA3LCBQMTMsIHB4LnkpLCBtYWMueSk7CglyZXMyID0gbWl4KHJlczIsIG1peChQMTMsIFAxNywgcHgueCksIG1hYy54KTsKCQoJRnJhZ0NvbG9yID0gdmVjNChtaXgocmVzMSwgcmVzMiwgc3RlcChjX2RmKFAxMiwgcmVzMSksIGNfZGYoUDEyLCByZXMyKSkpLCAxLjApOwp9IAojZW5kaWYK",
            },
        ],
    },

    //https://github.com/libretro/glsl-shaders/blob/master/crt/crt-aperture.glslp
    "crt-aperture.glslp": {
        "shader": {
            "type": "text",
            "value": "shaders = 1\n\nshader0 = crt-aperture.glsl\nfilter_linear0 = false\n",
        },
        "resources": [
            {
                "name": "crt-aperture.glsl",
                "type": "base64",
                "value": "LyoKICAgIENSVCBTaGFkZXIgYnkgRWFzeU1vZGUKICAgIExpY2Vuc2U6IEdQTAoqLwoKI3ByYWdtYSBwYXJhbWV0ZXIgU0hBUlBORVNTX0lNQUdFICJTaGFycG5lc3MgSW1hZ2UiIDEuMCAxLjAgNS4wIDEuMAojcHJhZ21hIHBhcmFtZXRlciBTSEFSUE5FU1NfRURHRVMgIlNoYXJwbmVzcyBFZGdlcyIgMy4wIDEuMCA1LjAgMS4wCiNwcmFnbWEgcGFyYW1ldGVyIEdMT1dfV0lEVEggIkdsb3cgV2lkdGgiIDAuNSAwLjA1IDAuNjUgMC4wNQojcHJhZ21hIHBhcmFtZXRlciBHTE9XX0hFSUdIVCAiR2xvdyBIZWlnaHQiIDAuNSAwLjA1IDAuNjUgMC4wNQojcHJhZ21hIHBhcmFtZXRlciBHTE9XX0hBTEFUSU9OICJHbG93IEhhbGF0aW9uIiAwLjEgMC4wIDEuMCAwLjAxCiNwcmFnbWEgcGFyYW1ldGVyIEdMT1dfRElGRlVTSU9OICJHbG93IERpZmZ1c2lvbiIgMC4wNSAwLjAgMS4wIDAuMDEKI3ByYWdtYSBwYXJhbWV0ZXIgTUFTS19DT0xPUlMgIk1hc2sgQ29sb3JzIiAyLjAgMi4wIDMuMCAxLjAKI3ByYWdtYSBwYXJhbWV0ZXIgTUFTS19TVFJFTkdUSCAiTWFzayBTdHJlbmd0aCIgMC4zIDAuMCAxLjAgMC4wNQojcHJhZ21hIHBhcmFtZXRlciBNQVNLX1NJWkUgIk1hc2sgU2l6ZSIgMS4wIDEuMCA5LjAgMS4wCiNwcmFnbWEgcGFyYW1ldGVyIFNDQU5MSU5FX1NJWkVfTUlOICJTY2FubGluZSBTaXplIE1pbi4iIDAuNSAwLjUgMS41IDAuMDUKI3ByYWdtYSBwYXJhbWV0ZXIgU0NBTkxJTkVfU0laRV9NQVggIlNjYW5saW5lIFNpemUgTWF4LiIgMS41IDAuNSAxLjUgMC4wNQojcHJhZ21hIHBhcmFtZXRlciBTQ0FOTElORV9TSEFQRSAiU2NhbmxpbmUgU2hhcGUiIDIuNSAxLjAgMTAwLjAgMC4xCiNwcmFnbWEgcGFyYW1ldGVyIFNDQU5MSU5FX09GRlNFVCAiU2NhbmxpbmUgT2Zmc2V0IiAxLjAgMC4wIDEuMCAxLjAKI3ByYWdtYSBwYXJhbWV0ZXIgR0FNTUFfSU5QVVQgIkdhbW1hIElucHV0IiAyLjQgMS4wIDUuMCAwLjEKI3ByYWdtYSBwYXJhbWV0ZXIgR0FNTUFfT1VUUFVUICJHYW1tYSBPdXRwdXQiIDIuNCAxLjAgNS4wIDAuMQojcHJhZ21hIHBhcmFtZXRlciBCUklHSFRORVNTICJCcmlnaHRuZXNzIiAxLjUgMC4wIDIuMCAwLjA1CgojZGVmaW5lIENvb3JkIFRFWDAKCiNpZiBkZWZpbmVkKFZFUlRFWCkKCiNpZiBfX1ZFUlNJT05fXyA+PSAxMzAKI2RlZmluZSBPVVQgb3V0CiNkZWZpbmUgSU4gIGluCiNkZWZpbmUgdGV4MkQgdGV4dHVyZQojZWxzZQojZGVmaW5lIE9VVCB2YXJ5aW5nIAojZGVmaW5lIElOIGF0dHJpYnV0ZSAKI2RlZmluZSB0ZXgyRCB0ZXh0dXJlMkQKI2VuZGlmCgojaWZkZWYgR0xfRVMKI2RlZmluZSBQUkVDSVNJT04gbWVkaXVtcAojZWxzZQojZGVmaW5lIFBSRUNJU0lPTgojZW5kaWYKCklOICB2ZWM0IFZlcnRleENvb3JkOwpJTiAgdmVjNCBDb2xvcjsKSU4gIHZlYzIgVGV4Q29vcmQ7Ck9VVCB2ZWM0IGNvbG9yOwpPVVQgdmVjMiBDb29yZDsKCnVuaWZvcm0gbWF0NCBNVlBNYXRyaXg7CnVuaWZvcm0gUFJFQ0lTSU9OIGludCBGcmFtZURpcmVjdGlvbjsKdW5pZm9ybSBQUkVDSVNJT04gaW50IEZyYW1lQ291bnQ7CnVuaWZvcm0gUFJFQ0lTSU9OIHZlYzIgT3V0cHV0U2l6ZTsKdW5pZm9ybSBQUkVDSVNJT04gdmVjMiBUZXh0dXJlU2l6ZTsKdW5pZm9ybSBQUkVDSVNJT04gdmVjMiBJbnB1dFNpemU7Cgp2b2lkIG1haW4oKQp7CiAgICBnbF9Qb3NpdGlvbiA9IE1WUE1hdHJpeCAqIFZlcnRleENvb3JkOwogICAgY29sb3IgPSBDb2xvcjsKICAgIENvb3JkID0gVGV4Q29vcmQgKiAxLjAwMDE7Cn0KCiNlbGlmIGRlZmluZWQoRlJBR01FTlQpCgojaWYgX19WRVJTSU9OX18gPj0gMTMwCiNkZWZpbmUgSU4gaW4KI2RlZmluZSB0ZXgyRCB0ZXh0dXJlCm91dCB2ZWM0IEZyYWdDb2xvcjsKI2Vsc2UKI2RlZmluZSBJTiB2YXJ5aW5nCiNkZWZpbmUgRnJhZ0NvbG9yIGdsX0ZyYWdDb2xvcgojZGVmaW5lIHRleDJEIHRleHR1cmUyRAojZW5kaWYKCiNpZmRlZiBHTF9FUwojaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gKcHJlY2lzaW9uIGhpZ2hwIGZsb2F0OwojZWxzZQpwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKI2VuZGlmCiNkZWZpbmUgUFJFQ0lTSU9OIG1lZGl1bXAKI2Vsc2UKI2RlZmluZSBQUkVDSVNJT04KI2VuZGlmCgp1bmlmb3JtIFBSRUNJU0lPTiBpbnQgRnJhbWVEaXJlY3Rpb247CnVuaWZvcm0gUFJFQ0lTSU9OIGludCBGcmFtZUNvdW50Owp1bmlmb3JtIFBSRUNJU0lPTiB2ZWMyIE91dHB1dFNpemU7CnVuaWZvcm0gUFJFQ0lTSU9OIHZlYzIgVGV4dHVyZVNpemU7CnVuaWZvcm0gUFJFQ0lTSU9OIHZlYzIgSW5wdXRTaXplOwp1bmlmb3JtIHNhbXBsZXIyRCBUZXh0dXJlOwpJTiB2ZWMyIENvb3JkOwoKI2lmZGVmIFBBUkFNRVRFUl9VTklGT1JNCnVuaWZvcm0gUFJFQ0lTSU9OIGZsb2F0IFNIQVJQTkVTU19JTUFHRTsKdW5pZm9ybSBQUkVDSVNJT04gZmxvYXQgU0hBUlBORVNTX0VER0VTOwp1bmlmb3JtIFBSRUNJU0lPTiBmbG9hdCBHTE9XX1dJRFRIOwp1bmlmb3JtIFBSRUNJU0lPTiBmbG9hdCBHTE9XX0hFSUdIVDsKdW5pZm9ybSBQUkVDSVNJT04gZmxvYXQgR0xPV19IQUxBVElPTjsKdW5pZm9ybSBQUkVDSVNJT04gZmxvYXQgR0xPV19ESUZGVVNJT047CnVuaWZvcm0gUFJFQ0lTSU9OIGZsb2F0IE1BU0tfQ09MT1JTOwp1bmlmb3JtIFBSRUNJU0lPTiBmbG9hdCBNQVNLX1NUUkVOR1RIOwp1bmlmb3JtIFBSRUNJU0lPTiBmbG9hdCBNQVNLX1NJWkU7CnVuaWZvcm0gUFJFQ0lTSU9OIGZsb2F0IFNDQU5MSU5FX1NJWkVfTUlOOwp1bmlmb3JtIFBSRUNJU0lPTiBmbG9hdCBTQ0FOTElORV9TSVpFX01BWDsKdW5pZm9ybSBQUkVDSVNJT04gZmxvYXQgU0NBTkxJTkVfU0hBUEU7CnVuaWZvcm0gUFJFQ0lTSU9OIGZsb2F0IFNDQU5MSU5FX09GRlNFVDsKdW5pZm9ybSBQUkVDSVNJT04gZmxvYXQgR0FNTUFfSU5QVVQ7CnVuaWZvcm0gUFJFQ0lTSU9OIGZsb2F0IEdBTU1BX09VVFBVVDsKdW5pZm9ybSBQUkVDSVNJT04gZmxvYXQgQlJJR0hUTkVTUzsKI2Vsc2UKI2RlZmluZSBTSEFSUE5FU1NfSU1BR0UgMS4wCiNkZWZpbmUgU0hBUlBORVNTX0VER0VTIDMuMAojZGVmaW5lIEdMT1dfV0lEVEggMC41CiNkZWZpbmUgR0xPV19IRUlHSFQgMC41CiNkZWZpbmUgR0xPV19IQUxBVElPTiAwLjEKI2RlZmluZSBHTE9XX0RJRkZVU0lPTiAwLjA1CiNkZWZpbmUgTUFTS19DT0xPUlMgMi4wCiNkZWZpbmUgTUFTS19TVFJFTkdUSCAwLjMKI2RlZmluZSBNQVNLX1NJWkUgMS4wCiNkZWZpbmUgU0NBTkxJTkVfU0laRV9NSU4gMC41CiNkZWZpbmUgU0NBTkxJTkVfU0laRV9NQVggMS41CiNkZWZpbmUgU0NBTkxJTkVfU0hBUEUgMS41CiNkZWZpbmUgU0NBTkxJTkVfT0ZGU0VUIDEuMAojZGVmaW5lIEdBTU1BX0lOUFVUIDIuNAojZGVmaW5lIEdBTU1BX09VVFBVVCAyLjQKI2RlZmluZSBCUklHSFRORVNTIDEuNQojZW5kaWYKCiNkZWZpbmUgRklYKGMpIG1heChhYnMoYyksIDFlLTUpCiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODkKI2RlZmluZSBzYXR1cmF0ZShjKSBjbGFtcChjLCAwLjAsIDEuMCkKI2RlZmluZSBURVgyRChjKSBwb3codGV4MkQodGV4LCBjKS5yZ2IsIHZlYzMoR0FNTUFfSU5QVVQpKQoKbWF0MyBnZXRfY29sb3JfbWF0cml4KHNhbXBsZXIyRCB0ZXgsIHZlYzIgY28sIHZlYzIgZHgpCnsKICAgIHJldHVybiBtYXQzKFRFWDJEKGNvIC0gZHgpLCBURVgyRChjbyksIFRFWDJEKGNvICsgZHgpKTsKfQoKdmVjMyBibHVyKG1hdDMgbSwgZmxvYXQgZGlzdCwgZmxvYXQgcmFkKQp7CiAgICB2ZWMzIHggPSB2ZWMzKGRpc3QgLSAxLjAsIGRpc3QsIGRpc3QgKyAxLjApIC8gcmFkOwogICAgdmVjMyB3ID0gZXhwMih4ICogeCAqIC0xLjApOwoKICAgIHJldHVybiAobVswXSAqIHcueCArIG1bMV0gKiB3LnkgKyBtWzJdICogdy56KSAvICh3LnggKyB3LnkgKyB3LnopOwp9Cgp2ZWMzIGZpbHRlcl9nYXVzc2lhbihzYW1wbGVyMkQgdGV4LCB2ZWMyIGNvLCB2ZWMyIHRleF9zaXplKQp7CiAgICB2ZWMyIGR4ID0gdmVjMigxLjAgLyB0ZXhfc2l6ZS54LCAwLjApOwogICAgdmVjMiBkeSA9IHZlYzIoMC4wLCAxLjAgLyB0ZXhfc2l6ZS55KTsKICAgIHZlYzIgcGl4X2NvID0gY28gKiB0ZXhfc2l6ZTsKICAgIHZlYzIgdGV4X2NvID0gKGZsb29yKHBpeF9jbykgKyAwLjUpIC8gdGV4X3NpemU7CiAgICB2ZWMyIGRpc3QgPSAoZnJhY3QocGl4X2NvKSAtIDAuNSkgKiAtMS4wOwoKICAgIG1hdDMgbGluZTAgPSBnZXRfY29sb3JfbWF0cml4KHRleCwgdGV4X2NvIC0gZHksIGR4KTsKICAgIG1hdDMgbGluZTEgPSBnZXRfY29sb3JfbWF0cml4KHRleCwgdGV4X2NvLCBkeCk7CiAgICBtYXQzIGxpbmUyID0gZ2V0X2NvbG9yX21hdHJpeCh0ZXgsIHRleF9jbyArIGR5LCBkeCk7CiAgICBtYXQzIGNvbHVtbiA9IG1hdDMoYmx1cihsaW5lMCwgZGlzdC54LCBHTE9XX1dJRFRIKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsdXIobGluZTEsIGRpc3QueCwgR0xPV19XSURUSCksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibHVyKGxpbmUyLCBkaXN0LngsIEdMT1dfV0lEVEgpKTsKCiAgICByZXR1cm4gYmx1cihjb2x1bW4sIGRpc3QueSwgR0xPV19IRUlHSFQpOwp9Cgp2ZWMzIGZpbHRlcl9sYW5jem9zKHNhbXBsZXIyRCB0ZXgsIHZlYzIgY28sIHZlYzIgdGV4X3NpemUsIGZsb2F0IHNoYXJwKQp7CiAgICB0ZXhfc2l6ZS54ICo9IHNoYXJwOwoKICAgIHZlYzIgZHggPSB2ZWMyKDEuMCAvIHRleF9zaXplLngsIDAuMCk7CiAgICB2ZWMyIHBpeF9jbyA9IGNvICogdGV4X3NpemUgLSB2ZWMyKDAuNSwgMC4wKTsKICAgIHZlYzIgdGV4X2NvID0gKGZsb29yKHBpeF9jbykgKyB2ZWMyKDAuNSwgMC4wKSkgLyB0ZXhfc2l6ZTsKICAgIHZlYzIgZGlzdCA9IGZyYWN0KHBpeF9jbyk7CiAgICB2ZWM0IGNvZWYgPSBQSSAqIHZlYzQoZGlzdC54ICsgMS4wLCBkaXN0LngsIGRpc3QueCAtIDEuMCwgZGlzdC54IC0gMi4wKTsKCiAgICBjb2VmID0gRklYKGNvZWYpOwogICAgY29lZiA9IDIuMCAqIHNpbihjb2VmKSAqIHNpbihjb2VmIC8gMi4wKSAvIChjb2VmICogY29lZik7CiAgICBjb2VmIC89IGRvdChjb2VmLCB2ZWM0KDEuMCkpOwoKICAgIHZlYzQgY29sMSA9IHZlYzQoVEVYMkQodGV4X2NvKSwgMS4wKTsKICAgIHZlYzQgY29sMiA9IHZlYzQoVEVYMkQodGV4X2NvICsgZHgpLCAxLjApOwoKICAgIHJldHVybiAobWF0NChjb2wxLCBjb2wxLCBjb2wyLCBjb2wyKSAqIGNvZWYpLnJnYjsKfQoKdmVjMyBnZXRfc2NhbmxpbmVfd2VpZ2h0KGZsb2F0IHgsIHZlYzMgY29sKQp7CiAgICB2ZWMzIGJlYW0gPSBtaXgodmVjMyhTQ0FOTElORV9TSVpFX01JTiksIHZlYzMoU0NBTkxJTkVfU0laRV9NQVgpLCBwb3coY29sLCB2ZWMzKDEuMCAvIFNDQU5MSU5FX1NIQVBFKSkpOwogICAgdmVjMyB4X211bCA9IDIuMCAvIGJlYW07CiAgICB2ZWMzIHhfb2Zmc2V0ID0geF9tdWwgKiAwLjU7CgogICAgcmV0dXJuIHNtb290aHN0ZXAoMC4wLCAxLjAsIDEuMCAtIGFicyh4ICogeF9tdWwgLSB4X29mZnNldCkpICogeF9vZmZzZXQ7Cn0KCnZlYzMgZ2V0X21hc2tfd2VpZ2h0KGZsb2F0IHgpCnsKICAgIGZsb2F0IGkgPSBtb2QoZmxvb3IoeCAqIE91dHB1dFNpemUueCAqIFRleHR1cmVTaXplLnggLyAoSW5wdXRTaXplLnggKiBNQVNLX1NJWkUpKSwgTUFTS19DT0xPUlMpOwoKICAgIGlmIChpID09IDAuMCkgcmV0dXJuIG1peCh2ZWMzKDEuMCwgMC4wLCAxLjApLCB2ZWMzKDEuMCwgMC4wLCAwLjApLCBNQVNLX0NPTE9SUyAtIDIuMCk7CiAgICBlbHNlIGlmIChpID09IDEuMCkgcmV0dXJuIHZlYzMoMC4wLCAxLjAsIDAuMCk7CiAgICBlbHNlIHJldHVybiB2ZWMzKDAuMCwgMC4wLCAxLjApOwp9Cgp2b2lkIG1haW4oKQp7CiAgICBmbG9hdCBzY2FsZSA9IGZsb29yKChPdXRwdXRTaXplLnkgLyBJbnB1dFNpemUueSkgKyAwLjAwMSk7CiAgICBmbG9hdCBvZmZzZXQgPSAxLjAgLyBzY2FsZSAqIDAuNTsKICAgIAogICAgaWYgKGJvb2wobW9kKHNjYWxlLCAyLjApKSkgb2Zmc2V0ID0gMC4wOwogICAgCiAgICB2ZWMyIGNvID0gKENvb3JkICogVGV4dHVyZVNpemUgLSB2ZWMyKDAuMCwgb2Zmc2V0ICogU0NBTkxJTkVfT0ZGU0VUKSkgLyBUZXh0dXJlU2l6ZTsKCiAgICB2ZWMzIGNvbF9nbG93ID0gZmlsdGVyX2dhdXNzaWFuKFRleHR1cmUsIGNvLCBUZXh0dXJlU2l6ZSk7CiAgICB2ZWMzIGNvbF9zb2Z0ID0gZmlsdGVyX2xhbmN6b3MoVGV4dHVyZSwgY28sIFRleHR1cmVTaXplLCBTSEFSUE5FU1NfSU1BR0UpOwogICAgdmVjMyBjb2xfc2hhcnAgPSBmaWx0ZXJfbGFuY3pvcyhUZXh0dXJlLCBjbywgVGV4dHVyZVNpemUsIFNIQVJQTkVTU19FREdFUyk7CiAgICB2ZWMzIGNvbCA9IHNxcnQoY29sX3NoYXJwICogY29sX3NvZnQpOwoKICAgIGNvbCAqPSBnZXRfc2NhbmxpbmVfd2VpZ2h0KGZyYWN0KGNvLnkgKiBUZXh0dXJlU2l6ZS55KSwgY29sX3NvZnQpOwogICAgY29sX2dsb3cgPSBzYXR1cmF0ZShjb2xfZ2xvdyAtIGNvbCk7CiAgICBjb2wgKz0gY29sX2dsb3cgKiBjb2xfZ2xvdyAqIEdMT1dfSEFMQVRJT047CiAgICBjb2wgPSBtaXgoY29sLCBjb2wgKiBnZXRfbWFza193ZWlnaHQoY28ueCkgKiBNQVNLX0NPTE9SUywgTUFTS19TVFJFTkdUSCk7CiAgICBjb2wgKz0gY29sX2dsb3cgKiBHTE9XX0RJRkZVU0lPTjsKICAgIGNvbCA9IHBvdyhjb2wgKiBCUklHSFRORVNTLCB2ZWMzKDEuMCAvIEdBTU1BX09VVFBVVCkpOwoKICAgIEZyYWdDb2xvciA9IHZlYzQoY29sLCAxLjApOwp9CgojZW5kaWYK",
            },
        ],
    },

    //https://github.com/libretro/glsl-shaders/blob/master/crt/crt-easymode.glslp
    "crt-easymode.glslp": {
        "shader": {
            "type": "text",
            "value": "shaders = 1\n\nshader0 = crt-easymode.glsl\nfilter_linear0 = false\n",
        },
        "resources": [
            {
                "name": "crt-easymode.glsl",
                "type": "base64",
                "value": "LyoKICAgIENSVCBTaGFkZXIgYnkgRWFzeU1vZGUKICAgIExpY2Vuc2U6IEdQTAoKICAgIEEgZmxhdCBDUlQgc2hhZGVyIGlkZWFsbHkgZm9yIDEwODBwIG9yIGhpZ2hlciBkaXNwbGF5cy4KCiAgICBSZWNvbW1lbmRlZCBTZXR0aW5nczoKCiAgICBWaWRlbwogICAgLSBBc3BlY3QgUmF0aW86ICA0OjMKICAgIC0gSW50ZWdlciBTY2FsZTogT2ZmCgogICAgU2hhZGVyCiAgICAtIEZpbHRlcjogTmVhcmVzdAogICAgLSBTY2FsZTogIERvbid0IENhcmUKCiAgICBFeGFtcGxlIFJHQiBNYXNrIFBhcmFtZXRlciBTZXR0aW5nczoKCiAgICBBcGVydHVyZSBHcmlsbGUgKERlZmF1bHQpCiAgICAtIERvdCBXaWR0aDogIDEKICAgIC0gRG90IEhlaWdodDogMQogICAgLSBTdGFnZ2VyOiAgICAwCgogICAgTG90dGVzJyBTaGFkb3cgTWFzawogICAgLSBEb3QgV2lkdGg6ICAyCiAgICAtIERvdCBIZWlnaHQ6IDEKICAgIC0gU3RhZ2dlcjogICAgMwoqLwoKLy8gUGFyYW1ldGVyIGxpbmVzIGdvIGhlcmU6CiNwcmFnbWEgcGFyYW1ldGVyIFNIQVJQTkVTU19IICJTaGFycG5lc3MgSG9yaXpvbnRhbCIgMC41IDAuMCAxLjAgMC4wNQojcHJhZ21hIHBhcmFtZXRlciBTSEFSUE5FU1NfViAiU2hhcnBuZXNzIFZlcnRpY2FsIiAxLjAgMC4wIDEuMCAwLjA1CiNwcmFnbWEgcGFyYW1ldGVyIE1BU0tfU1RSRU5HVEggIk1hc2sgU3RyZW5ndGgiIDAuMyAwLjAgMS4wIDAuMDEKI3ByYWdtYSBwYXJhbWV0ZXIgTUFTS19ET1RfV0lEVEggIk1hc2sgRG90IFdpZHRoIiAxLjAgMS4wIDEwMC4wIDEuMAojcHJhZ21hIHBhcmFtZXRlciBNQVNLX0RPVF9IRUlHSFQgIk1hc2sgRG90IEhlaWdodCIgMS4wIDEuMCAxMDAuMCAxLjAKI3ByYWdtYSBwYXJhbWV0ZXIgTUFTS19TVEFHR0VSICJNYXNrIFN0YWdnZXIiIDAuMCAwLjAgMTAwLjAgMS4wCiNwcmFnbWEgcGFyYW1ldGVyIE1BU0tfU0laRSAiTWFzayBTaXplIiAxLjAgMS4wIDEwMC4wIDEuMAojcHJhZ21hIHBhcmFtZXRlciBTQ0FOTElORV9TVFJFTkdUSCAiU2NhbmxpbmUgU3RyZW5ndGgiIDEuMCAwLjAgMS4wIDAuMDUKI3ByYWdtYSBwYXJhbWV0ZXIgU0NBTkxJTkVfQkVBTV9XSURUSF9NSU4gIlNjYW5saW5lIEJlYW0gV2lkdGggTWluLiIgMS41IDAuNSA1LjAgMC41CiNwcmFnbWEgcGFyYW1ldGVyIFNDQU5MSU5FX0JFQU1fV0lEVEhfTUFYICJTY2FubGluZSBCZWFtIFdpZHRoIE1heC4iIDEuNSAwLjUgNS4wIDAuNQojcHJhZ21hIHBhcmFtZXRlciBTQ0FOTElORV9CUklHSFRfTUlOICJTY2FubGluZSBCcmlnaHRuZXNzIE1pbi4iIDAuMzUgMC4wIDEuMCAwLjA1CiNwcmFnbWEgcGFyYW1ldGVyIFNDQU5MSU5FX0JSSUdIVF9NQVggIlNjYW5saW5lIEJyaWdodG5lc3MgTWF4LiIgMC42NSAwLjAgMS4wIDAuMDUKI3ByYWdtYSBwYXJhbWV0ZXIgU0NBTkxJTkVfQ1VUT0ZGICJTY2FubGluZSBDdXRvZmYiIDQwMC4wIDEuMCAxMDAwLjAgMS4wCiNwcmFnbWEgcGFyYW1ldGVyIEdBTU1BX0lOUFVUICJHYW1tYSBJbnB1dCIgMi4wIDAuMSA1LjAgMC4xCiNwcmFnbWEgcGFyYW1ldGVyIEdBTU1BX09VVFBVVCAiR2FtbWEgT3V0cHV0IiAxLjggMC4xIDUuMCAwLjEKI3ByYWdtYSBwYXJhbWV0ZXIgQlJJR0hUX0JPT1NUICJCcmlnaHRuZXNzIEJvb3N0IiAxLjIgMS4wIDIuMCAwLjAxCiNwcmFnbWEgcGFyYW1ldGVyIERJTEFUSU9OICJEaWxhdGlvbiIgMS4wIDAuMCAxLjAgMS4wCgojaWYgZGVmaW5lZChWRVJURVgpCgojaWYgX19WRVJTSU9OX18gPj0gMTMwCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgb3V0CiNkZWZpbmUgQ09NUEFUX0FUVFJJQlVURSBpbgojZGVmaW5lIENPTVBBVF9URVhUVVJFIHRleHR1cmUKI2Vsc2UKI2RlZmluZSBDT01QQVRfVkFSWUlORyB2YXJ5aW5nIAojZGVmaW5lIENPTVBBVF9BVFRSSUJVVEUgYXR0cmlidXRlIAojZGVmaW5lIENPTVBBVF9URVhUVVJFIHRleHR1cmUyRAojZW5kaWYKCiNpZmRlZiBHTF9FUwojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04gbWVkaXVtcAojZWxzZQojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04KI2VuZGlmCgpDT01QQVRfQVRUUklCVVRFIHZlYzQgVmVydGV4Q29vcmQ7CkNPTVBBVF9BVFRSSUJVVEUgdmVjNCBDT0xPUjsKQ09NUEFUX0FUVFJJQlVURSB2ZWM0IFRleENvb3JkOwpDT01QQVRfVkFSWUlORyB2ZWM0IENPTDA7CkNPTVBBVF9WQVJZSU5HIHZlYzQgVEVYMDsKCnZlYzQgX29Qb3NpdGlvbjE7IAp1bmlmb3JtIG1hdDQgTVZQTWF0cml4Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lRGlyZWN0aW9uOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lQ291bnQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIE91dHB1dFNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIFRleHR1cmVTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBJbnB1dFNpemU7Cgp2b2lkIG1haW4oKQp7CiAgICBnbF9Qb3NpdGlvbiA9IE1WUE1hdHJpeCAqIFZlcnRleENvb3JkOwogICAgQ09MMCA9IENPTE9SOwogICAgVEVYMC54eSA9IFRleENvb3JkLnh5Owp9CgojZWxpZiBkZWZpbmVkKEZSQUdNRU5UKQoKI2lmIF9fVkVSU0lPTl9fID49IDEzMAojZGVmaW5lIENPTVBBVF9WQVJZSU5HIGluCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZQpvdXQgdmVjNCBGcmFnQ29sb3I7CiNlbHNlCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgdmFyeWluZwojZGVmaW5lIEZyYWdDb2xvciBnbF9GcmFnQ29sb3IKI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlMkQKI2VuZGlmCgojaWZkZWYgR0xfRVMKI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdICnByZWNpc2lvbiBoaWdocCBmbG9hdDsKI2Vsc2UKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CnByZWNpc2lvbiBtZWRpdW1wIGludDsKI2VuZGlmCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTiBtZWRpdW1wCiNlbHNlCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTgojZW5kaWYKCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVEaXJlY3Rpb247CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVDb3VudDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgT3V0cHV0U2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgVGV4dHVyZVNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIElucHV0U2l6ZTsKdW5pZm9ybSBzYW1wbGVyMkQgVGV4dHVyZTsKQ09NUEFUX1ZBUllJTkcgdmVjNCBURVgwOwoKI2RlZmluZSBGSVgoYykgbWF4KGFicyhjKSwgMWUtNSkKI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU4OQoKI2RlZmluZSBURVgyRChjKSBkaWxhdGUoQ09NUEFUX1RFWFRVUkUoVGV4dHVyZSwgYykpCgovLyBjb21wYXRpYmlsaXR5ICNkZWZpbmVzCiNkZWZpbmUgU291cmNlIFRleHR1cmUKI2RlZmluZSB2VGV4Q29vcmQgVEVYMC54eQoKI2RlZmluZSBTb3VyY2VTaXplIHZlYzQoVGV4dHVyZVNpemUsIDEuMCAvIFRleHR1cmVTaXplKSAvL2VpdGhlciBUZXh0dXJlU2l6ZSBvciBJbnB1dFNpemUKI2RlZmluZSBvdXRzaXplIHZlYzQoT3V0cHV0U2l6ZSwgMS4wIC8gT3V0cHV0U2l6ZSkKCiNpZmRlZiBQQVJBTUVURVJfVU5JRk9STQovLyBBbGwgcGFyYW1ldGVyIGZsb2F0cyBuZWVkIHRvIGhhdmUgQ09NUEFUX1BSRUNJU0lPTiBpbiBmcm9udCBvZiB0aGVtCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBTSEFSUE5FU1NfSDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IFNIQVJQTkVTU19WOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgTUFTS19TVFJFTkdUSDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IE1BU0tfRE9UX1dJRFRIOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgTUFTS19ET1RfSEVJR0hUOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgTUFTS19TVEFHR0VSOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgTUFTS19TSVpFOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgU0NBTkxJTkVfU1RSRU5HVEg7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBTQ0FOTElORV9CRUFNX1dJRFRIX01JTjsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IFNDQU5MSU5FX0JFQU1fV0lEVEhfTUFYOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgU0NBTkxJTkVfQlJJR0hUX01JTjsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IFNDQU5MSU5FX0JSSUdIVF9NQVg7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBTQ0FOTElORV9DVVRPRkY7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBHQU1NQV9JTlBVVDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IEdBTU1BX09VVFBVVDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IEJSSUdIVF9CT09TVDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IERJTEFUSU9OOwojZWxzZQojZGVmaW5lIFNIQVJQTkVTU19IIDAuNQojZGVmaW5lIFNIQVJQTkVTU19WIDEuMAojZGVmaW5lIE1BU0tfU1RSRU5HVEggMC4zCiNkZWZpbmUgTUFTS19ET1RfV0lEVEggMS4wCiNkZWZpbmUgTUFTS19ET1RfSEVJR0hUIDEuMAojZGVmaW5lIE1BU0tfU1RBR0dFUiAwLjAKI2RlZmluZSBNQVNLX1NJWkUgMS4wCiNkZWZpbmUgU0NBTkxJTkVfU1RSRU5HVEggMS4wCiNkZWZpbmUgU0NBTkxJTkVfQkVBTV9XSURUSF9NSU4gMS41CiNkZWZpbmUgU0NBTkxJTkVfQkVBTV9XSURUSF9NQVggMS41CiNkZWZpbmUgU0NBTkxJTkVfQlJJR0hUX01JTiAwLjM1CiNkZWZpbmUgU0NBTkxJTkVfQlJJR0hUX01BWCAwLjY1CiNkZWZpbmUgU0NBTkxJTkVfQ1VUT0ZGIDQwMC4wCiNkZWZpbmUgR0FNTUFfSU5QVVQgMi4wCiNkZWZpbmUgR0FNTUFfT1VUUFVUIDEuOAojZGVmaW5lIEJSSUdIVF9CT09TVCAxLjIKI2RlZmluZSBESUxBVElPTiAxLjAKI2VuZGlmCgovLyBTZXQgdG8gMCB0byB1c2UgbGluZWFyIGZpbHRlciBhbmQgZ2FpbiBzcGVlZAojZGVmaW5lIEVOQUJMRV9MQU5DWk9TIDEKCnZlYzQgZGlsYXRlKHZlYzQgY29sKQp7CiAgICB2ZWM0IHggPSBtaXgodmVjNCgxLjApLCBjb2wsIERJTEFUSU9OKTsKCiAgICByZXR1cm4gY29sICogeDsKfQoKZmxvYXQgY3VydmVfZGlzdGFuY2UoZmxvYXQgeCwgZmxvYXQgc2hhcnApCnsKCi8qCiAgICBhcHBseSBoYWxmLWNpcmNsZSBzLWN1cnZlIHRvIGRpc3RhbmNlIGZvciBzaGFycGVyIChtb3JlIHBpeGVsYXRlZCkgaW50ZXJwb2xhdGlvbgogICAgc2luZ2xlIGxpbmUgZm9ybXVsYSBmb3IgR3JhcGggVG95OgogICAgMC41IC0gc3FydCgwLjI1IC0gKHggLSBzdGVwKDAuNSwgeCkpICogKHggLSBzdGVwKDAuNSwgeCkpKSAqIHNpZ24oMC41IC0geCkKKi8KCiAgICBmbG9hdCB4X3N0ZXAgPSBzdGVwKDAuNSwgeCk7CiAgICBmbG9hdCBjdXJ2ZSA9IDAuNSAtIHNxcnQoMC4yNSAtICh4IC0geF9zdGVwKSAqICh4IC0geF9zdGVwKSkgKiBzaWduKDAuNSAtIHgpOwoKICAgIHJldHVybiBtaXgoeCwgY3VydmUsIHNoYXJwKTsKfQoKbWF0NCBnZXRfY29sb3JfbWF0cml4KHZlYzIgY28sIHZlYzIgZHgpCnsKICAgIHJldHVybiBtYXQ0KFRFWDJEKGNvIC0gZHgpLCBURVgyRChjbyksIFRFWDJEKGNvICsgZHgpLCBURVgyRChjbyArIDIuMCAqIGR4KSk7Cn0KCnZlYzMgZmlsdGVyX2xhbmN6b3ModmVjNCBjb2VmZnMsIG1hdDQgY29sb3JfbWF0cml4KQp7CiAgICB2ZWM0IGNvbCAgICAgICAgPSBjb2xvcl9tYXRyaXggKiBjb2VmZnM7CiAgICB2ZWM0IHNhbXBsZV9taW4gPSBtaW4oY29sb3JfbWF0cml4WzFdLCBjb2xvcl9tYXRyaXhbMl0pOwogICAgdmVjNCBzYW1wbGVfbWF4ID0gbWF4KGNvbG9yX21hdHJpeFsxXSwgY29sb3JfbWF0cml4WzJdKTsKCiAgICBjb2wgPSBjbGFtcChjb2wsIHNhbXBsZV9taW4sIHNhbXBsZV9tYXgpOwoKICAgIHJldHVybiBjb2wucmdiOwp9Cgp2b2lkIG1haW4oKQp7CiAgICB2ZWMyIGR4ICAgICA9IHZlYzIoU291cmNlU2l6ZS56LCAwLjApOwogICAgdmVjMiBkeSAgICAgPSB2ZWMyKDAuMCwgU291cmNlU2l6ZS53KTsKICAgIHZlYzIgcGl4X2NvID0gdlRleENvb3JkICogU291cmNlU2l6ZS54eSAtIHZlYzIoMC41LCAwLjUpOwogICAgdmVjMiB0ZXhfY28gPSAoZmxvb3IocGl4X2NvKSArIHZlYzIoMC41LCAwLjUpKSAqIFNvdXJjZVNpemUuenc7CiAgICB2ZWMyIGRpc3QgICA9IGZyYWN0KHBpeF9jbyk7CiAgICBmbG9hdCBjdXJ2ZV94OwogICAgdmVjMyBjb2wsIGNvbDI7CgojaWYgRU5BQkxFX0xBTkNaT1MKICAgIGN1cnZlX3ggPSBjdXJ2ZV9kaXN0YW5jZShkaXN0LngsIFNIQVJQTkVTU19IICogU0hBUlBORVNTX0gpOwoKICAgIHZlYzQgY29lZmZzID0gUEkgKiB2ZWM0KDEuMCArIGN1cnZlX3gsIGN1cnZlX3gsIDEuMCAtIGN1cnZlX3gsIDIuMCAtIGN1cnZlX3gpOwoKICAgIGNvZWZmcyA9IEZJWChjb2VmZnMpOwogICAgY29lZmZzID0gMi4wICogc2luKGNvZWZmcykgKiBzaW4oY29lZmZzICogMC41KSAvIChjb2VmZnMgKiBjb2VmZnMpOwogICAgY29lZmZzIC89IGRvdChjb2VmZnMsIHZlYzQoMS4wKSk7CgogICAgY29sICA9IGZpbHRlcl9sYW5jem9zKGNvZWZmcywgZ2V0X2NvbG9yX21hdHJpeCh0ZXhfY28sIGR4KSk7CiAgICBjb2wyID0gZmlsdGVyX2xhbmN6b3MoY29lZmZzLCBnZXRfY29sb3JfbWF0cml4KHRleF9jbyArIGR5LCBkeCkpOwojZWxzZQogICAgY3VydmVfeCA9IGN1cnZlX2Rpc3RhbmNlKGRpc3QueCwgU0hBUlBORVNTX0gpOwoKICAgIGNvbCAgPSBtaXgoVEVYMkQodGV4X2NvKS5yZ2IsICAgICAgVEVYMkQodGV4X2NvICsgZHgpLnJnYiwgICAgICBjdXJ2ZV94KTsKICAgIGNvbDIgPSBtaXgoVEVYMkQodGV4X2NvICsgZHkpLnJnYiwgVEVYMkQodGV4X2NvICsgZHggKyBkeSkucmdiLCBjdXJ2ZV94KTsKI2VuZGlmCgogICAgY29sID0gbWl4KGNvbCwgY29sMiwgY3VydmVfZGlzdGFuY2UoZGlzdC55LCBTSEFSUE5FU1NfVikpOwogICAgY29sID0gcG93KGNvbCwgdmVjMyhHQU1NQV9JTlBVVCAvIChESUxBVElPTiArIDEuMCkpKTsKCiAgICBmbG9hdCBsdW1hICAgICAgICA9IGRvdCh2ZWMzKDAuMjEyNiwgMC43MTUyLCAwLjA3MjIpLCBjb2wpOwogICAgZmxvYXQgYnJpZ2h0ICAgICAgPSAobWF4KGNvbC5yLCBtYXgoY29sLmcsIGNvbC5iKSkgKyBsdW1hKSAqIDAuNTsKICAgIGZsb2F0IHNjYW5fYnJpZ2h0ID0gY2xhbXAoYnJpZ2h0LCBTQ0FOTElORV9CUklHSFRfTUlOLCBTQ0FOTElORV9CUklHSFRfTUFYKTsKICAgIGZsb2F0IHNjYW5fYmVhbSAgID0gY2xhbXAoYnJpZ2h0ICogU0NBTkxJTkVfQkVBTV9XSURUSF9NQVgsIFNDQU5MSU5FX0JFQU1fV0lEVEhfTUlOLCBTQ0FOTElORV9CRUFNX1dJRFRIX01BWCk7CiAgICBmbG9hdCBzY2FuX3dlaWdodCA9IDEuMCAtIHBvdyhjb3ModlRleENvb3JkLnkgKiAyLjAgKiBQSSAqIFNvdXJjZVNpemUueSkgKiAwLjUgKyAwLjUsIHNjYW5fYmVhbSkgKiBTQ0FOTElORV9TVFJFTkdUSDsKCiAgICBmbG9hdCBtYXNrICAgPSAxLjAgLSBNQVNLX1NUUkVOR1RIOyAgICAKICAgIHZlYzIgbW9kX2ZhYyA9IGZsb29yKHZUZXhDb29yZCAqIG91dHNpemUueHkgKiBTb3VyY2VTaXplLnh5IC8gKElucHV0U2l6ZS54eSAqIHZlYzIoTUFTS19TSVpFLCBNQVNLX0RPVF9IRUlHSFQgKiBNQVNLX1NJWkUpKSk7CiAgICBpbnQgZG90X25vICAgPSBpbnQobW9kKChtb2RfZmFjLnggKyBtb2QobW9kX2ZhYy55LCAyLjApICogTUFTS19TVEFHR0VSKSAvIE1BU0tfRE9UX1dJRFRILCAzLjApKTsKICAgIHZlYzMgbWFza193ZWlnaHQ7CgogICAgaWYgICAgICAoZG90X25vID09IDApIG1hc2tfd2VpZ2h0ID0gdmVjMygxLjAsICBtYXNrLCBtYXNrKTsKICAgIGVsc2UgaWYgKGRvdF9ubyA9PSAxKSBtYXNrX3dlaWdodCA9IHZlYzMobWFzaywgMS4wLCAgbWFzayk7CiAgICBlbHNlICAgICAgICAgICAgICAgICAgbWFza193ZWlnaHQgPSB2ZWMzKG1hc2ssIG1hc2ssIDEuMCk7CgogICAgaWYgKElucHV0U2l6ZS55ID49IFNDQU5MSU5FX0NVVE9GRikgCiAgICAgICAgc2Nhbl93ZWlnaHQgPSAxLjA7CgogICAgY29sMiA9IGNvbC5yZ2I7CiAgICBjb2wgKj0gdmVjMyhzY2FuX3dlaWdodCk7CiAgICBjb2wgID0gbWl4KGNvbCwgY29sMiwgc2Nhbl9icmlnaHQpOwogICAgY29sICo9IG1hc2tfd2VpZ2h0OwogICAgY29sICA9IHBvdyhjb2wsIHZlYzMoMS4wIC8gR0FNTUFfT1VUUFVUKSk7CgogICAgRnJhZ0NvbG9yID0gdmVjNChjb2wgKiBCUklHSFRfQk9PU1QsIDEuMCk7Cn0gCiNlbmRpZgo=",
            },
        ],
    },

    //https://github.com/libretro/glsl-shaders/blob/master/crt/crt-geom.glslp
    "crt-geom.glslp": {
        "shader": {
            "type": "text",
            "value": "shaders = 1\n\nshader0 = crt-geom.glsl\nfilter_linear0 = false\n",
        },
        "resources": [
            {
                "name": "crt-geom.glsl",
                "type": "base64",
                "value": "LyoKICAgIENSVC1pbnRlcmxhY2VkCgogICAgQ29weXJpZ2h0IChDKSAyMDEwLTIwMTIgY2d3ZywgVGhlbWFpc3RlciBhbmQgRE9MTFMKCiAgICBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAogICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUKICAgIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlciB2ZXJzaW9uIDIgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikKICAgIGFueSBsYXRlciB2ZXJzaW9uLgoKICAgIChjZ3dnIGdhdmUgdGhlaXIgY29uc2VudCB0byBoYXZlIHRoZSBvcmlnaW5hbCB2ZXJzaW9uIG9mIHRoaXMgc2hhZGVyCiAgICBkaXN0cmlidXRlZCB1bmRlciB0aGUgR1BMIGluIHRoaXMgbWVzc2FnZToKCiAgICAgICAgaHR0cDovL2JvYXJkLmJ5dXUub3JnL3ZpZXd0b3BpYy5waHA/cD0yNjA3NSNwMjYwNzUKCiAgICAgICAgIkZlZWwgZnJlZSB0byBkaXN0cmlidXRlIG15IHNoYWRlcnMgdW5kZXIgdGhlIEdQTC4gQWZ0ZXIgYWxsLCB0aGUKICAgICAgICBiYXJyZWwgZGlzdG9ydGlvbiBjb2RlIHdhcyB0YWtlbiBmcm9tIHRoZSBDdXJ2YXR1cmUgc2hhZGVyLCB3aGljaCBpcwogICAgICAgIHVuZGVyIHRoZSBHUEwuIgogICAgKQoJVGhpcyBzaGFkZXIgdmFyaWFudCBpcyBwcmUtY29uZmlndXJlZCB3aXRoIHNjcmVlbiBjdXJ2YXR1cmUKKi8KCiNwcmFnbWEgcGFyYW1ldGVyIENSVGdhbW1hICJDUlRHZW9tIFRhcmdldCBHYW1tYSIgMi40IDAuMSA1LjAgMC4xCiNwcmFnbWEgcGFyYW1ldGVyIElOViAiSW52ZXJzZSBHYW1tYS9DUlQtR2VvbSBHYW1tYSBvdXQiIDEuMCAwLjAgMS4wIDEuMAojcHJhZ21hIHBhcmFtZXRlciBtb25pdG9yZ2FtbWEgIkNSVEdlb20gTW9uaXRvciBHYW1tYSIgMi4yIDAuMSA1LjAgMC4xCiNwcmFnbWEgcGFyYW1ldGVyIGQgIkNSVEdlb20gRGlzdGFuY2UiIDEuNiAwLjEgMy4wIDAuMQojcHJhZ21hIHBhcmFtZXRlciBDVVJWQVRVUkUgIkNSVEdlb20gQ3VydmF0dXJlIFRvZ2dsZSIgMS4wIDAuMCAxLjAgMS4wCiNwcmFnbWEgcGFyYW1ldGVyIFIgIkNSVEdlb20gQ3VydmF0dXJlIFJhZGl1cyIgMi4wIDAuMSAxMC4wIDAuMQojcHJhZ21hIHBhcmFtZXRlciBjb3JuZXJzaXplICJDUlRHZW9tIENvcm5lciBTaXplIiAwLjAzIDAuMDAxIDEuMCAwLjAwNQojcHJhZ21hIHBhcmFtZXRlciBjb3JuZXJzbW9vdGggIkNSVEdlb20gQ29ybmVyIFNtb290aG5lc3MiIDEwMDAuMCA4MC4wIDIwMDAuMCAxMDAuMAojcHJhZ21hIHBhcmFtZXRlciB4X3RpbHQgIkNSVEdlb20gSG9yaXpvbnRhbCBUaWx0IiAwLjAgLTAuNSAwLjUgMC4wNQojcHJhZ21hIHBhcmFtZXRlciB5X3RpbHQgIkNSVEdlb20gVmVydGljYWwgVGlsdCIgMC4wIC0wLjUgMC41IDAuMDUKI3ByYWdtYSBwYXJhbWV0ZXIgb3ZlcnNjYW5feCAiQ1JUR2VvbSBIb3Jpei4gT3ZlcnNjYW4gJSIgMTAwLjAgLTEyNS4wIDEyNS4wIDEuMAojcHJhZ21hIHBhcmFtZXRlciBvdmVyc2Nhbl95ICJDUlRHZW9tIFZlcnQuIE92ZXJzY2FuICUiIDEwMC4wIC0xMjUuMCAxMjUuMCAxLjAKI3ByYWdtYSBwYXJhbWV0ZXIgRE9UTUFTSyAiQ1JUR2VvbSBEb3QgTWFzayBTdHJlbmd0aCIgMC4zIDAuMCAxLjAgMC4xCiNwcmFnbWEgcGFyYW1ldGVyIFNIQVJQRVIgIkNSVEdlb20gU2hhcnBuZXNzIiAxLjAgMS4wIDMuMCAxLjAKI3ByYWdtYSBwYXJhbWV0ZXIgc2NhbmxpbmVfd2VpZ2h0ICJDUlRHZW9tIFNjYW5saW5lIFdlaWdodCIgMC4zIDAuMSAwLjUgMC4wNQojcHJhZ21hIHBhcmFtZXRlciBsdW0gIkNSVEdlb20gTHVtaW5hbmNlIiAwLjAgMC4wIDEuMCAwLjAxCiNwcmFnbWEgcGFyYW1ldGVyIGludGVybGFjZV9kZXRlY3QgIkNSVEdlb20gSW50ZXJsYWNpbmcgU2ltdWxhdGlvbiIgMS4wIDAuMCAxLjAgMS4wCiNwcmFnbWEgcGFyYW1ldGVyIFNBVFVSQVRJT04gIkNSVEdlb20gU2F0dXJhdGlvbiIgMS4wIDAuMCAyLjAgMC4wNQoKI2lmbmRlZiBQQVJBTUVURVJfVU5JRk9STQojZGVmaW5lIENSVGdhbW1hIDIuNAojZGVmaW5lIG1vbml0b3JnYW1tYSAyLjIKI2RlZmluZSBkIDEuNgojZGVmaW5lIENVUlZBVFVSRSAxLjAKI2RlZmluZSBSIDIuMAojZGVmaW5lIGNvcm5lcnNpemUgMC4wMwojZGVmaW5lIGNvcm5lcnNtb290aCAxMDAwLjAKI2RlZmluZSB4X3RpbHQgMC4wCiNkZWZpbmUgeV90aWx0IDAuMAojZGVmaW5lIG92ZXJzY2FuX3ggMTAwLjAKI2RlZmluZSBvdmVyc2Nhbl95IDEwMC4wCiNkZWZpbmUgRE9UTUFTSyAwLjMKI2RlZmluZSBTSEFSUEVSIDEuMAojZGVmaW5lIHNjYW5saW5lX3dlaWdodCAwLjMKI2RlZmluZSBsdW0gMC4wCiNkZWZpbmUgaW50ZXJsYWNlX2RldGVjdCAxLjAKI2RlZmluZSBTQVRVUkFUSU9OIDEuMAojZGVmaW5lIElOViAxLjAKI2VuZGlmCgojaWYgZGVmaW5lZChWRVJURVgpCgojaWYgX19WRVJTSU9OX18gPj0gMTMwCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgb3V0CiNkZWZpbmUgQ09NUEFUX0FUVFJJQlVURSBpbgojZGVmaW5lIENPTVBBVF9URVhUVVJFIHRleHR1cmUKI2Vsc2UKI2RlZmluZSBDT01QQVRfVkFSWUlORyB2YXJ5aW5nIAojZGVmaW5lIENPTVBBVF9BVFRSSUJVVEUgYXR0cmlidXRlIAojZGVmaW5lIENPTVBBVF9URVhUVVJFIHRleHR1cmUyRAojZW5kaWYKCiNpZmRlZiBHTF9FUwojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04gbWVkaXVtcAojZWxzZQojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04KI2VuZGlmCgpDT01QQVRfQVRUUklCVVRFIHZlYzQgVmVydGV4Q29vcmQ7CkNPTVBBVF9BVFRSSUJVVEUgdmVjNCBDT0xPUjsKQ09NUEFUX0FUVFJJQlVURSB2ZWM0IFRleENvb3JkOwpDT01QQVRfVkFSWUlORyB2ZWM0IENPTDA7CkNPTVBBVF9WQVJZSU5HIHZlYzQgVEVYMDsKCnZlYzQgX29Qb3NpdGlvbjE7IAp1bmlmb3JtIG1hdDQgTVZQTWF0cml4Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lRGlyZWN0aW9uOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lQ291bnQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIE91dHB1dFNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIFRleHR1cmVTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBJbnB1dFNpemU7CgpDT01QQVRfVkFSWUlORyB2ZWMyIG92ZXJzY2FuOwpDT01QQVRfVkFSWUlORyB2ZWMyIGFzcGVjdDsKQ09NUEFUX1ZBUllJTkcgdmVjMyBzdHJldGNoOwpDT01QQVRfVkFSWUlORyB2ZWMyIHNpbmFuZ2xlOwpDT01QQVRfVkFSWUlORyB2ZWMyIGNvc2FuZ2xlOwpDT01QQVRfVkFSWUlORyB2ZWMyIG9uZTsKQ09NUEFUX1ZBUllJTkcgZmxvYXQgbW9kX2ZhY3RvcjsKQ09NUEFUX1ZBUllJTkcgdmVjMiBpbGZhYzsKCiNpZmRlZiBQQVJBTUVURVJfVU5JRk9STQp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgQ1JUZ2FtbWE7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBtb25pdG9yZ2FtbWE7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBkOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgQ1VSVkFUVVJFOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgUjsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IGNvcm5lcnNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBjb3JuZXJzbW9vdGg7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCB4X3RpbHQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCB5X3RpbHQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBvdmVyc2Nhbl94Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgb3ZlcnNjYW5feTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IERPVE1BU0s7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBTSEFSUEVSOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgc2NhbmxpbmVfd2VpZ2h0Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgbHVtOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgaW50ZXJsYWNlX2RldGVjdDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IFNBVFVSQVRJT047CiNlbmRpZgoKI2RlZmluZSBGSVgoYykgbWF4KGFicyhjKSwgMWUtNSk7CgpmbG9hdCBpbnRlcnNlY3QodmVjMiB4eSkKICAgICAgICB7CglmbG9hdCBBID0gZG90KHh5LHh5KStkKmQ7CglmbG9hdCBCID0gMi4wKihSKihkb3QoeHksc2luYW5nbGUpLWQqY29zYW5nbGUueCpjb3NhbmdsZS55KS1kKmQpOwoJZmxvYXQgQyA9IGQqZCArIDIuMCpSKmQqY29zYW5nbGUueCpjb3NhbmdsZS55OwoJcmV0dXJuICgtQi1zcXJ0KEIqQi00LjAqQSpDKSkvKDIuMCpBKTsKICAgICAgICB9Cgp2ZWMyIGJrd3RyYW5zKHZlYzIgeHkpCiAgICAgICAgewoJZmxvYXQgYyA9IGludGVyc2VjdCh4eSk7Cgl2ZWMyIHBvaW50ID0gdmVjMihjKSp4eTsKCXBvaW50IC09IHZlYzIoLVIpKnNpbmFuZ2xlOwoJcG9pbnQgLz0gdmVjMihSKTsKCXZlYzIgdGFuZyA9IHNpbmFuZ2xlL2Nvc2FuZ2xlOwoJdmVjMiBwb2MgPSBwb2ludC9jb3NhbmdsZTsKCWZsb2F0IEEgPSBkb3QodGFuZyx0YW5nKSsxLjA7CglmbG9hdCBCID0gLTIuMCpkb3QocG9jLHRhbmcpOwoJZmxvYXQgQyA9IGRvdChwb2MscG9jKS0xLjA7CglmbG9hdCBhID0gKC1CK3NxcnQoQipCLTQuMCpBKkMpKS8oMi4wKkEpOwoJdmVjMiB1diA9IChwb2ludC1hKnNpbmFuZ2xlKS9jb3NhbmdsZTsKCWZsb2F0IHIgPSBSKmFjb3MoYSk7CglyZXR1cm4gdXYqci9zaW4oci9SKTsKICAgICAgICB9Cgp2ZWMyIGZ3dHJhbnModmVjMiB1dikKICAgICAgICB7CglmbG9hdCByID0gRklYKHNxcnQoZG90KHV2LHV2KSkpOwoJdXYgKj0gc2luKHIvUikvcjsKCWZsb2F0IHggPSAxLjAtY29zKHIvUik7CglmbG9hdCBEID0gZC9SICsgeCpjb3NhbmdsZS54KmNvc2FuZ2xlLnkrZG90KHV2LHNpbmFuZ2xlKTsKCXJldHVybiBkKih1dipjb3NhbmdsZS14KnNpbmFuZ2xlKS9EOwogICAgICAgIH0KCnZlYzMgbWF4c2NhbGUoKQogICAgICAgIHsKCXZlYzIgYyA9IGJrd3RyYW5zKC1SICogc2luYW5nbGUgLyAoMS4wICsgUi9kKmNvc2FuZ2xlLngqY29zYW5nbGUueSkpOwoJdmVjMiBhID0gdmVjMigwLjUsMC41KSphc3BlY3Q7Cgl2ZWMyIGxvID0gdmVjMihmd3RyYW5zKHZlYzIoLWEueCxjLnkpKS54LCBmd3RyYW5zKHZlYzIoYy54LC1hLnkpKS55KS9hc3BlY3Q7Cgl2ZWMyIGhpID0gdmVjMihmd3RyYW5zKHZlYzIoK2EueCxjLnkpKS54LCBmd3RyYW5zKHZlYzIoYy54LCthLnkpKS55KS9hc3BlY3Q7CglyZXR1cm4gdmVjMygoaGkrbG8pKmFzcGVjdCowLjUsbWF4KGhpLngtbG8ueCxoaS55LWxvLnkpKTsKICAgICAgICB9Cgp2b2lkIG1haW4oKQp7Ci8vIFNUQVJUIG9mIHBhcmFtZXRlcnMKCi8vIGdhbW1hIG9mIHNpbXVsYXRlZCBDUlQKLy8JQ1JUZ2FtbWEgPSAxLjg7Ci8vIGdhbW1hIG9mIGRpc3BsYXkgbW9uaXRvciAodHlwaWNhbGx5IDIuMiBpcyBjb3JyZWN0KQovLwltb25pdG9yZ2FtbWEgPSAyLjI7Ci8vIG92ZXJzY2FuIChlLmcuIDEuMDIgZm9yIDIlIG92ZXJzY2FuKQoJb3ZlcnNjYW4gPSB2ZWMyKDEuMDAsMS4wMCk7Ci8vIGFzcGVjdCByYXRpbwoJYXNwZWN0ID0gdmVjMigxLjAsIDAuNzUpOwovLyBsZW5ndGhzIGFyZSBtZWFzdXJlZCBpbiB1bml0cyBvZiAoYXBwcm94aW1hdGVseSkgdGhlIHdpZHRoCi8vIG9mIHRoZSBtb25pdG9yIHNpbXVsYXRlZCBkaXN0YW5jZSBmcm9tIHZpZXdlciB0byBtb25pdG9yCi8vCWQgPSAyLjA7Ci8vIHJhZGl1cyBvZiBjdXJ2YXR1cmUKLy8JUiA9IDEuNTsKLy8gdGlsdCBhbmdsZSBpbiByYWRpYW5zCi8vIChiZWhhdmlvciBtaWdodCBiZSBhIGJpdCB3cm9uZyBpZiBib3RoIGNvbXBvbmVudHMgYXJlCi8vIG5vbnplcm8pCgljb25zdCB2ZWMyIGFuZ2xlID0gdmVjMigwLjAsMC4wKTsKLy8gc2l6ZSBvZiBjdXJ2ZWQgY29ybmVycwovLwljb3JuZXJzaXplID0gMC4wMzsKLy8gYm9yZGVyIHNtb290aG5lc3MgcGFyYW1ldGVyCi8vIGRlY3JlYXNlIGlmIGJvcmRlcnMgYXJlIHRvbyBhbGlhc2VkCi8vCWNvcm5lcnNtb290aCA9IDEwMDAuMDsKCi8vIEVORCBvZiBwYXJhbWV0ZXJzCgogICAgdmVjNCBfb0NvbG9yOwogICAgdmVjMiBfb3RleENvb3JkOwogICAgZ2xfUG9zaXRpb24gPSBWZXJ0ZXhDb29yZC54ICogTVZQTWF0cml4WzBdICsgVmVydGV4Q29vcmQueSAqIE1WUE1hdHJpeFsxXSArIFZlcnRleENvb3JkLnogKiBNVlBNYXRyaXhbMl0gKyBWZXJ0ZXhDb29yZC53ICogTVZQTWF0cml4WzNdOwogICAgX29Qb3NpdGlvbjEgPSBnbF9Qb3NpdGlvbjsKICAgIF9vQ29sb3IgPSBDT0xPUjsKICAgIF9vdGV4Q29vcmQgPSBUZXhDb29yZC54eSoxLjAwMDE7CiAgICBDT0wwID0gQ09MT1I7CiAgICBURVgwLnh5ID0gVGV4Q29vcmQueHkqMS4wMDAxOwoKLy8gUHJlY2FsY3VsYXRlIGEgYnVuY2ggb2YgdXNlZnVsIHZhbHVlcyB3ZSdsbCBuZWVkIGluIHRoZSBmcmFnbWVudAovLyBzaGFkZXIuCglzaW5hbmdsZSA9IHNpbih2ZWMyKHhfdGlsdCwgeV90aWx0KSkgKyB2ZWMyKDAuMDAxKTsvL3Npbih2ZWMyKG1heChhYnMoeF90aWx0KSwgMWUtMyksIG1heChhYnMoeV90aWx0KSwgMWUtMykpKTsKCWNvc2FuZ2xlID0gY29zKHZlYzIoeF90aWx0LCB5X3RpbHQpKSArIHZlYzIoMC4wMDEpOy8vY29zKHZlYzIobWF4KGFicyh4X3RpbHQpLCAxZS0zKSwgbWF4KGFicyh5X3RpbHQpLCAxZS0zKSkpOwoJc3RyZXRjaCA9IG1heHNjYWxlKCk7CgoJaWxmYWMgPSB2ZWMyKDEuMCxjbGFtcChmbG9vcihJbnB1dFNpemUueS8yMDAuMCksIDEuMCwgMi4wKSk7CgovLyBUaGUgc2l6ZSBvZiBvbmUgdGV4ZWwsIGluIHRleHR1cmUtY29vcmRpbmF0ZXMuCgl2ZWMyIHNoYXJwVGV4dHVyZVNpemUgPSB2ZWMyKFNIQVJQRVIgKiBUZXh0dXJlU2l6ZS54LCBUZXh0dXJlU2l6ZS55KTsKCW9uZSA9IGlsZmFjIC8gc2hhcnBUZXh0dXJlU2l6ZTsKCi8vIFJlc3VsdGluZyBYIHBpeGVsLWNvb3JkaW5hdGUgb2YgdGhlIHBpeGVsIHdlJ3JlIGRyYXdpbmcuCgltb2RfZmFjdG9yID0gVGV4Q29vcmQueCAqIFRleHR1cmVTaXplLnggKiBPdXRwdXRTaXplLnggLyBJbnB1dFNpemUueDsKCn0KCiNlbGlmIGRlZmluZWQoRlJBR01FTlQpCgojaWYgX19WRVJTSU9OX18gPj0gMTMwCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgaW4KI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlCm91dCB2ZWM0IEZyYWdDb2xvcjsKI2Vsc2UKI2RlZmluZSBDT01QQVRfVkFSWUlORyB2YXJ5aW5nCiNkZWZpbmUgRnJhZ0NvbG9yIGdsX0ZyYWdDb2xvcgojZGVmaW5lIENPTVBBVF9URVhUVVJFIHRleHR1cmUyRAojZW5kaWYKCiNpZmRlZiBHTF9FUwojaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gKcHJlY2lzaW9uIGhpZ2hwIGZsb2F0OwojZWxzZQpwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKI2VuZGlmCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTiBtZWRpdW1wCiNlbHNlCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTgojZW5kaWYKCnN0cnVjdCBvdXRwdXRfZHVtbXkgewogICAgdmVjNCBfY29sb3I7Cn07Cgp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lRGlyZWN0aW9uOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lQ291bnQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIE91dHB1dFNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIFRleHR1cmVTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBJbnB1dFNpemU7CnVuaWZvcm0gc2FtcGxlcjJEIFRleHR1cmU7CkNPTVBBVF9WQVJZSU5HIHZlYzQgVEVYMDsKCi8vIENvbW1lbnQgdGhlIG5leHQgbGluZSB0byBkaXNhYmxlIGludGVycG9sYXRpb24gaW4gbGluZWFyIGdhbW1hIChhbmQKLy8gZ2FpbiBzcGVlZCkuCgkjZGVmaW5lIExJTkVBUl9QUk9DRVNTSU5HCgovLyBFbmFibGUgc2NyZWVuIGN1cnZhdHVyZS4KLy8gICAgICAgICNkZWZpbmUgQ1VSVkFUVVJFCgovLyBFbmFibGUgM3ggb3ZlcnNhbXBsaW5nIG9mIHRoZSBiZWFtIHByb2ZpbGUKICAgICAgICAjZGVmaW5lIE9WRVJTQU1QTEUKCi8vIFVzZSB0aGUgb2xkZXIsIHB1cmVseSBnYXVzc2lhbiBiZWFtIHByb2ZpbGUKICAgICAgICAvLyNkZWZpbmUgVVNFR0FVU1NJQU4KCi8vIE1hY3Jvcy4KI2RlZmluZSBGSVgoYykgbWF4KGFicyhjKSwgMWUtNSk7CiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODkKCiNpZmRlZiBMSU5FQVJfUFJPQ0VTU0lORwojICAgICAgIGRlZmluZSBURVgyRChjKSBwb3coQ09NUEFUX1RFWFRVUkUoVGV4dHVyZSwgKGMpKSwgdmVjNChDUlRnYW1tYSkpCiNlbHNlCiMgICAgICAgZGVmaW5lIFRFWDJEKGMpIENPTVBBVF9URVhUVVJFKFRleHR1cmUsIChjKSkKI2VuZGlmCgpDT01QQVRfVkFSWUlORyB2ZWMyIG9uZTsKQ09NUEFUX1ZBUllJTkcgZmxvYXQgbW9kX2ZhY3RvcjsKQ09NUEFUX1ZBUllJTkcgdmVjMiBpbGZhYzsKQ09NUEFUX1ZBUllJTkcgdmVjMiBvdmVyc2NhbjsKQ09NUEFUX1ZBUllJTkcgdmVjMiBhc3BlY3Q7CkNPTVBBVF9WQVJZSU5HIHZlYzMgc3RyZXRjaDsKQ09NUEFUX1ZBUllJTkcgdmVjMiBzaW5hbmdsZTsKQ09NUEFUX1ZBUllJTkcgdmVjMiBjb3NhbmdsZTsKCiNpZmRlZiBQQVJBTUVURVJfVU5JRk9STQp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgQ1JUZ2FtbWE7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBtb25pdG9yZ2FtbWE7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBkOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgQ1VSVkFUVVJFOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgUjsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IGNvcm5lcnNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBjb3JuZXJzbW9vdGg7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCB4X3RpbHQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCB5X3RpbHQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBvdmVyc2Nhbl94Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgb3ZlcnNjYW5feTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IERPVE1BU0s7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBTSEFSUEVSOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgc2NhbmxpbmVfd2VpZ2h0Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgbHVtOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgaW50ZXJsYWNlX2RldGVjdDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IFNBVFVSQVRJT047CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBJTlY7CiNlbmRpZgoKZmxvYXQgaW50ZXJzZWN0KHZlYzIgeHkpCiAgICAgICAgewoJZmxvYXQgQSA9IGRvdCh4eSx4eSkrZCpkOwoJZmxvYXQgQiA9IDIuMCooUiooZG90KHh5LHNpbmFuZ2xlKS1kKmNvc2FuZ2xlLngqY29zYW5nbGUueSktZCpkKTsKCWZsb2F0IEMgPSBkKmQgKyAyLjAqUipkKmNvc2FuZ2xlLngqY29zYW5nbGUueTsKCXJldHVybiAoLUItc3FydChCKkItNC4wKkEqQykpLygyLjAqQSk7CiAgICAgICAgfQoKdmVjMiBia3d0cmFucyh2ZWMyIHh5KQogICAgICAgIHsKCWZsb2F0IGMgPSBpbnRlcnNlY3QoeHkpOwoJdmVjMiBwb2ludCA9IHZlYzIoYykqeHk7Cglwb2ludCAtPSB2ZWMyKC1SKSpzaW5hbmdsZTsKCXBvaW50IC89IHZlYzIoUik7Cgl2ZWMyIHRhbmcgPSBzaW5hbmdsZS9jb3NhbmdsZTsKCXZlYzIgcG9jID0gcG9pbnQvY29zYW5nbGU7CglmbG9hdCBBID0gZG90KHRhbmcsdGFuZykrMS4wOwoJZmxvYXQgQiA9IC0yLjAqZG90KHBvYyx0YW5nKTsKCWZsb2F0IEMgPSBkb3QocG9jLHBvYyktMS4wOwoJZmxvYXQgYSA9ICgtQitzcXJ0KEIqQi00LjAqQSpDKSkvKDIuMCpBKTsKCXZlYzIgdXYgPSAocG9pbnQtYSpzaW5hbmdsZSkvY29zYW5nbGU7CglmbG9hdCByID0gRklYKFIqYWNvcyhhKSk7CglyZXR1cm4gdXYqci9zaW4oci9SKTsKICAgICAgICB9Cgp2ZWMyIHRyYW5zZm9ybSh2ZWMyIGNvb3JkKQogICAgICAgIHsKCWNvb3JkICo9IFRleHR1cmVTaXplIC8gSW5wdXRTaXplOwoJY29vcmQgPSAoY29vcmQtdmVjMigwLjUpKSphc3BlY3Qqc3RyZXRjaC56K3N0cmV0Y2gueHk7CglyZXR1cm4gKGJrd3RyYW5zKGNvb3JkKS92ZWMyKG92ZXJzY2FuX3ggLyAxMDAuMCwgb3ZlcnNjYW5feSAvIDEwMC4wKS9hc3BlY3QrdmVjMigwLjUpKSAqIElucHV0U2l6ZSAvIFRleHR1cmVTaXplOwogICAgICAgIH0KCmZsb2F0IGNvcm5lcih2ZWMyIGNvb3JkKQogICAgICAgIHsKCWNvb3JkICo9IFRleHR1cmVTaXplIC8gSW5wdXRTaXplOwoJY29vcmQgPSAoY29vcmQgLSB2ZWMyKDAuNSkpICogdmVjMihvdmVyc2Nhbl94IC8gMTAwLjAsIG92ZXJzY2FuX3kgLyAxMDAuMCkgKyB2ZWMyKDAuNSk7Cgljb29yZCA9IG1pbihjb29yZCwgdmVjMigxLjApLWNvb3JkKSAqIGFzcGVjdDsKCXZlYzIgY2Rpc3QgPSB2ZWMyKGNvcm5lcnNpemUpOwoJY29vcmQgPSAoY2Rpc3QgLSBtaW4oY29vcmQsY2Rpc3QpKTsKCWZsb2F0IGRpc3QgPSBzcXJ0KGRvdChjb29yZCxjb29yZCkpOwoJcmV0dXJuIGNsYW1wKChjZGlzdC54LWRpc3QpKmNvcm5lcnNtb290aCwwLjAsIDEuMCkqMS4wMDAxOwogICAgICAgIH0KCi8vIENhbGN1bGF0ZSB0aGUgaW5mbHVlbmNlIG9mIGEgc2NhbmxpbmUgb24gdGhlIGN1cnJlbnQgcGl4ZWwuCi8vCi8vICdkaXN0YW5jZScgaXMgdGhlIGRpc3RhbmNlIGluIHRleHR1cmUgY29vcmRpbmF0ZXMgZnJvbSB0aGUgY3VycmVudAovLyBwaXhlbCB0byB0aGUgc2NhbmxpbmUgaW4gcXVlc3Rpb24uCi8vICdjb2xvcicgaXMgdGhlIGNvbG91ciBvZiB0aGUgc2NhbmxpbmUgYXQgdGhlIGhvcml6b250YWwgbG9jYXRpb24gb2YKLy8gdGhlIGN1cnJlbnQgcGl4ZWwuCnZlYzQgc2NhbmxpbmVXZWlnaHRzKGZsb2F0IGRpc3RhbmNlLCB2ZWM0IGNvbG9yKQogICAgICAgIHsKCS8vICJ3aWQiIGNvbnRyb2xzIHRoZSB3aWR0aCBvZiB0aGUgc2NhbmxpbmUgYmVhbSwgZm9yIGVhY2ggUkdCCgkvLyBjaGFubmVsIFRoZSAid2VpZ2h0cyIgbGluZXMgYmFzaWNhbGx5IHNwZWNpZnkgdGhlIGZvcm11bGEKCS8vIHRoYXQgZ2l2ZXMgeW91IHRoZSBwcm9maWxlIG9mIHRoZSBiZWFtLCBpLmUuIHRoZSBpbnRlbnNpdHkgYXMKCS8vIGEgZnVuY3Rpb24gb2YgZGlzdGFuY2UgZnJvbSB0aGUgdmVydGljYWwgY2VudGVyIG9mIHRoZQoJLy8gc2NhbmxpbmUuIEluIHRoaXMgY2FzZSwgaXQgaXMgZ2F1c3NpYW4gaWYgd2lkdGg9MiwgYW5kCgkvLyBiZWNvbWVzIG5vbmdhdXNzaWFuIGZvciBsYXJnZXIgd2lkdGhzLiBJZGVhbGx5IHRoaXMgc2hvdWxkCgkvLyBiZSBub3JtYWxpemVkIHNvIHRoYXQgdGhlIGludGVncmFsIGFjcm9zcyB0aGUgYmVhbSBpcwoJLy8gaW5kZXBlbmRlbnQgb2YgaXRzIHdpZHRoLiBUaGF0IGlzLCBmb3IgYSBuYXJyb3dlciBiZWFtCgkvLyAid2VpZ2h0cyIgc2hvdWxkIGhhdmUgYSBoaWdoZXIgcGVhayBhdCB0aGUgY2VudGVyIG9mIHRoZQoJLy8gc2NhbmxpbmUgdGhhbiBmb3IgYSB3aWRlciBiZWFtLgojaWZkZWYgVVNFR0FVU1NJQU4KCXZlYzQgd2lkID0gMC4zICsgMC4xICogcG93KGNvbG9yLCB2ZWM0KDMuMCkpOwoJdmVjNCB3ZWlnaHRzID0gdmVjNChkaXN0YW5jZSAvIHdpZCk7CglyZXR1cm4gKGx1bSArIDAuNCkgKiBleHAoLXdlaWdodHMgKiB3ZWlnaHRzKSAvIHdpZDsKI2Vsc2UKCXZlYzQgd2lkID0gMi4wICsgMi4wICogcG93KGNvbG9yLCB2ZWM0KDQuMCkpOwoJdmVjNCB3ZWlnaHRzID0gdmVjNChkaXN0YW5jZSAvIHNjYW5saW5lX3dlaWdodCk7CglyZXR1cm4gKGx1bSArIDEuNCkgKiBleHAoLXBvdyh3ZWlnaHRzICogaW52ZXJzZXNxcnQoMC41ICogd2lkKSwgd2lkKSkgLyAoMC42ICsgMC4yICogd2lkKTsKI2VuZGlmCiAgICAgICAgfQoKdmVjMyBzYXR1cmF0aW9uICh2ZWMzIHRleHR1cmVDb2xvcikKewogICAgZmxvYXQgbHVtPWxlbmd0aCh0ZXh0dXJlQ29sb3IpKjAuNTc3NTsKCiAgICB2ZWMzIGx1bWluYW5jZVdlaWdodGluZyA9IHZlYzMoMC4zLDAuNiwwLjEpOwogICAgaWYgKGx1bTwwLjUpIGx1bWluYW5jZVdlaWdodGluZy5yZ2I9KGx1bWluYW5jZVdlaWdodGluZy5yZ2IqbHVtaW5hbmNlV2VpZ2h0aW5nLnJnYikrKGx1bWluYW5jZVdlaWdodGluZy5yZ2IqbHVtaW5hbmNlV2VpZ2h0aW5nLnJnYik7CgogICAgZmxvYXQgbHVtaW5hbmNlID0gZG90KHRleHR1cmVDb2xvciwgbHVtaW5hbmNlV2VpZ2h0aW5nKTsKICAgIHZlYzMgZ3JleVNjYWxlQ29sb3IgPSB2ZWMzKGx1bWluYW5jZSk7CgogICAgdmVjMyByZXMgPSB2ZWMzKG1peChncmV5U2NhbGVDb2xvciwgdGV4dHVyZUNvbG9yLCBTQVRVUkFUSU9OKSk7CiAgICByZXR1cm4gcmVzOwp9CgojZGVmaW5lIHB3ciB2ZWMzKDEuMC8oKC0wLjcqKDEuMC1zY2FubGluZV93ZWlnaHQpKzEuMCkqKC0wLjUqRE9UTUFTSysxLjApKS0xLjI1KQoKCi8vIFJldHVybnMgZ2FtbWEgY29ycmVjdGVkIG91dHB1dCwgY29tcGVuc2F0ZWQgZm9yIHNjYW5saW5lK21hc2sgZW1iZWRkZWQgZ2FtbWEKdmVjMyBpbnZfZ2FtbWEodmVjMyBjb2wsIHZlYzMgcG93ZXIpCnsKICAgIHZlYzMgY2lyICA9IGNvbC0xLjA7CiAgICAgICAgIGNpciAqPSBjaXI7CiAgICAgICAgIGNvbCAgPSBtaXgoc3FydChjb2wpLHNxcnQoMS4wLWNpcikscG93ZXIpOwogICAgcmV0dXJuIGNvbDsKfQoKdm9pZCBtYWluKCkKewovLyBIZXJlJ3MgYSBoZWxwZnVsIGRpYWdyYW0gdG8ga2VlcCBpbiBtaW5kIHdoaWxlIHRyeWluZyB0bwovLyB1bmRlcnN0YW5kIHRoZSBjb2RlOgovLwovLyAgfCAgICAgIHwgICAgICB8ICAgICAgfCAgICAgIHwKLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQovLyAgfCAgICAgIHwgICAgICB8ICAgICAgfCAgICAgIHwKLy8gIHwgIDAxICB8ICAxMSAgfCAgMjEgIHwgIDMxICB8IDwtLSBjdXJyZW50IHNjYW5saW5lCi8vICB8ICAgICAgfCBAICAgIHwgICAgICB8ICAgICAgfAovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi8vICB8ICAgICAgfCAgICAgIHwgICAgICB8ICAgICAgfAovLyAgfCAgMDIgIHwgIDEyICB8ICAyMiAgfCAgMzIgIHwgPC0tIG5leHQgc2NhbmxpbmUKLy8gIHwgICAgICB8ICAgICAgfCAgICAgIHwgICAgICB8Ci8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KLy8gIHwgICAgICB8ICAgICAgfCAgICAgIHwgICAgICB8Ci8vCi8vIEVhY2ggY2hhcmFjdGVyLWNlbGwgcmVwcmVzZW50cyBhIHBpeGVsIG9uIHRoZSBvdXRwdXQKLy8gc3VyZmFjZSwgIkAiIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgcGl4ZWwgKGFsd2F5cyBzb21ld2hlcmUKLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIHRoZSBjdXJyZW50IHNjYW4tbGluZSwgb3IgdGhlIHRvcC1oYWxmCi8vIG9mIHRoZSBuZXh0IHNjYW5saW5lKS4gVGhlIGdyaWQgb2YgbGluZXMgcmVwcmVzZW50cyB0aGUKLy8gZWRnZXMgb2YgdGhlIHRleGVscyBvZiB0aGUgdW5kZXJseWluZyB0ZXh0dXJlLgoKLy8gVGV4dHVyZSBjb29yZGluYXRlcyBvZiB0aGUgdGV4ZWwgY29udGFpbmluZyB0aGUgYWN0aXZlIHBpeGVsLgoJdmVjMiB4eSA9IChDVVJWQVRVUkUgPiAwLjUpID8gdHJhbnNmb3JtKFRFWDAueHkpIDogVEVYMC54eTsKCglmbG9hdCBjdmFsID0gY29ybmVyKHh5KTsKCi8vIE9mIGFsbCB0aGUgcGl4ZWxzIHRoYXQgYXJlIG1hcHBlZCBvbnRvIHRoZSB0ZXhlbCB3ZSBhcmUKLy8gY3VycmVudGx5IHJlbmRlcmluZywgd2hpY2ggcGl4ZWwgYXJlIHdlIGN1cnJlbnRseSByZW5kZXJpbmc/Cgl2ZWMyIGlsdmVjID0gdmVjMigwLjAsaWxmYWMueSAqIGludGVybGFjZV9kZXRlY3QgPiAxLjUgPyBtb2QoZmxvYXQoRnJhbWVDb3VudCksMi4wKSA6IDAuMCk7Cgl2ZWMyIHJhdGlvX3NjYWxlID0gKHh5ICogVGV4dHVyZVNpemUgLSB2ZWMyKDAuNSkgKyBpbHZlYykvaWxmYWM7CiNpZmRlZiBPVkVSU0FNUExFCglmbG9hdCBmaWx0ZXJfID0gSW5wdXRTaXplLnkvT3V0cHV0U2l6ZS55Oy8vZndpZHRoKHJhdGlvX3NjYWxlLnkpOwojZW5kaWYKCXZlYzIgdXZfcmF0aW8gPSBmcmFjdChyYXRpb19zY2FsZSk7CgovLyBTbmFwIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHVuZGVybHlpbmcgdGV4ZWwuCgl4eSA9IChmbG9vcihyYXRpb19zY2FsZSkqaWxmYWMgKyB2ZWMyKDAuNSkgLSBpbHZlYykgLyBUZXh0dXJlU2l6ZTsKCi8vIENhbGN1bGF0ZSBMYW5jem9zIHNjYWxpbmcgY29lZmZpY2llbnRzIGRlc2NyaWJpbmcgdGhlIGVmZmVjdAovLyBvZiB2YXJpb3VzIG5laWdoYm91ciB0ZXhlbHMgaW4gYSBzY2FubGluZSBvbiB0aGUgY3VycmVudAovLyBwaXhlbC4KCXZlYzQgY29lZmZzID0gUEkgKiB2ZWM0KDEuMCArIHV2X3JhdGlvLngsIHV2X3JhdGlvLngsIDEuMCAtIHV2X3JhdGlvLngsIDIuMCAtIHV2X3JhdGlvLngpOwoKLy8gUHJldmVudCBkaXZpc2lvbiBieSB6ZXJvLgoJY29lZmZzID0gRklYKGNvZWZmcyk7CgovLyBMYW5jem9zMiBrZXJuZWwuCgljb2VmZnMgPSAyLjAgKiBzaW4oY29lZmZzKSAqIHNpbihjb2VmZnMgLyAyLjApIC8gKGNvZWZmcyAqIGNvZWZmcyk7CgovLyBOb3JtYWxpemUuCgljb2VmZnMgLz0gZG90KGNvZWZmcywgdmVjNCgxLjApKTsKCi8vIENhbGN1bGF0ZSB0aGUgZWZmZWN0aXZlIGNvbG91ciBvZiB0aGUgY3VycmVudCBhbmQgbmV4dAovLyBzY2FubGluZXMgYXQgdGhlIGhvcml6b250YWwgbG9jYXRpb24gb2YgdGhlIGN1cnJlbnQgcGl4ZWwsCi8vIHVzaW5nIHRoZSBMYW5jem9zIGNvZWZmaWNpZW50cyBhYm92ZS4KCXZlYzQgY29sICA9IGNsYW1wKG1hdDQoCiAgICAgICAgICAgICAgICAgICAgICAgIFRFWDJEKHh5ICsgdmVjMigtb25lLngsIDAuMCkpLAogICAgICAgICAgICAgICAgICAgICAgICBURVgyRCh4eSksCiAgICAgICAgICAgICAgICAgICAgICAgIFRFWDJEKHh5ICsgdmVjMihvbmUueCwgMC4wKSksCiAgICAgICAgICAgICAgICAgICAgICAgIFRFWDJEKHh5ICsgdmVjMigyLjAgKiBvbmUueCwgMC4wKSkpICogY29lZmZzLAogICAgICAgICAgICAgICAgICAgICAgICAwLjAsIDEuMCk7CiAgICAgICAgdmVjNCBjb2wyID0gY2xhbXAobWF0NCgKICAgICAgICAgICAgICAgICAgICAgICAgVEVYMkQoeHkgKyB2ZWMyKC1vbmUueCwgb25lLnkpKSwKICAgICAgICAgICAgICAgICAgICAgICAgVEVYMkQoeHkgKyB2ZWMyKDAuMCwgb25lLnkpKSwKICAgICAgICAgICAgICAgICAgICAgICAgVEVYMkQoeHkgKyBvbmUpLAogICAgICAgICAgICAgICAgICAgICAgICBURVgyRCh4eSArIHZlYzIoMi4wICogb25lLngsIG9uZS55KSkpICogY29lZmZzLAogICAgICAgICAgICAgICAgICAgICAgICAwLjAsIDEuMCk7CgojaWZuZGVmIExJTkVBUl9QUk9DRVNTSU5HCgljb2wgID0gcG93KGNvbCAsIHZlYzQoQ1JUZ2FtbWEpKTsKCWNvbDIgPSBwb3coY29sMiwgdmVjNChDUlRnYW1tYSkpOwojZW5kaWYKCi8vIENhbGN1bGF0ZSB0aGUgaW5mbHVlbmNlIG9mIHRoZSBjdXJyZW50IGFuZCBuZXh0IHNjYW5saW5lcyBvbgovLyB0aGUgY3VycmVudCBwaXhlbC4KCXZlYzQgd2VpZ2h0cyAgPSBzY2FubGluZVdlaWdodHModXZfcmF0aW8ueSwgY29sKTsKCXZlYzQgd2VpZ2h0czIgPSBzY2FubGluZVdlaWdodHMoMS4wIC0gdXZfcmF0aW8ueSwgY29sMik7CiNpZmRlZiBPVkVSU0FNUExFCgl1dl9yYXRpby55ID11dl9yYXRpby55KzEuMC8zLjAqZmlsdGVyXzsKCXdlaWdodHMgPSAod2VpZ2h0cytzY2FubGluZVdlaWdodHModXZfcmF0aW8ueSwgY29sKSkvMy4wOwoJd2VpZ2h0czI9KHdlaWdodHMyK3NjYW5saW5lV2VpZ2h0cyhhYnMoMS4wLXV2X3JhdGlvLnkpLCBjb2wyKSkvMy4wOwoJdXZfcmF0aW8ueSA9dXZfcmF0aW8ueS0yLjAvMy4wKmZpbHRlcl87Cgl3ZWlnaHRzPXdlaWdodHMrc2NhbmxpbmVXZWlnaHRzKGFicyh1dl9yYXRpby55KSwgY29sKS8zLjA7Cgl3ZWlnaHRzMj13ZWlnaHRzMitzY2FubGluZVdlaWdodHMoYWJzKDEuMC11dl9yYXRpby55KSwgY29sMikvMy4wOwojZW5kaWYKCgl2ZWMzIG11bF9yZXMgID0gKGNvbCAqIHdlaWdodHMgKyBjb2wyICogd2VpZ2h0czIpLnJnYiAqIHZlYzMoY3ZhbCk7CgovLyBkb3QtbWFzayBlbXVsYXRpb246Ci8vIE91dHB1dCBwaXhlbHMgYXJlIGFsdGVybmF0ZWx5IHRpbnRlZCBncmVlbiBhbmQgbWFnZW50YS4KdmVjMyBkb3RNYXNrV2VpZ2h0cyA9IG1peCgKCXZlYzMoMS4wLCAxLjAgLSBET1RNQVNLLCAxLjApLAoJdmVjMygxLjAgLSBET1RNQVNLLCAxLjAsIDEuMCAtIERPVE1BU0spLAoJZmxvb3IobW9kKG1vZF9mYWN0b3IsIDIuMCkpCiAgICAgICAgKTsKCgltdWxfcmVzICo9IGRvdE1hc2tXZWlnaHRzOwoKLy8gQ29udmVydCB0aGUgaW1hZ2UgZ2FtbWEgZm9yIGRpc3BsYXkgb24gb3VyIG91dHB1dCBkZXZpY2UuCmlmIChJTlYgPT0gMS4wKXsgbXVsX3JlcyA9IGludl9nYW1tYShtdWxfcmVzLHB3cik7fSAKCWVsc2UgbXVsX3JlcyA9IHBvdyhtdWxfcmVzLCB2ZWMzKDEuMC9tb25pdG9yZ2FtbWEpKTsKICAgICAgICAKICAgICAgICBtdWxfcmVzID0gc2F0dXJhdGlvbihtdWxfcmVzKTsKCgoKLy8gQ29sb3IgdGhlIHRleGVsLgogICAgb3V0cHV0X2R1bW15IF9PVVQ7CiAgICBfT1VULl9jb2xvciA9IHZlYzQobXVsX3JlcywgMS4wKTsKICAgIEZyYWdDb2xvciA9IF9PVVQuX2NvbG9yOwogICAgcmV0dXJuOwp9IAojZW5kaWYK",
            },
        ],
    },

    //https://github.com/libretro/glsl-shaders/blob/master/crt/crt-mattias.glslp
    "crt-mattias.glslp": {
        "shader": {
            "type": "text",
            "value": "shaders = 1\n\nshader0 = crt-mattias.glsl\nfilter_linear0 = false",
        },
        "resources": [
            {
                "name": "crt-mattias.glsl",
                "type": "base64",
                "value": "Ly8gQ1JUIEVtdWxhdGlvbgovLyBieSBNYXR0aWFzCi8vIGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9sc0IzRFYKCiNwcmFnbWEgcGFyYW1ldGVyIENVUlZBVFVSRSAiQ3VydmF0dXJlIiAwLjUgMC4wIDEuMCAwLjA1CiNwcmFnbWEgcGFyYW1ldGVyIFNDQU5TUEVFRCAiU2NhbmxpbmUgQ3Jhd2wgU3BlZWQiIDEuMCAwLjAgMTAuMCAwLjUKCiNpZiBkZWZpbmVkKFZFUlRFWCkKCiNpZiBfX1ZFUlNJT05fXyA+PSAxMzAKI2RlZmluZSBDT01QQVRfVkFSWUlORyBvdXQKI2RlZmluZSBDT01QQVRfQVRUUklCVVRFIGluCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZQojZWxzZQojZGVmaW5lIENPTVBBVF9WQVJZSU5HIHZhcnlpbmcgCiNkZWZpbmUgQ09NUEFUX0FUVFJJQlVURSBhdHRyaWJ1dGUgCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZTJECiNlbmRpZgoKI2lmZGVmIEdMX0VTCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTiBtZWRpdW1wCiNlbHNlCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTgojZW5kaWYKCkNPTVBBVF9BVFRSSUJVVEUgdmVjNCBWZXJ0ZXhDb29yZDsKQ09NUEFUX0FUVFJJQlVURSB2ZWM0IENPTE9SOwpDT01QQVRfQVRUUklCVVRFIHZlYzQgVGV4Q29vcmQ7CkNPTVBBVF9WQVJZSU5HIHZlYzQgQ09MMDsKQ09NUEFUX1ZBUllJTkcgdmVjNCBURVgwOwovLyBvdXQgdmFyaWFibGVzIGdvIGhlcmUgYXMgQ09NUEFUX1ZBUllJTkcgd2hhdGV2ZXIKCnZlYzQgX29Qb3NpdGlvbjE7IAp1bmlmb3JtIG1hdDQgTVZQTWF0cml4Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lRGlyZWN0aW9uOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lQ291bnQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIE91dHB1dFNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIFRleHR1cmVTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBJbnB1dFNpemU7CgovLyBjb21wYXRpYmlsaXR5ICNkZWZpbmVzCiNkZWZpbmUgdlRleENvb3JkIFRFWDAueHkKI2RlZmluZSBTb3VyY2VTaXplIHZlYzQoVGV4dHVyZVNpemUsIDEuMCAvIFRleHR1cmVTaXplKSAvL2VpdGhlciBUZXh0dXJlU2l6ZSBvciBJbnB1dFNpemUKI2RlZmluZSBPdXRTaXplIHZlYzQoT3V0cHV0U2l6ZSwgMS4wIC8gT3V0cHV0U2l6ZSkKCnZvaWQgbWFpbigpCnsKICAgIGdsX1Bvc2l0aW9uID0gTVZQTWF0cml4ICogVmVydGV4Q29vcmQ7CiAgICBURVgwLnh5ID0gVGV4Q29vcmQueHk7Cn0KCiNlbGlmIGRlZmluZWQoRlJBR01FTlQpCgojaWZkZWYgR0xfRVMKI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdICnByZWNpc2lvbiBoaWdocCBmbG9hdDsKI2Vsc2UKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CiNlbmRpZgojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04gbWVkaXVtcAojZWxzZQojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04KI2VuZGlmCgojaWYgX19WRVJTSU9OX18gPj0gMTMwCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgaW4KI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlCm91dCBDT01QQVRfUFJFQ0lTSU9OIHZlYzQgRnJhZ0NvbG9yOwojZWxzZQojZGVmaW5lIENPTVBBVF9WQVJZSU5HIHZhcnlpbmcKI2RlZmluZSBGcmFnQ29sb3IgZ2xfRnJhZ0NvbG9yCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZTJECiNlbmRpZgoKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZURpcmVjdGlvbjsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZUNvdW50Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBPdXRwdXRTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBUZXh0dXJlU2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgSW5wdXRTaXplOwp1bmlmb3JtIHNhbXBsZXIyRCBUZXh0dXJlOwpDT01QQVRfVkFSWUlORyB2ZWM0IFRFWDA7CgovLyBjb21wYXRpYmlsaXR5ICNkZWZpbmVzCiNkZWZpbmUgU291cmNlIFRleHR1cmUKI2RlZmluZSB2VGV4Q29vcmQgVEVYMC54eQoKI2RlZmluZSBTb3VyY2VTaXplIHZlYzQoVGV4dHVyZVNpemUsIDEuMCAvIFRleHR1cmVTaXplKSAvL2VpdGhlciBUZXh0dXJlU2l6ZSBvciBJbnB1dFNpemUKI2RlZmluZSBPdXRTaXplIHZlYzQoT3V0cHV0U2l6ZSwgMS4wIC8gT3V0cHV0U2l6ZSkKCiNpZmRlZiBQQVJBTUVURVJfVU5JRk9STQp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgQ1VSVkFUVVJFLCBTQ0FOU1BFRUQ7CiNlbHNlCiNkZWZpbmUgQ1VSVkFUVVJFIDAuNQojZGVmaW5lIFNDQU5TUEVFRCAxLjAKI2VuZGlmCgojZGVmaW5lIGlDaGFubmVsMCBUZXh0dXJlCiNkZWZpbmUgaVRpbWUgKGZsb2F0KEZyYW1lQ291bnQpIC8gNjAuMCkKI2RlZmluZSBpUmVzb2x1dGlvbiBPdXRwdXRTaXplLnh5CiNkZWZpbmUgZnJhZ0Nvb3JkIGdsX0ZyYWdDb29yZC54eQoKdmVjMyBzYW1wbGVfKCBzYW1wbGVyMkQgdGV4LCB2ZWMyIHRjICkKewoJdmVjMyBzID0gcG93KENPTVBBVF9URVhUVVJFKHRleCx0YykucmdiLCB2ZWMzKDIuMikpOwoJcmV0dXJuIHM7Cn0KCnZlYzMgYmx1cihzYW1wbGVyMkQgdGV4LCB2ZWMyIHRjLCBmbG9hdCBvZmZzKQp7Cgl2ZWM0IHhvZmZzID0gb2ZmcyAqIHZlYzQoLTIuMCwgLTEuMCwgMS4wLCAyLjApIC8gKGlSZXNvbHV0aW9uLnggKiBUZXh0dXJlU2l6ZS54IC8gSW5wdXRTaXplLngpOwoJdmVjNCB5b2ZmcyA9IG9mZnMgKiB2ZWM0KC0yLjAsIC0xLjAsIDEuMCwgMi4wKSAvIChpUmVzb2x1dGlvbi55ICogVGV4dHVyZVNpemUueSAvIElucHV0U2l6ZS55KTsKICAgdGMgPSB0YyAqIElucHV0U2l6ZSAvIFRleHR1cmVTaXplOwoJCgl2ZWMzIGNvbG9yID0gdmVjMygwLjAsIDAuMCwgMC4wKTsKCWNvbG9yICs9IHNhbXBsZV8odGV4LHRjICsgdmVjMih4b2Zmcy54LCB5b2Zmcy54KSkgKiAwLjAwMzY2OwoJY29sb3IgKz0gc2FtcGxlXyh0ZXgsdGMgKyB2ZWMyKHhvZmZzLnksIHlvZmZzLngpKSAqIDAuMDE0NjU7Cgljb2xvciArPSBzYW1wbGVfKHRleCx0YyArIHZlYzIoICAgIDAuMCwgeW9mZnMueCkpICogMC4wMjU2NDsKCWNvbG9yICs9IHNhbXBsZV8odGV4LHRjICsgdmVjMih4b2Zmcy56LCB5b2Zmcy54KSkgKiAwLjAxNDY1OwoJY29sb3IgKz0gc2FtcGxlXyh0ZXgsdGMgKyB2ZWMyKHhvZmZzLncsIHlvZmZzLngpKSAqIDAuMDAzNjY7CgkKCWNvbG9yICs9IHNhbXBsZV8odGV4LHRjICsgdmVjMih4b2Zmcy54LCB5b2Zmcy55KSkgKiAwLjAxNDY1OwoJY29sb3IgKz0gc2FtcGxlXyh0ZXgsdGMgKyB2ZWMyKHhvZmZzLnksIHlvZmZzLnkpKSAqIDAuMDU4NjE7Cgljb2xvciArPSBzYW1wbGVfKHRleCx0YyArIHZlYzIoICAgIDAuMCwgeW9mZnMueSkpICogMC4wOTUyNDsKCWNvbG9yICs9IHNhbXBsZV8odGV4LHRjICsgdmVjMih4b2Zmcy56LCB5b2Zmcy55KSkgKiAwLjA1ODYxOwoJY29sb3IgKz0gc2FtcGxlXyh0ZXgsdGMgKyB2ZWMyKHhvZmZzLncsIHlvZmZzLnkpKSAqIDAuMDE0NjU7CgkKCWNvbG9yICs9IHNhbXBsZV8odGV4LHRjICsgdmVjMih4b2Zmcy54LCAwLjApKSAqIDAuMDI1NjQ7Cgljb2xvciArPSBzYW1wbGVfKHRleCx0YyArIHZlYzIoeG9mZnMueSwgMC4wKSkgKiAwLjA5NTI0OwoJY29sb3IgKz0gc2FtcGxlXyh0ZXgsdGMgKyB2ZWMyKCAgICAwLjAsIDAuMCkpICogMC4xNTAxODsKCWNvbG9yICs9IHNhbXBsZV8odGV4LHRjICsgdmVjMih4b2Zmcy56LCAwLjApKSAqIDAuMDk1MjQ7Cgljb2xvciArPSBzYW1wbGVfKHRleCx0YyArIHZlYzIoeG9mZnMudywgMC4wKSkgKiAwLjAyNTY0OwoJCgljb2xvciArPSBzYW1wbGVfKHRleCx0YyArIHZlYzIoeG9mZnMueCwgeW9mZnMueikpICogMC4wMTQ2NTsKCWNvbG9yICs9IHNhbXBsZV8odGV4LHRjICsgdmVjMih4b2Zmcy55LCB5b2Zmcy56KSkgKiAwLjA1ODYxOwoJY29sb3IgKz0gc2FtcGxlXyh0ZXgsdGMgKyB2ZWMyKCAgICAwLjAsIHlvZmZzLnopKSAqIDAuMDk1MjQ7Cgljb2xvciArPSBzYW1wbGVfKHRleCx0YyArIHZlYzIoeG9mZnMueiwgeW9mZnMueikpICogMC4wNTg2MTsKCWNvbG9yICs9IHNhbXBsZV8odGV4LHRjICsgdmVjMih4b2Zmcy53LCB5b2Zmcy56KSkgKiAwLjAxNDY1OwoJCgljb2xvciArPSBzYW1wbGVfKHRleCx0YyArIHZlYzIoeG9mZnMueCwgeW9mZnMudykpICogMC4wMDM2NjsKCWNvbG9yICs9IHNhbXBsZV8odGV4LHRjICsgdmVjMih4b2Zmcy55LCB5b2Zmcy53KSkgKiAwLjAxNDY1OwoJY29sb3IgKz0gc2FtcGxlXyh0ZXgsdGMgKyB2ZWMyKCAgICAwLjAsIHlvZmZzLncpKSAqIDAuMDI1NjQ7Cgljb2xvciArPSBzYW1wbGVfKHRleCx0YyArIHZlYzIoeG9mZnMueiwgeW9mZnMudykpICogMC4wMTQ2NTsKCWNvbG9yICs9IHNhbXBsZV8odGV4LHRjICsgdmVjMih4b2Zmcy53LCB5b2Zmcy53KSkgKiAwLjAwMzY2OwoKCXJldHVybiBjb2xvcjsKfQoKLy9DYW5vbmljYWwgbm9pc2UgZnVuY3Rpb247IHJlcGxhY2VkIHRvIHByZXZlbnQgcHJlY2lzaW9uIGVycm9ycwovL2Zsb2F0IHJhbmQodmVjMiBjbyl7Ci8vICAgIHJldHVybiBmcmFjdChzaW4oZG90KGNvLnh5ICx2ZWMyKDEyLjk4OTgsNzguMjMzKSkpICogNDM3NTguNTQ1Myk7Ci8vfQoKZmxvYXQgcmFuZCh2ZWMyIGNvKQp7CiAgICBmbG9hdCBhID0gMTIuOTg5ODsKICAgIGZsb2F0IGIgPSA3OC4yMzM7CiAgICBmbG9hdCBjID0gNDM3NTguNTQ1MzsKICAgIGZsb2F0IGR0PSBkb3QoY28ueHkgLHZlYzIoYSxiKSk7CiAgICBmbG9hdCBzbj0gbW9kKGR0LDMuMTQpOwogICAgcmV0dXJuIGZyYWN0KHNpbihzbikgKiBjKTsKfQoKdmVjMiBjdXJ2ZSh2ZWMyIHV2KQp7Cgl1diA9ICh1diAtIDAuNSkgKiAyLjA7Cgl1diAqPSAxLjE7CQoJdXYueCAqPSAxLjAgKyBwb3coKGFicyh1di55KSAvIDUuMCksIDIuMCk7Cgl1di55ICo9IDEuMCArIHBvdygoYWJzKHV2LngpIC8gNC4wKSwgMi4wKTsKCXV2ICA9ICh1diAvIDIuMCkgKyAwLjU7Cgl1diA9ICB1diAqMC45MiArIDAuMDQ7CglyZXR1cm4gdXY7Cn0KCnZvaWQgbWFpbigpCnsKICAgIHZlYzIgcSA9ICh2VGV4Q29vcmQueHkgKiBUZXh0dXJlU2l6ZS54eSAvIElucHV0U2l6ZS54eSk7Ly9mcmFnQ29vcmQueHkgLyBpUmVzb2x1dGlvbi54eTsKICAgIHZlYzIgdXYgPSBxOwogICAgdXYgPSBtaXgoIHV2LCBjdXJ2ZSggdXYgKSwgQ1VSVkFUVVJFICkgKiBJbnB1dFNpemUueHkgLyBUZXh0dXJlU2l6ZS54eTsKICAgIHZlYzMgY29sOwoJZmxvYXQgeCA9ICBzaW4oMC4xKmlUaW1lK3V2LnkqMjEuMCkqc2luKDAuMjMqaVRpbWUrdXYueSoyOS4wKSpzaW4oMC4zKzAuMTEqaVRpbWUrdXYueSozMS4wKSowLjAwMTc7CglmbG9hdCBvID0yLjAqbW9kKGZyYWdDb29yZC55LDIuMCkvaVJlc29sdXRpb24ueDsKCXgrPW87CiAgIHV2ID0gdXYgKiBUZXh0dXJlU2l6ZSAvIElucHV0U2l6ZTsKICAgIGNvbC5yID0gMS4wKmJsdXIoaUNoYW5uZWwwLHZlYzIodXYueCswLjAwMDksdXYueSswLjAwMDkpLDEuMikueCswLjAwNTsKICAgIGNvbC5nID0gMS4wKmJsdXIoaUNoYW5uZWwwLHZlYzIodXYueCswLjAwMCx1di55LTAuMDAxNSksMS4yKS55KzAuMDA1OwogICAgY29sLmIgPSAxLjAqYmx1cihpQ2hhbm5lbDAsdmVjMih1di54LTAuMDAxNSx1di55KzAuMDAwKSwxLjIpLnorMC4wMDU7CiAgICBjb2wuciArPSAwLjIqYmx1cihpQ2hhbm5lbDAsdmVjMih1di54KzAuMDAwOSx1di55KzAuMDAwOSksMi4yNSkueC0wLjAwNTsKICAgIGNvbC5nICs9IDAuMipibHVyKGlDaGFubmVsMCx2ZWMyKHV2LngrMC4wMDAsdXYueS0wLjAwMTUpLDEuNzUpLnktMC4wMDU7CiAgICBjb2wuYiArPSAwLjIqYmx1cihpQ2hhbm5lbDAsdmVjMih1di54LTAuMDAxNSx1di55KzAuMDAwKSwxLjI1KS56LTAuMDA1OwogICAgZmxvYXQgZ2hzID0gMC4wNTsKCWNvbC5yICs9IGdocyooMS4wLTAuMjk5KSpibHVyKGlDaGFubmVsMCwwLjc1KnZlYzIoMC4wMSwgLTAuMDI3KSt2ZWMyKHV2LngrMC4wMDEsdXYueSswLjAwMSksNy4wKS54OwogICAgY29sLmcgKz0gZ2hzKigxLjAtMC41ODcpKmJsdXIoaUNoYW5uZWwwLDAuNzUqdmVjMigtMC4wMjIsIC0wLjAyKSt2ZWMyKHV2LngrMC4wMDAsdXYueS0wLjAwMiksNS4wKS55OwogICAgY29sLmIgKz0gZ2hzKigxLjAtMC4xMTQpKmJsdXIoaUNoYW5uZWwwLDAuNzUqdmVjMigtMC4wMiwgLTAuMCkrdmVjMih1di54LTAuMDAyLHV2LnkrMC4wMDApLDMuMCkuejsKICAgIAogICAgCgogICAgY29sID0gY2xhbXAoY29sKjAuNCswLjYqY29sKmNvbCoxLjAsMC4wLDEuMCk7CiAgICBmbG9hdCB2aWcgPSAoMC4wICsgMS4wKjE2LjAqdXYueCp1di55KigxLjAtdXYueCkqKDEuMC11di55KSk7Cgl2aWcgPSBwb3codmlnLDAuMyk7Cgljb2wgKj0gdmVjMyh2aWcpOwoKICAgIGNvbCAqPSB2ZWMzKDAuOTUsMS4wNSwwLjk1KTsKCWNvbCA9IG1peCggY29sLCBjb2wgKiBjb2wsIDAuMykgKiAzLjg7CgoJZmxvYXQgc2NhbnMgPSBjbGFtcCggMC4zNSswLjE1KnNpbigzLjUqKGlUaW1lICogU0NBTlNQRUVEKSt1di55KmlSZXNvbHV0aW9uLnkqMS41KSwgMC4wLCAxLjApOwoJCglmbG9hdCBzID0gcG93KHNjYW5zLDAuOSk7Cgljb2wgPSBjb2wqdmVjMyggcykgOwoKICAgIGNvbCAqPSAxLjArMC4wMDE1KnNpbigzMDAuMCppVGltZSk7CgkKCWNvbCo9MS4wLTAuMTUqdmVjMyhjbGFtcCgobW9kKGZyYWdDb29yZC54K28sIDIuMCktMS4wKSoyLjAsMC4wLDEuMCkpOwoJY29sICo9IHZlYzMoIDEuMCApIC0gMC4yNSp2ZWMzKCByYW5kKCB1diswLjAwMDEqaVRpbWUpLCAgcmFuZCggdXYrMC4wMDAxKmlUaW1lICsgMC4zICksICByYW5kKCB1diswLjAwMDEqaVRpbWUrIDAuNSApICApOwoJY29sID0gcG93KGNvbCwgdmVjMygwLjQ1KSk7CgoJaWYgKHV2LnggPCAwLjAgfHwgdXYueCA+IDEuMCkKCQljb2wgKj0gMC4wOwoJaWYgKHV2LnkgPCAwLjAgfHwgdXYueSA+IDEuMCkKCQljb2wgKj0gMC4wOwoJCgogICAgZmxvYXQgY29tcCA9IHNtb290aHN0ZXAoIDAuMSwgMC45LCBzaW4oaVRpbWUpICk7CgogICAgRnJhZ0NvbG9yID0gdmVjNChjb2wsMS4wKTsKfSAKI2VuZGlmCg==",
            },
        ],
    },

    //https://github.com/libretro/glsl-shaders/blob/master/crt/CRT-beam.glslp
    "crt-beam": {
        "shader": {
            "type": "text",
            "value": "shaders = \"1\"\nfeedback_pass = \"0\"\nshader0 = \"CRT-Beam.glsl\"\nfilter_linear0 = \"true\"\nwrap_mode0 = \"clamp_to_border\"\nmipmap_input0 = \"false\"\nalias0 = \"\"\nfloat_framebuffer0 = \"false\"\nsrgb_framebuffer0 = \"false\"\n\n",
        },
        "resources": [
            {
                "name": "CRT-Beam.glsl",
                "type": "base64",
                "value": "LyoKCWNydC1iZWFtCglmb3IgYmVzdCByZXN1bHRzIHVzZSBpbnRlZ2VyIHNjYWxlIDV4IG9yIG1vcmUKKi8KCiNwcmFnbWEgcGFyYW1ldGVyIGJsdXIgIkhvcml6b250YWwgQmx1ci9CZWFtIHNoYXBlIiAwLjYgMC4wIDEuMCAwLjEKI3ByYWdtYSBwYXJhbWV0ZXIgU2NhbmxpbmUgIlNjYW5saW5lIHRoaWNrbmVzcyIgMC4yIDAuMCAxLjAgMC4wNQojcHJhZ21hIHBhcmFtZXRlciB3ZWlnaHRyICJTY2FubGluZSBSZWQgYnJpZ2h0bmVzcyIgMC44IDAuMCAxLjAgMC4wNQojcHJhZ21hIHBhcmFtZXRlciB3ZWlnaHRnICJTY2FubGluZSBHcmVlbiBicmlnaHRuZXNzIiAwLjggMC4wIDEuMCAwLjA1CiNwcmFnbWEgcGFyYW1ldGVyIHdlaWdodGIgIlNjYW5saW5lIEJsdWUgYnJpZ2h0bmVzcyIgMC44IDAuMCAxLjAgMC4wNQojcHJhZ21hIHBhcmFtZXRlciBib2d1c19tc2sgIiBbIE1BU0tTIF0gIiAwLjAgMC4wIDAuMCAwLjAKI3ByYWdtYSBwYXJhbWV0ZXIgbWFzayAiTWFzayAwOkNHV0csMS0yOkxvdHRlcywzLTQgR3JheSw1LTY6Q0dXRyBzbG90LDcgVkdBIiAzLjAgLTEuMCA3LjAgMS4wCiNwcmFnbWEgcGFyYW1ldGVyIG1za19zaXplICJNYXNrIHNpemUiIDEuMCAxLjAgMi4wIDEuMAojcHJhZ21hIHBhcmFtZXRlciBzY2FsZSAiVkdBIE1hc2sgVmVydGljYWwgU2NhbGUiIDIuMCAyLjAwIDEwLjAwIDEuMAojcHJhZ21hIHBhcmFtZXRlciBNYXNrRGFyayAiTG90dGVzIE1hc2sgRGFyayIgMC43IDAuMDAgMi4wMCAwLjEwCiNwcmFnbWEgcGFyYW1ldGVyIE1hc2tMaWdodCAiTG90dGVzIE1hc2sgTGlnaHQiIDEuMCAwLjAwIDIuMDAgMC4xMAojcHJhZ21hIHBhcmFtZXRlciBib2d1c19jb2wgIiBbIENPTE9SIF0gIiAwLjAgMC4wIDAuMCAwLjAKI3ByYWdtYSBwYXJhbWV0ZXIgc2F0ICJTYXR1cmF0aW9uIiAxLjAgMC4wMCAyLjAwIDAuMDUKI3ByYWdtYSBwYXJhbWV0ZXIgYnJpZ2h0ICJCb29zdCBicmlnaHQiIDEuMCAxLjAwIDIuMDAgMC4wNQojcHJhZ21hIHBhcmFtZXRlciBkYXJrICJCb29zdCBkYXJrIiAxLjQ1IDEuMDAgMi4wMCAwLjA1CiNwcmFnbWEgcGFyYW1ldGVyIGdsb3cgIkdsb3cgU3RyZW5ndGgiIDAuMDggMC4wIDAuNSAwLjAxCgoKI2RlZmluZSBwaSAzLjE0MTU5CgojaWZkZWYgR0xfRVMKI2RlZmluZSBDT01QQVRfUFJFQ0lTSU9OIG1lZGl1bXAKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CiNlbHNlCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTgojZW5kaWYKCgp1bmlmb3JtIHZlYzIgVGV4dHVyZVNpemU7CnZhcnlpbmcgdmVjMiBURVgwOwp2YXJ5aW5nIHZlYzIgZnJhZ3BvczsKCiNpZiBkZWZpbmVkKFZFUlRFWCkKdW5pZm9ybSBtYXQ0IE1WUE1hdHJpeDsKYXR0cmlidXRlIHZlYzQgVmVydGV4Q29vcmQ7CmF0dHJpYnV0ZSB2ZWMyIFRleENvb3JkOwp1bmlmb3JtIHZlYzIgSW5wdXRTaXplOwp1bmlmb3JtIHZlYzIgT3V0cHV0U2l6ZTsKCnZvaWQgbWFpbigpCnsKCVRFWDAgPSBUZXhDb29yZCoxLjAwMDE7ICAgICAgICAgICAgICAgICAgICAKCWdsX1Bvc2l0aW9uID0gTVZQTWF0cml4ICogVmVydGV4Q29vcmQ7ICAKCWZyYWdwb3MgPSBURVgwLnh5Kk91dHB1dFNpemUueHkqVGV4dHVyZVNpemUueHkvSW5wdXRTaXplLnh5OyAgIAp9CgojZWxpZiBkZWZpbmVkKEZSQUdNRU5UKQoKdW5pZm9ybSBzYW1wbGVyMkQgVGV4dHVyZTsKdW5pZm9ybSB2ZWMyIE91dHB1dFNpemU7CnVuaWZvcm0gdmVjMiBJbnB1dFNpemU7CgojZGVmaW5lIHZUZXhDb29yZCBURVgwLnh5CiNkZWZpbmUgU291cmNlU2l6ZSB2ZWM0KFRleHR1cmVTaXplLCAxLjAgLyBUZXh0dXJlU2l6ZSkgLy9laXRoZXIgVGV4dHVyZVNpemUgb3IgSW5wdXRTaXplCiNkZWZpbmUgb3V0U2l6ZSB2ZWM0KE91dHB1dFNpemUueHksIDEuMC9PdXRwdXRTaXplLnh5LzQuMCkKI2RlZmluZSBGcmFnQ29sb3IgZ2xfRnJhZ0NvbG9yCiNkZWZpbmUgU291cmNlIFRleHR1cmUKCgojaWZkZWYgUEFSQU1FVEVSX1VOSUZPUk0KCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBibHVyOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgU2NhbmxpbmU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCB3ZWlnaHRyOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgd2VpZ2h0ZzsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IHdlaWdodGI7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBtYXNrOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgc2NhbGU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBtc2tfc2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IE1hc2tEYXJrOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgTWFza0xpZ2h0Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgYnJpZ2h0Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgZGFyazsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IHNhdDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IGdsb3c7CgojZWxzZQoKI2RlZmluZSBibHVyIDAuNgojZGVmaW5lIFNjYW5saW5lIDAuMgojZGVmaW5lIHdlaWdodHIgIDAuMgojZGVmaW5lIHdlaWdodGcgIDAuNgojZGVmaW5lIHdlaWdodGIgIDAuMQojZGVmaW5lIG1hc2sgICAgICA3LjAgICAKI2RlZmluZSBtc2tfc2l6ZSAgMS4wCiNkZWZpbmUgc2NhbGUgICAyLjAKI2RlZmluZSBNYXNrRGFyayAgMC41CiNkZWZpbmUgTWFza0xpZ2h0ICAxLjUKI2RlZmluZSBicmlnaHQgIDEuNQojZGVmaW5lIGRhcmsgIDEuMjUKI2RlZmluZSBnbG93ICAgICAgMC4wNSAgIAojZGVmaW5lIHNhdCAgICAgICAxLjAKCiNlbmRpZgoKdmVjNCBNYXNrICh2ZWMyIHApCnsJCQoJCXAgPSBmbG9vcihwL21za19zaXplKTsKCQlmbG9hdCBtZj1mcmFjdChwLngqMC41KTsKCQlmbG9hdCBtPU1hc2tEYXJrOwoJCXZlYzMgTWFzayA9IHZlYzMgKE1hc2tEYXJrKTsKCi8vIFBob3NwaG9yLgoJaWYgKG1hc2s9PTAuMCkKCXsKCQlpZiAobWYgPCAwLjUpIHJldHVybiB2ZWM0IChNYXNrTGlnaHQsbSxNYXNrTGlnaHQsMS4wKTsgCgkJZWxzZSByZXR1cm4gdmVjNCAobSxNYXNrTGlnaHQsbSwxLjApOwoJfQoKLy8gVmVyeSBjb21wcmVzc2VkIFRWIHN0eWxlIHNoYWRvdyBtYXNrLgoJZWxzZSBpZiAobWFzayA9PSAxLjApCgl7CgkJZmxvYXQgbGluZSA9IE1hc2tMaWdodDsKCQlmbG9hdCBvZGQgID0gMC4wOwoKCQlpZiAoZnJhY3QocC54LzYuMCkgPCAwLjUpCgkJCW9kZCA9IDEuMDsKCQlpZiAoZnJhY3QoKHAueSArIG9kZCkvMi4wKSA8IDAuNSkKCQkJbGluZSA9IE1hc2tEYXJrOwoKCQlwLnggPSBmcmFjdChwLngvMy4wKTsKICAgIAoJCWlmICAgICAgKHAueCA8IDAuMzMzKSBNYXNrLnIgPSBNYXNrTGlnaHQ7CgkJZWxzZSBpZiAocC54IDwgMC42NjYpIE1hc2suZyA9IE1hc2tMaWdodDsKCQllbHNlICAgICAgICAgICAgICAgICAgTWFzay5iID0gTWFza0xpZ2h0OwoJCQoJCU1hc2sqPWxpbmU7CgkJcmV0dXJuIHZlYzQgKE1hc2suciwgTWFzay5nLCBNYXNrLmIsMS4wKTsgIAoJfSAKCi8vIEFwZXJ0dXJlLWdyaWxsZS4KCWVsc2UgaWYgKG1hc2sgPT0gMi4wKQoJewoJCXAueCA9IGZyYWN0KHAueC8zLjApOwoKCQlpZiAgICAgIChwLnggPCAwLjMzMykgTWFzay5yID0gTWFza0xpZ2h0OwoJCWVsc2UgaWYgKHAueCA8IDAuNjY2KSBNYXNrLmcgPSBNYXNrTGlnaHQ7CgkJZWxzZSAgICAgICAgICAgICAgICAgIE1hc2suYiA9IE1hc2tMaWdodDsKCQlyZXR1cm4gdmVjNCAoTWFzay5yLCBNYXNrLmcsIE1hc2suYiwxLjApOyAgCgoJfSAKLy8gZ3JheQoJZWxzZSBpZiAobWFzaz09My4wKQoJewoJCQoJCWlmIChtZiA8IDAuNSkgcmV0dXJuIHZlYzQgKE1hc2tMaWdodCxNYXNrTGlnaHQsTWFza0xpZ2h0LDEuMCk7IAoJCWVsc2UgcmV0dXJuIHZlYzQgKG0sbSxtLDEuMCk7Cgl9Ci8vZ3JheSAzcHgKCWVsc2UgaWYgKG1hc2s9PTQuMCkKCXsKCQlmbG9hdCBtZj1mcmFjdChwLngqMC4zMzMzKTsKCQlpZiAobWYgPCAwLjY2NjYpIHJldHVybiB2ZWM0IChNYXNrTGlnaHQsTWFza0xpZ2h0LE1hc2tMaWdodCwxLjApOyAKCQllbHNlIHJldHVybiB2ZWM0IChtLG0sbSwxLjApOwoJfQovL2Nnd2cgc2xvdAoJZWxzZSBpZiAobWFzayA9PSA1LjApCgl7CgkJZmxvYXQgbGluZSA9IE1hc2tMaWdodDsKCQlmbG9hdCBvZGQgID0gMC4wOwoKCQlpZiAoZnJhY3QocC54LzQuMCkgPCAwLjUpCgkJCW9kZCA9IDEuMDsKCQlpZiAoZnJhY3QoKHAueSArIG9kZCkvMi4wKSA8IDAuNSkKCQkJbGluZSA9IE1hc2tEYXJrOwoKCQlwLnggPSBmcmFjdChwLngvMi4wKTsKICAgIAoJCWlmICAocC54IDwgMC41KSB7TWFzay5yID0gMS4wOyBNYXNrLmIgPSAxLjA7fQoJCWVsc2UgIE1hc2suZyA9IDEuMDsJCgkJTWFzayo9bGluZTsgIAoJCXJldHVybiB2ZWM0IChNYXNrLnIsIE1hc2suZywgTWFzay5iLDEuMCk7ICAKCgl9IAoKLy9jZ3dnIHNsb3QgMTQ0MHAKCWVsc2UgaWYgKG1hc2sgPT0gNi4wKQoJewoJCWZsb2F0IGxpbmUgPSBNYXNrTGlnaHQ7CgkJZmxvYXQgb2RkICA9IDAuMDsKCgkJaWYgKGZyYWN0KHAueC82LjApIDwgMC41KQoJCQlvZGQgPSAxLjA7CgkJaWYgKGZyYWN0KChwLnkgKyBvZGQpLzMuMCkgPCAwLjUpCgkJCWxpbmUgPSBNYXNrRGFyazsKCgkJcC54ID0gZnJhY3QocC54LzIuMCk7CiAgICAKCQlpZiAgKHAueCA8IDAuNSkge01hc2suciA9IE1hc2tMaWdodDsgTWFzay5iID0gTWFza0xpZ2h0O30KCQkJZWxzZSAge01hc2suZyA9IE1hc2tMaWdodDt9CQoJCQoJCU1hc2sqPWxpbmU7IAoJCXJldHVybiB2ZWM0IChNYXNrLnIsIE1hc2suZywgTWFzay5iLDEuMCk7ICAgCgl9IAoKLy9QQyBDUlQgVkdBIHN0eWxlIG1hc2sKCWVsc2UgaWYgKG1hc2sgPT0gNy4wKQoJewoJCWZsb2F0IGxpbmUgPSAxLjA7CgkJcC54ID0gZnJhY3QocC54LzIuMCk7CgoJCWlmIChmcmFjdChwLnkvc2NhbGUpIDwgMC41KQoJCQl7CgkJCQlpZiAgKHAueCA8IDAuNSkge01hc2suciA9IDEuMDsgTWFzay5iID0gMS4wO30KCQkJCWVsc2UgIHtNYXNrLmcgPSAxLjA7fQkKCQkJfQoJCWVsc2UKCQkJewoJCQkJaWYgIChwLnggPCAwLjUpIHtNYXNrLmcgPSAxLjA7fQkKCQkJCWVsc2UgICB7TWFzay5yID0gMS4wOyBNYXNrLmIgPSAxLjA7fQoJfQoJCU1hc2sqPWxpbmU7CgkJcmV0dXJuIHZlYzQgKE1hc2suciwgTWFzay5nLCBNYXNrLmIsMS4wKTsgICAKCgl9IAplbHNlIHJldHVybiB2ZWM0KDEuMCk7Cn0KdmVjMyBib29zdGVyICh2ZWMyIHBvcykKewoJdmVjMiBkeCA9IHZlYzIoU291cmNlU2l6ZS56LDAuMCk7Cgl2ZWMyIGR5ID0gdmVjMigwLjAsU291cmNlU2l6ZS53KTsKCgl2ZWM0IGMwMCA9IHRleHR1cmUyRChTb3VyY2UscG9zKTsKCXZlYzQgYzAxID0gdGV4dHVyZTJEKFNvdXJjZSxwb3MrZHgpOwoJdmVjNCBjMDIgPSB0ZXh0dXJlMkQoU291cmNlLHBvcytkeSk7Cgl2ZWM0IGMwMyA9IHRleHR1cmUyRChTb3VyY2UscG9zK2R4K2R5KTsKCgl2ZWM0IGdsID0gKGMwMCtjMDErYzAyK2MwMykvNC4wOyBnbCAqPWdsOwoJdmVjMyBnbDAgPSBnbC5yZ2I7CglyZXR1cm4gZ2wwKmdsb3c7Cn0KCnZvaWQgbWFpbigpCnsJCgl2ZWMyIHBvcyA9dlRleENvb3JkOwoJdmVjMiBPR0wyUG9zID0gcG9zKlRleHR1cmVTaXplOwoJdmVjMiBjZW50ID0gKGZsb29yKE9HTDJQb3MpKzAuNSkvVGV4dHVyZVNpemU7CglmbG9hdCB4Y29vcmQgPSBtaXgoY2VudC54LHZUZXhDb29yZC54LGJsdXIpOwoJdmVjMiBjb29yZHMgPSB2ZWMyKHhjb29yZCwgY2VudC55KTsKCgl2ZWMzIHJlcz0gdGV4dHVyZTJEKFNvdXJjZSwgY29vcmRzKS5yZ2I7CgoJZmxvYXQgbHVtID0gbWF4KG1heChyZXMucip3ZWlnaHRyLHJlcy5nKndlaWdodGcpLHJlcy5iKndlaWdodGIpOwoJZmxvYXQgZiA9IGZyYWN0KE9HTDJQb3MueSk7CgkKCXJlcyAqPSAxLjAtKGYtMC41KSooZi0wLjUpKjQ1LjAqKFNjYW5saW5lKigxLjAtbHVtKSk7CglyZXMgPSBjbGFtcChyZXMsMC4wLDEuMCk7CgkKCWZsb2F0IGwgPSBkb3QocmVzLHZlYzMoMC4zLDAuNiwwLjEpKTsKCXJlcyA9IG1peCh2ZWMzKGwpLCByZXMsIHNhdCk7CglyZXMgKz0gYm9vc3Rlcihjb29yZHMpOwoJdmVjNCByZXMwID0gdmVjNChyZXMsMS4wKTsgCglyZXMwICo9IE1hc2soZnJhZ3BvcyoxLjAwMDEpOwoJcmVzMCAqPSBtaXgoZGFyayxicmlnaHQsbCk7CgkKCUZyYWdDb2xvciA9IHJlczA7Cn0KI2VuZGlmCg==",
            },
        ],
    },

    //https://github.com/libretro/glsl-shaders/blob/master/crt/crt-caligari.glslp
    "crt-caligari": {
        "shader": {
            "type": "text",
            "value": "shaders = 1\n\nshader0 = crt-caligari.glsl\nfilter_linear0 = false\n",
        },
        "resources": [
            {
                "name": "crt-caligari.glsl",
                "type": "base64",
                "value": "Ly8gUGFyYW1ldGVyIGxpbmVzIGdvIGhlcmU6Ci8vIDAuNSA9IHRoZSBzcG90IHN0YXlzIGluc2lkZSB0aGUgb3JpZ2luYWwgcGl4ZWwKLy8gMS4wID0gdGhlIHNwb3QgYmxlZWRzIHVwIHRvIHRoZSBjZW50ZXIgb2YgbmV4dCBwaXhlbAojcHJhZ21hIHBhcmFtZXRlciBTUE9UX1dJRFRIICJDUlRDYWxpZ2FyaSBTcG90IFdpZHRoIiAwLjkgMC41IDEuNSAwLjA1CiNwcmFnbWEgcGFyYW1ldGVyIFNQT1RfSEVJR0hUICJDUlRDYWxpZ2FyaSBTcG90IEhlaWdodCIgMC42NSAwLjUgMS41IDAuMDUKLy8gVXNlZCB0byBjb3VudGVyYWN0IHRoZSBkZXNhdHVyYXRpb24gZWZmZWN0IG9mIHdlaWdodGluZy4KI3ByYWdtYSBwYXJhbWV0ZXIgQ09MT1JfQk9PU1QgIkNSVENhbGlnYXJpIENvbG9yIEJvb3N0IiAxLjQ1IDEuMCAyLjAgMC4wNQovLyBDb25zdGFudHMgdXNlZCB3aXRoIGdhbW1hIGNvcnJlY3Rpb24uCiNwcmFnbWEgcGFyYW1ldGVyIElucHV0R2FtbWEgIkNSVENhbGlnYXJpIElucHV0IEdhbW1hIiAyLjQgMC4wIDUuMCAwLjEKI3ByYWdtYSBwYXJhbWV0ZXIgT3V0cHV0R2FtbWEgIkNSVENhbGlnYXJpIE91dHB1dCBHYW1tYSIgMi4yIDAuMCA1LjAgMC4xCgojaWYgZGVmaW5lZChWRVJURVgpCgojaWYgX19WRVJTSU9OX18gPj0gMTMwCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgb3V0CiNkZWZpbmUgQ09NUEFUX0FUVFJJQlVURSBpbgojZGVmaW5lIENPTVBBVF9URVhUVVJFIHRleHR1cmUKI2Vsc2UKI2RlZmluZSBDT01QQVRfVkFSWUlORyB2YXJ5aW5nIAojZGVmaW5lIENPTVBBVF9BVFRSSUJVVEUgYXR0cmlidXRlIAojZGVmaW5lIENPTVBBVF9URVhUVVJFIHRleHR1cmUyRAojZW5kaWYKCiNpZmRlZiBHTF9FUwojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04gbWVkaXVtcAojZWxzZQojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04KI2VuZGlmCgpDT01QQVRfQVRUUklCVVRFIHZlYzQgVmVydGV4Q29vcmQ7CkNPTVBBVF9BVFRSSUJVVEUgdmVjNCBDT0xPUjsKQ09NUEFUX0FUVFJJQlVURSB2ZWM0IFRleENvb3JkOwpDT01QQVRfVkFSWUlORyB2ZWM0IENPTDA7CkNPTVBBVF9WQVJZSU5HIHZlYzQgVEVYMDsKQ09NUEFUX1ZBUllJTkcgdmVjMiBvbmV4OwpDT01QQVRfVkFSWUlORyB2ZWMyIG9uZXk7Cgp2ZWM0IF9vUG9zaXRpb24xOyAKdW5pZm9ybSBtYXQ0IE1WUE1hdHJpeDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZURpcmVjdGlvbjsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZUNvdW50Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBPdXRwdXRTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBUZXh0dXJlU2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgSW5wdXRTaXplOwoKI2RlZmluZSBTb3VyY2VTaXplIHZlYzQoVGV4dHVyZVNpemUsIDEuMCAvIFRleHR1cmVTaXplKSAvL2VpdGhlciBUZXh0dXJlU2l6ZSBvciBJbnB1dFNpemUKCnZvaWQgbWFpbigpCnsKICAgIGdsX1Bvc2l0aW9uID0gTVZQTWF0cml4ICogVmVydGV4Q29vcmQ7CiAgICBDT0wwID0gQ09MT1I7CiAgICBURVgwLnh5ID0gVGV4Q29vcmQueHk7CiAgIG9uZXggPSB2ZWMyKFNvdXJjZVNpemUueiwgMC4wKTsKICAgb25leSA9IHZlYzIoMC4wLCBTb3VyY2VTaXplLncpOwp9CgojZWxpZiBkZWZpbmVkKEZSQUdNRU5UKQoKI2lmIF9fVkVSU0lPTl9fID49IDEzMAojZGVmaW5lIENPTVBBVF9WQVJZSU5HIGluCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZQpvdXQgdmVjNCBGcmFnQ29sb3I7CiNlbHNlCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgdmFyeWluZwojZGVmaW5lIEZyYWdDb2xvciBnbF9GcmFnQ29sb3IKI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlMkQKI2VuZGlmCgojaWZkZWYgR0xfRVMKI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdICnByZWNpc2lvbiBoaWdocCBmbG9hdDsKI2Vsc2UKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CiNlbmRpZgojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04gbWVkaXVtcAojZWxzZQojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04KI2VuZGlmCgp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lRGlyZWN0aW9uOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lQ291bnQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIE91dHB1dFNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIFRleHR1cmVTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBJbnB1dFNpemU7CnVuaWZvcm0gc2FtcGxlcjJEIFRleHR1cmU7CkNPTVBBVF9WQVJZSU5HIHZlYzQgVEVYMDsKQ09NUEFUX1ZBUllJTkcgdmVjMiBvbmV4OwpDT01QQVRfVkFSWUlORyB2ZWMyIG9uZXk7CgovLyBjb21wYXRpYmlsaXR5ICNkZWZpbmVzCiNkZWZpbmUgU291cmNlIFRleHR1cmUKI2RlZmluZSB2VGV4Q29vcmQgVEVYMC54eQoKI2RlZmluZSBTb3VyY2VTaXplIHZlYzQoVGV4dHVyZVNpemUsIDEuMCAvIFRleHR1cmVTaXplKSAvL2VpdGhlciBUZXh0dXJlU2l6ZSBvciBJbnB1dFNpemUKI2RlZmluZSBPdXRwdXRTaXplIHZlYzQoT3V0cHV0U2l6ZSwgMS4wIC8gT3V0cHV0U2l6ZSkKCiNpZmRlZiBQQVJBTUVURVJfVU5JRk9STQovLyBBbGwgcGFyYW1ldGVyIGZsb2F0cyBuZWVkIHRvIGhhdmUgQ09NUEFUX1BSRUNJU0lPTiBpbiBmcm9udCBvZiB0aGVtCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBTUE9UX1dJRFRIOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgU1BPVF9IRUlHSFQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBDT0xPUl9CT09TVDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IElucHV0R2FtbWE7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBPdXRwdXRHYW1tYTsKI2Vsc2UKI2RlZmluZSBTUE9UX1dJRFRIIDAuOQojZGVmaW5lIFNQT1RfSEVJR0hUIDAuNjUKI2RlZmluZSBDT0xPUl9CT09TVCAxLjQ1CiNkZWZpbmUgSW5wdXRHYW1tYSAyLjQKI2RlZmluZSBPdXRwdXRHYW1tYSAyLjIKI2VuZGlmCgojZGVmaW5lIEdBTU1BX0lOKGNvbG9yKSAgICAgcG93KGNvbG9yLHZlYzQoSW5wdXRHYW1tYSkpCiNkZWZpbmUgR0FNTUFfT1VUKGNvbG9yKSAgICBwb3coY29sb3IsIHZlYzQoMS4wIC8gT3V0cHV0R2FtbWEpKQoKI2RlZmluZSBURVgyRChjb29yZHMpCUdBTU1BX0lOKCBDT01QQVRfVEVYVFVSRShTb3VyY2UsIGNvb3JkcykgKQoKLy8gTWFjcm8gZm9yIHdlaWdodHMgY29tcHV0aW5nCiNkZWZpbmUgV0VJR0hUKHcpIFwKICAgaWYodz4xLjApIHc9MS4wOyBcCncgPSAxLjAgLSB3ICogdzsgXAp3ID0gdyAqIHc7Cgp2b2lkIG1haW4oKQp7CiAgIHZlYzIgY29vcmRzID0gKCB2VGV4Q29vcmQgKiBTb3VyY2VTaXplLnh5ICk7CiAgIHZlYzIgcGl4ZWxfY2VudGVyID0gZmxvb3IoIGNvb3JkcyApICsgdmVjMigwLjUsIDAuNSk7CiAgIHZlYzIgdGV4dHVyZV9jb29yZHMgPSBwaXhlbF9jZW50ZXIgKiBTb3VyY2VTaXplLnp3OwoKICAgdmVjNCBjb2xvciA9IFRFWDJEKCB0ZXh0dXJlX2Nvb3JkcyApOwoKICAgZmxvYXQgZHggPSBjb29yZHMueCAtIHBpeGVsX2NlbnRlci54OwoKICAgZmxvYXQgaF93ZWlnaHRfMDAgPSBkeCAvIFNQT1RfV0lEVEg7CiAgIFdFSUdIVCggaF93ZWlnaHRfMDAgKTsKCiAgIGNvbG9yICo9IHZlYzQoIGhfd2VpZ2h0XzAwLCBoX3dlaWdodF8wMCwgaF93ZWlnaHRfMDAsIGhfd2VpZ2h0XzAwICApOwoKICAgLy8gZ2V0IGNsb3Nlc3QgaG9yaXpvbnRhbCBuZWlnaGJvdXIgdG8gYmxlbmQKICAgdmVjMiBjb29yZHMwMTsKICAgaWYgKGR4PjAuMCkgewogICAgICBjb29yZHMwMSA9IG9uZXg7CiAgICAgIGR4ID0gMS4wIC0gZHg7CiAgIH0gZWxzZSB7CiAgICAgIGNvb3JkczAxID0gLW9uZXg7CiAgICAgIGR4ID0gMS4wICsgZHg7CiAgIH0KICAgdmVjNCBjb2xvck5CID0gVEVYMkQoIHRleHR1cmVfY29vcmRzICsgY29vcmRzMDEgKTsKCiAgIGZsb2F0IGhfd2VpZ2h0XzAxID0gZHggLyBTUE9UX1dJRFRIOwogICBXRUlHSFQoIGhfd2VpZ2h0XzAxICk7CgogICBjb2xvciA9IGNvbG9yICsgY29sb3JOQiAqIHZlYzQoIGhfd2VpZ2h0XzAxICk7CgogICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8KICAgLy8gVmVydGljYWwgQmxlbmRpbmcKICAgZmxvYXQgZHkgPSBjb29yZHMueSAtIHBpeGVsX2NlbnRlci55OwogICBmbG9hdCB2X3dlaWdodF8wMCA9IGR5IC8gU1BPVF9IRUlHSFQ7CiAgIFdFSUdIVCggdl93ZWlnaHRfMDAgKTsKICAgY29sb3IgKj0gdmVjNCggdl93ZWlnaHRfMDAgKTsKCiAgIC8vIGdldCBjbG9zZXN0IHZlcnRpY2FsIG5laWdoYm91ciB0byBibGVuZAogICB2ZWMyIGNvb3JkczEwOwogICBpZiAoZHk+MC4wKSB7CiAgICAgIGNvb3JkczEwID0gb25leTsKICAgICAgZHkgPSAxLjAgLSBkeTsKICAgfSBlbHNlIHsKICAgICAgY29vcmRzMTAgPSAtb25leTsKICAgICAgZHkgPSAxLjAgKyBkeTsKICAgfQogICBjb2xvck5CID0gVEVYMkQoIHRleHR1cmVfY29vcmRzICsgY29vcmRzMTAgKTsKCiAgIGZsb2F0IHZfd2VpZ2h0XzEwID0gZHkgLyBTUE9UX0hFSUdIVDsKICAgV0VJR0hUKCB2X3dlaWdodF8xMCApOwoKICAgY29sb3IgPSBjb2xvciArIGNvbG9yTkIgKiB2ZWM0KCB2X3dlaWdodF8xMCAqIGhfd2VpZ2h0XzAwLCB2X3dlaWdodF8xMCAqIGhfd2VpZ2h0XzAwLCB2X3dlaWdodF8xMCAqIGhfd2VpZ2h0XzAwLCB2X3dlaWdodF8xMCAqIGhfd2VpZ2h0XzAwICk7CgogICBjb2xvck5CID0gVEVYMkQoICB0ZXh0dXJlX2Nvb3JkcyArIGNvb3JkczAxICsgY29vcmRzMTAgKTsKCiAgIGNvbG9yID0gY29sb3IgKyBjb2xvck5CICogdmVjNCggdl93ZWlnaHRfMTAgKiBoX3dlaWdodF8wMSwgdl93ZWlnaHRfMTAgKiBoX3dlaWdodF8wMSwgdl93ZWlnaHRfMTAgKiBoX3dlaWdodF8wMSwgdl93ZWlnaHRfMTAgKiBoX3dlaWdodF8wMSApOwoKICAgY29sb3IgKj0gdmVjNCggQ09MT1JfQk9PU1QgKTsKCiAgIEZyYWdDb2xvciA9IGNsYW1wKCBHQU1NQV9PVVQoY29sb3IpLCAwLjAsIDEuMCApOwp9IAojZW5kaWYK",
            },
        ],
    },

    //https://github.com/libretro/glsl-shaders/blob/master/crt/crt-lottes.glslp
    "crt-lottes": {
        "shader": {
            "type": "text",
            "value": "shaders = 1\n\nshader0 = crt-lottes.glsl\nfilter_linear0 = false\n",
        },
        "resources": [
            {
                "name": "crt-lottes.glsl",
                "type": "base64",
                "value": "Ly8gUGFyYW1ldGVyIGxpbmVzIGdvIGhlcmU6CiNwcmFnbWEgcGFyYW1ldGVyIGhhcmRTY2FuICJoYXJkU2NhbiIgLTguMCAtMjAuMCAwLjAgMS4wCiNwcmFnbWEgcGFyYW1ldGVyIGhhcmRQaXggImhhcmRQaXgiIC0zLjAgLTIwLjAgMC4wIDEuMAojcHJhZ21hIHBhcmFtZXRlciB3YXJwWCAid2FycFgiIDAuMDMxIDAuMCAwLjEyNSAwLjAxCiNwcmFnbWEgcGFyYW1ldGVyIHdhcnBZICJ3YXJwWSIgMC4wNDEgMC4wIDAuMTI1IDAuMDEKI3ByYWdtYSBwYXJhbWV0ZXIgbWFza0RhcmsgIm1hc2tEYXJrIiAwLjUgMC4wIDIuMCAwLjEKI3ByYWdtYSBwYXJhbWV0ZXIgbWFza0xpZ2h0ICJtYXNrTGlnaHQiIDEuNSAwLjAgMi4wIDAuMQojcHJhZ21hIHBhcmFtZXRlciBzY2FsZUluTGluZWFyR2FtbWEgInNjYWxlSW5MaW5lYXJHYW1tYSIgMS4wIDAuMCAxLjAgMS4wCiNwcmFnbWEgcGFyYW1ldGVyIHNoYWRvd01hc2sgInNoYWRvd01hc2siIDMuMCAwLjAgNC4wIDEuMAojcHJhZ21hIHBhcmFtZXRlciBicmlnaHRCb29zdCAiYnJpZ2h0bmVzcyBib29zdCIgMS4wIDAuMCAyLjAgMC4wNQojcHJhZ21hIHBhcmFtZXRlciBoYXJkQmxvb21QaXggImJsb29tLXggc29mdCIgLTEuNSAtMi4wIC0wLjUgMC4xCiNwcmFnbWEgcGFyYW1ldGVyIGhhcmRCbG9vbVNjYW4gImJsb29tLXkgc29mdCIgLTIuMCAtNC4wIC0xLjAgMC4xCiNwcmFnbWEgcGFyYW1ldGVyIGJsb29tQW1vdW50ICJibG9vbSBhbW1vdW50IiAwLjE1IDAuMCAxLjAgMC4wNQojcHJhZ21hIHBhcmFtZXRlciBzaGFwZSAiZmlsdGVyIGtlcm5lbCBzaGFwZSIgMi4wIDAuMCAxMC4wIDAuMDUKCiNpZiBkZWZpbmVkKFZFUlRFWCkKCiNpZiBfX1ZFUlNJT05fXyA+PSAxMzAKI2RlZmluZSBDT01QQVRfVkFSWUlORyBvdXQKI2RlZmluZSBDT01QQVRfQVRUUklCVVRFIGluCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZQojZWxzZQojZGVmaW5lIENPTVBBVF9WQVJZSU5HIHZhcnlpbmcgCiNkZWZpbmUgQ09NUEFUX0FUVFJJQlVURSBhdHRyaWJ1dGUgCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZTJECiNlbmRpZgoKI2lmZGVmIEdMX0VTCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTiBtZWRpdW1wCiNlbHNlCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTgojZW5kaWYKCkNPTVBBVF9BVFRSSUJVVEUgdmVjNCBWZXJ0ZXhDb29yZDsKQ09NUEFUX0FUVFJJQlVURSB2ZWM0IENPTE9SOwpDT01QQVRfQVRUUklCVVRFIHZlYzQgVGV4Q29vcmQ7CkNPTVBBVF9WQVJZSU5HIHZlYzQgQ09MMDsKQ09NUEFUX1ZBUllJTkcgdmVjNCBURVgwOwoKdW5pZm9ybSBtYXQ0IE1WUE1hdHJpeDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZURpcmVjdGlvbjsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZUNvdW50Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBPdXRwdXRTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBUZXh0dXJlU2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgSW5wdXRTaXplOwoKLy8gdmVydGV4IGNvbXBhdGliaWxpdHkgI2RlZmluZXMKI2RlZmluZSB2VGV4Q29vcmQgVEVYMC54eQojZGVmaW5lIFNvdXJjZVNpemUgdmVjNChUZXh0dXJlU2l6ZSwgMS4wIC8gVGV4dHVyZVNpemUpIC8vZWl0aGVyIFRleHR1cmVTaXplIG9yIElucHV0U2l6ZQojZGVmaW5lIG91dHNpemUgdmVjNChPdXRwdXRTaXplLCAxLjAgLyBPdXRwdXRTaXplKQoKdm9pZCBtYWluKCkKewogICAgZ2xfUG9zaXRpb24gPSBNVlBNYXRyaXggKiBWZXJ0ZXhDb29yZDsKICAgIFRFWDAueHkgPSBUZXhDb29yZC54eTsKfQoKI2VsaWYgZGVmaW5lZChGUkFHTUVOVCkKCiNpZiBfX1ZFUlNJT05fXyA+PSAxMzAKI2RlZmluZSBDT01QQVRfVkFSWUlORyBpbgojZGVmaW5lIENPTVBBVF9URVhUVVJFIHRleHR1cmUKb3V0IHZlYzQgRnJhZ0NvbG9yOwojZWxzZQojZGVmaW5lIENPTVBBVF9WQVJZSU5HIHZhcnlpbmcKI2RlZmluZSBGcmFnQ29sb3IgZ2xfRnJhZ0NvbG9yCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZTJECiNlbmRpZgoKI2lmZGVmIEdMX0VTCiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSApwcmVjaXNpb24gaGlnaHAgZmxvYXQ7CiNlbHNlCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwojZW5kaWYKI2RlZmluZSBDT01QQVRfUFJFQ0lTSU9OIG1lZGl1bXAKI2Vsc2UKI2RlZmluZSBDT01QQVRfUFJFQ0lTSU9OCiNlbmRpZgoKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZURpcmVjdGlvbjsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZUNvdW50Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBPdXRwdXRTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBUZXh0dXJlU2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgSW5wdXRTaXplOwp1bmlmb3JtIHNhbXBsZXIyRCBUZXh0dXJlOwpDT01QQVRfVkFSWUlORyB2ZWM0IFRFWDA7CgovLyBmcmFnbWVudCBjb21wYXRpYmlsaXR5ICNkZWZpbmVzCiNkZWZpbmUgU291cmNlIFRleHR1cmUKI2RlZmluZSB2VGV4Q29vcmQgVEVYMC54eQoKI2RlZmluZSBTb3VyY2VTaXplIHZlYzQoVGV4dHVyZVNpemUsIDEuMCAvIFRleHR1cmVTaXplKSAvL2VpdGhlciBUZXh0dXJlU2l6ZSBvciBJbnB1dFNpemUKI2RlZmluZSBvdXRzaXplIHZlYzQoT3V0cHV0U2l6ZSwgMS4wIC8gT3V0cHV0U2l6ZSkKCiNpZmRlZiBQQVJBTUVURVJfVU5JRk9STQovLyBBbGwgcGFyYW1ldGVyIGZsb2F0cyBuZWVkIHRvIGhhdmUgQ09NUEFUX1BSRUNJU0lPTiBpbiBmcm9udCBvZiB0aGVtCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBoYXJkU2NhbjsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IGhhcmRQaXg7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCB3YXJwWDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IHdhcnBZOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgbWFza0Rhcms7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBtYXNrTGlnaHQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBzY2FsZUluTGluZWFyR2FtbWE7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBzaGFkb3dNYXNrOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgYnJpZ2h0Qm9vc3Q7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBoYXJkQmxvb21QaXg7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBoYXJkQmxvb21TY2FuOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgYmxvb21BbW91bnQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBzaGFwZTsKI2Vsc2UKI2RlZmluZSBoYXJkU2NhbiAtOC4wCiNkZWZpbmUgaGFyZFBpeCAtMy4wCiNkZWZpbmUgd2FycFggMC4wMzEKI2RlZmluZSB3YXJwWSAwLjA0MQojZGVmaW5lIG1hc2tEYXJrIDAuNQojZGVmaW5lIG1hc2tMaWdodCAxLjUKI2RlZmluZSBzY2FsZUluTGluZWFyR2FtbWEgMS4wCiNkZWZpbmUgc2hhZG93TWFzayAzLjAKI2RlZmluZSBicmlnaHRCb29zdCAxLjAKI2RlZmluZSBoYXJkQmxvb21QaXggLTEuNQojZGVmaW5lIGhhcmRCbG9vbVNjYW4gLTIuMAojZGVmaW5lIGJsb29tQW1vdW50IDAuMTUKI2RlZmluZSBzaGFwZSAyLjAKI2VuZGlmCgovL1VuY29tbWVudCB0byByZWR1Y2UgaW5zdHJ1Y3Rpb25zIHdpdGggc2ltcGxlciBsaW5lYXJpemF0aW9uCi8vKGZpeGVzIEhEMzAwMCBTYW5keSBCcmlkZ2UgSUdQKQovLyNkZWZpbmUgU0lNUExFX0xJTkVBUl9HQU1NQQojZGVmaW5lIERPX0JMT09NCgovLyAtLS0tLS0tLS0tLS0tIC8vCgovLyBzUkdCIHRvIExpbmVhci4KLy8gQXNzdW1pbmcgdXNpbmcgc1JHQiB0eXBlZCB0ZXh0dXJlcyB0aGlzIHNob3VsZCBub3QgYmUgbmVlZGVkLgojaWZkZWYgU0lNUExFX0xJTkVBUl9HQU1NQQpmbG9hdCBUb0xpbmVhcjEoZmxvYXQgYykKewogICAgcmV0dXJuIGM7Cn0KdmVjMyBUb0xpbmVhcih2ZWMzIGMpCnsKICAgIHJldHVybiBjOwp9CnZlYzMgVG9TcmdiKHZlYzMgYykKewogICAgcmV0dXJuIHBvdyhjLCB2ZWMzKDEuMCAvIDIuMikpOwp9CiNlbHNlCmZsb2F0IFRvTGluZWFyMShmbG9hdCBjKQp7CiAgICBpZiAoc2NhbGVJbkxpbmVhckdhbW1hID09IDAuKSAKICAgICAgICByZXR1cm4gYzsKICAgIAogICAgcmV0dXJuKGM8PTAuMDQwNDUpID8gYy8xMi45MiA6IHBvdygoYyArIDAuMDU1KS8xLjA1NSwgMi40KTsKfQoKdmVjMyBUb0xpbmVhcih2ZWMzIGMpCnsKICAgIGlmIChzY2FsZUluTGluZWFyR2FtbWE9PTAuKSAKICAgICAgICByZXR1cm4gYzsKICAgIAogICAgcmV0dXJuIHZlYzMoVG9MaW5lYXIxKGMuciksIFRvTGluZWFyMShjLmcpLCBUb0xpbmVhcjEoYy5iKSk7Cn0KCi8vIExpbmVhciB0byBzUkdCLgovLyBBc3N1bWluZyB1c2luZyBzUkdCIHR5cGVkIHRleHR1cmVzIHRoaXMgc2hvdWxkIG5vdCBiZSBuZWVkZWQuCmZsb2F0IFRvU3JnYjEoZmxvYXQgYykKewogICAgaWYgKHNjYWxlSW5MaW5lYXJHYW1tYSA9PSAwLikgCiAgICAgICAgcmV0dXJuIGM7CiAgICAKICAgIHJldHVybihjPDAuMDAzMTMwOCA/IGMqMTIuOTIgOiAxLjA1NSpwb3coYywgMC40MTY2NikgLSAwLjA1NSk7Cn0KCnZlYzMgVG9TcmdiKHZlYzMgYykKewogICAgaWYgKHNjYWxlSW5MaW5lYXJHYW1tYSA9PSAwLikgCiAgICAgICAgcmV0dXJuIGM7CiAgICAKICAgIHJldHVybiB2ZWMzKFRvU3JnYjEoYy5yKSwgVG9TcmdiMShjLmcpLCBUb1NyZ2IxKGMuYikpOwp9CiNlbmRpZgoKLy8gTmVhcmVzdCBlbXVsYXRlZCBzYW1wbGUgZ2l2ZW4gZmxvYXRpbmcgcG9pbnQgcG9zaXRpb24gYW5kIHRleGVsIG9mZnNldC4KLy8gQWxzbyB6ZXJvJ3Mgb2ZmIHNjcmVlbi4KdmVjMyBGZXRjaCh2ZWMyIHBvcyx2ZWMyIG9mZil7CiAgcG9zPShmbG9vcihwb3MqU291cmNlU2l6ZS54eStvZmYpK3ZlYzIoMC41LDAuNSkpL1NvdXJjZVNpemUueHk7CiNpZmRlZiBTSU1QTEVfTElORUFSX0dBTU1BCiAgcmV0dXJuIFRvTGluZWFyKGJyaWdodEJvb3N0ICogcG93KENPTVBBVF9URVhUVVJFKFNvdXJjZSxwb3MueHkpLnJnYiwgdmVjMygyLjIpKSk7CiNlbHNlCiAgcmV0dXJuIFRvTGluZWFyKGJyaWdodEJvb3N0ICogQ09NUEFUX1RFWFRVUkUoU291cmNlLHBvcy54eSkucmdiKTsKI2VuZGlmCn0KCi8vIERpc3RhbmNlIGluIGVtdWxhdGVkIHBpeGVscyB0byBuZWFyZXN0IHRleGVsLgp2ZWMyIERpc3QodmVjMiBwb3MpCnsKICAgIHBvcyA9IHBvcypTb3VyY2VTaXplLnh5OwogICAgCiAgICByZXR1cm4gLSgocG9zIC0gZmxvb3IocG9zKSkgLSB2ZWMyKDAuNSkpOwp9CiAgICAKLy8gMUQgR2F1c3NpYW4uCmZsb2F0IEdhdXMoZmxvYXQgcG9zLCBmbG9hdCBzY2FsZSkKewogICAgcmV0dXJuIGV4cDIoc2NhbGUqcG93KGFicyhwb3MpLCBzaGFwZSkpOwp9CgovLyAzLXRhcCBHYXVzc2lhbiBmaWx0ZXIgYWxvbmcgaG9yeiBsaW5lLgp2ZWMzIEhvcnozKHZlYzIgcG9zLCBmbG9hdCBvZmYpCnsKICAgIHZlYzMgYiAgICA9IEZldGNoKHBvcywgdmVjMigtMS4wLCBvZmYpKTsKICAgIHZlYzMgYyAgICA9IEZldGNoKHBvcywgdmVjMiggMC4wLCBvZmYpKTsKICAgIHZlYzMgZCAgICA9IEZldGNoKHBvcywgdmVjMiggMS4wLCBvZmYpKTsKICAgIGZsb2F0IGRzdCA9IERpc3QocG9zKS54OwoKICAgIC8vIENvbnZlcnQgZGlzdGFuY2UgdG8gd2VpZ2h0LgogICAgZmxvYXQgc2NhbGUgPSBoYXJkUGl4OwogICAgZmxvYXQgd2IgPSBHYXVzKGRzdC0xLjAsc2NhbGUpOwogICAgZmxvYXQgd2MgPSBHYXVzKGRzdCswLjAsc2NhbGUpOwogICAgZmxvYXQgd2QgPSBHYXVzKGRzdCsxLjAsc2NhbGUpOwoKICAgIC8vIFJldHVybiBmaWx0ZXJlZCBzYW1wbGUuCiAgICByZXR1cm4gKGIqd2IrYyp3YytkKndkKS8od2Ird2Mrd2QpOwp9CgovLyA1LXRhcCBHYXVzc2lhbiBmaWx0ZXIgYWxvbmcgaG9yeiBsaW5lLgp2ZWMzIEhvcno1KHZlYzIgcG9zLGZsb2F0IG9mZil7CiAgICB2ZWMzIGEgPSBGZXRjaChwb3MsdmVjMigtMi4wLCBvZmYpKTsKICAgIHZlYzMgYiA9IEZldGNoKHBvcyx2ZWMyKC0xLjAsIG9mZikpOwogICAgdmVjMyBjID0gRmV0Y2gocG9zLHZlYzIoIDAuMCwgb2ZmKSk7CiAgICB2ZWMzIGQgPSBGZXRjaChwb3MsdmVjMiggMS4wLCBvZmYpKTsKICAgIHZlYzMgZSA9IEZldGNoKHBvcyx2ZWMyKCAyLjAsIG9mZikpOwogICAgCiAgICBmbG9hdCBkc3QgPSBEaXN0KHBvcykueDsKICAgIC8vIENvbnZlcnQgZGlzdGFuY2UgdG8gd2VpZ2h0LgogICAgZmxvYXQgc2NhbGUgPSBoYXJkUGl4OwogICAgZmxvYXQgd2EgPSBHYXVzKGRzdCAtIDIuMCwgc2NhbGUpOwogICAgZmxvYXQgd2IgPSBHYXVzKGRzdCAtIDEuMCwgc2NhbGUpOwogICAgZmxvYXQgd2MgPSBHYXVzKGRzdCArIDAuMCwgc2NhbGUpOwogICAgZmxvYXQgd2QgPSBHYXVzKGRzdCArIDEuMCwgc2NhbGUpOwogICAgZmxvYXQgd2UgPSBHYXVzKGRzdCArIDIuMCwgc2NhbGUpOwogICAgCiAgICAvLyBSZXR1cm4gZmlsdGVyZWQgc2FtcGxlLgogICAgcmV0dXJuIChhKndhK2Iqd2IrYyp3YytkKndkK2Uqd2UpLyh3YSt3Yit3Yyt3ZCt3ZSk7Cn0KICAKLy8gNy10YXAgR2F1c3NpYW4gZmlsdGVyIGFsb25nIGhvcnogbGluZS4KdmVjMyBIb3J6Nyh2ZWMyIHBvcyxmbG9hdCBvZmYpCnsKICAgIHZlYzMgYSA9IEZldGNoKHBvcywgdmVjMigtMy4wLCBvZmYpKTsKICAgIHZlYzMgYiA9IEZldGNoKHBvcywgdmVjMigtMi4wLCBvZmYpKTsKICAgIHZlYzMgYyA9IEZldGNoKHBvcywgdmVjMigtMS4wLCBvZmYpKTsKICAgIHZlYzMgZCA9IEZldGNoKHBvcywgdmVjMiggMC4wLCBvZmYpKTsKICAgIHZlYzMgZSA9IEZldGNoKHBvcywgdmVjMiggMS4wLCBvZmYpKTsKICAgIHZlYzMgZiA9IEZldGNoKHBvcywgdmVjMiggMi4wLCBvZmYpKTsKICAgIHZlYzMgZyA9IEZldGNoKHBvcywgdmVjMiggMy4wLCBvZmYpKTsKCiAgICBmbG9hdCBkc3QgPSBEaXN0KHBvcykueDsKICAgIC8vIENvbnZlcnQgZGlzdGFuY2UgdG8gd2VpZ2h0LgogICAgZmxvYXQgc2NhbGUgPSBoYXJkQmxvb21QaXg7CiAgICBmbG9hdCB3YSA9IEdhdXMoZHN0IC0gMy4wLCBzY2FsZSk7CiAgICBmbG9hdCB3YiA9IEdhdXMoZHN0IC0gMi4wLCBzY2FsZSk7CiAgICBmbG9hdCB3YyA9IEdhdXMoZHN0IC0gMS4wLCBzY2FsZSk7CiAgICBmbG9hdCB3ZCA9IEdhdXMoZHN0ICsgMC4wLCBzY2FsZSk7CiAgICBmbG9hdCB3ZSA9IEdhdXMoZHN0ICsgMS4wLCBzY2FsZSk7CiAgICBmbG9hdCB3ZiA9IEdhdXMoZHN0ICsgMi4wLCBzY2FsZSk7CiAgICBmbG9hdCB3ZyA9IEdhdXMoZHN0ICsgMy4wLCBzY2FsZSk7CgogICAgLy8gUmV0dXJuIGZpbHRlcmVkIHNhbXBsZS4KICAgIHJldHVybiAoYSp3YStiKndiK2Mqd2MrZCp3ZCtlKndlK2Yqd2YrZyp3ZykvKHdhK3diK3djK3dkK3dlK3dmK3dnKTsKfQogIAovLyBSZXR1cm4gc2NhbmxpbmUgd2VpZ2h0LgpmbG9hdCBTY2FuKHZlYzIgcG9zLCBmbG9hdCBvZmYpCnsKICAgIGZsb2F0IGRzdCA9IERpc3QocG9zKS55OwoKICAgIHJldHVybiBHYXVzKGRzdCArIG9mZiwgaGFyZFNjYW4pOwp9CiAgCi8vIFJldHVybiBzY2FubGluZSB3ZWlnaHQgZm9yIGJsb29tLgpmbG9hdCBCbG9vbVNjYW4odmVjMiBwb3MsIGZsb2F0IG9mZikKewogICAgZmxvYXQgZHN0ID0gRGlzdChwb3MpLnk7CiAgICAKICAgIHJldHVybiBHYXVzKGRzdCArIG9mZiwgaGFyZEJsb29tU2Nhbik7Cn0KCi8vIEFsbG93IG5lYXJlc3QgdGhyZWUgbGluZXMgdG8gZWZmZWN0IHBpeGVsLgp2ZWMzIFRyaSh2ZWMyIHBvcykKewogICAgdmVjMyBhID0gSG9yejMocG9zLC0xLjApOwogICAgdmVjMyBiID0gSG9yejUocG9zLCAwLjApOwogICAgdmVjMyBjID0gSG9yejMocG9zLCAxLjApOwogICAgCiAgICBmbG9hdCB3YSA9IFNjYW4ocG9zLC0xLjApOyAKICAgIGZsb2F0IHdiID0gU2Nhbihwb3MsIDAuMCk7CiAgICBmbG9hdCB3YyA9IFNjYW4ocG9zLCAxLjApOwogICAgCiAgICByZXR1cm4gYSp3YSArIGIqd2IgKyBjKndjOwp9CiAgCi8vIFNtYWxsIGJsb29tLgp2ZWMzIEJsb29tKHZlYzIgcG9zKQp7CiAgICB2ZWMzIGEgPSBIb3J6NShwb3MsLTIuMCk7CiAgICB2ZWMzIGIgPSBIb3J6Nyhwb3MsLTEuMCk7CiAgICB2ZWMzIGMgPSBIb3J6Nyhwb3MsIDAuMCk7CiAgICB2ZWMzIGQgPSBIb3J6Nyhwb3MsIDEuMCk7CiAgICB2ZWMzIGUgPSBIb3J6NShwb3MsIDIuMCk7CgogICAgZmxvYXQgd2EgPSBCbG9vbVNjYW4ocG9zLC0yLjApOwogICAgZmxvYXQgd2IgPSBCbG9vbVNjYW4ocG9zLC0xLjApOyAKICAgIGZsb2F0IHdjID0gQmxvb21TY2FuKHBvcywgMC4wKTsKICAgIGZsb2F0IHdkID0gQmxvb21TY2FuKHBvcywgMS4wKTsKICAgIGZsb2F0IHdlID0gQmxvb21TY2FuKHBvcywgMi4wKTsKCiAgICByZXR1cm4gYSp3YStiKndiK2Mqd2MrZCp3ZCtlKndlOwp9CiAgCi8vIERpc3RvcnRpb24gb2Ygc2NhbmxpbmVzLCBhbmQgZW5kIG9mIHNjcmVlbiBhbHBoYS4KdmVjMiBXYXJwKHZlYzIgcG9zKQp7CiAgICBwb3MgID0gcG9zKjIuMC0xLjA7ICAgIAogICAgcG9zICo9IHZlYzIoMS4wICsgKHBvcy55KnBvcy55KSp3YXJwWCwgMS4wICsgKHBvcy54KnBvcy54KSp3YXJwWSk7CiAgICAKICAgIHJldHVybiBwb3MqMC41ICsgMC41Owp9CiAgCi8vIFNoYWRvdyBtYXNrLgp2ZWMzIE1hc2sodmVjMiBwb3MpCnsKICAgIHZlYzMgbWFzayA9IHZlYzMobWFza0RhcmssIG1hc2tEYXJrLCBtYXNrRGFyayk7CiAgCiAgICAvLyBWZXJ5IGNvbXByZXNzZWQgVFYgc3R5bGUgc2hhZG93IG1hc2suCiAgICBpZiAoc2hhZG93TWFzayA9PSAxLjApIAogICAgewogICAgICAgIGZsb2F0IGxpbmUgPSBtYXNrTGlnaHQ7CiAgICAgICAgZmxvYXQgb2RkID0gMC4wOwogICAgICAgIAogICAgICAgIGlmIChmcmFjdChwb3MueCowLjE2NjY2NjY2NikgPCAwLjUpIG9kZCA9IDEuMDsKICAgICAgICBpZiAoZnJhY3QoKHBvcy55ICsgb2RkKSAqIDAuNSkgPCAwLjUpIGxpbmUgPSBtYXNrRGFyazsgIAogICAgICAgIAogICAgICAgIHBvcy54ID0gZnJhY3QocG9zLngqMC4zMzMzMzMzMzMpOwoKICAgICAgICBpZiAgICAgIChwb3MueCA8IDAuMzMzKSBtYXNrLnIgPSBtYXNrTGlnaHQ7CiAgICAgICAgZWxzZSBpZiAocG9zLnggPCAwLjY2NikgbWFzay5nID0gbWFza0xpZ2h0OwogICAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgIG1hc2suYiA9IG1hc2tMaWdodDsKICAgICAgICBtYXNrKj1saW5lOyAgCiAgICB9IAoKICAgIC8vIEFwZXJ0dXJlLWdyaWxsZS4KICAgIGVsc2UgaWYgKHNoYWRvd01hc2sgPT0gMi4wKSAKICAgIHsKICAgICAgICBwb3MueCA9IGZyYWN0KHBvcy54KjAuMzMzMzMzMzMzKTsKCiAgICAgICAgaWYgICAgICAocG9zLnggPCAwLjMzMykgbWFzay5yID0gbWFza0xpZ2h0OwogICAgICAgIGVsc2UgaWYgKHBvcy54IDwgMC42NjYpIG1hc2suZyA9IG1hc2tMaWdodDsKICAgICAgICBlbHNlICAgICAgICAgICAgICAgICAgICBtYXNrLmIgPSBtYXNrTGlnaHQ7CiAgICB9IAoKICAgIC8vIFN0cmV0Y2hlZCBWR0Egc3R5bGUgc2hhZG93IG1hc2sgKHNhbWUgYXMgcHJpb3Igc2hhZGVycykuCiAgICBlbHNlIGlmIChzaGFkb3dNYXNrID09IDMuMCkgCiAgICB7CiAgICAgICAgcG9zLnggKz0gcG9zLnkqMy4wOwogICAgICAgIHBvcy54ICA9IGZyYWN0KHBvcy54KjAuMTY2NjY2NjY2KTsKCiAgICAgICAgaWYgICAgICAocG9zLnggPCAwLjMzMykgbWFzay5yID0gbWFza0xpZ2h0OwogICAgICAgIGVsc2UgaWYgKHBvcy54IDwgMC42NjYpIG1hc2suZyA9IG1hc2tMaWdodDsKICAgICAgICBlbHNlICAgICAgICAgICAgICAgICAgICBtYXNrLmIgPSBtYXNrTGlnaHQ7CiAgICB9CgogICAgLy8gVkdBIHN0eWxlIHNoYWRvdyBtYXNrLgogICAgZWxzZSBpZiAoc2hhZG93TWFzayA9PSA0LjApIAogICAgewogICAgICAgIHBvcy54eSAgPSBmbG9vcihwb3MueHkqdmVjMigxLjAsIDAuNSkpOwogICAgICAgIHBvcy54ICArPSBwb3MueSozLjA7CiAgICAgICAgcG9zLnggICA9IGZyYWN0KHBvcy54KjAuMTY2NjY2NjY2KTsKCiAgICAgICAgaWYgICAgICAocG9zLnggPCAwLjMzMykgbWFzay5yID0gbWFza0xpZ2h0OwogICAgICAgIGVsc2UgaWYgKHBvcy54IDwgMC42NjYpIG1hc2suZyA9IG1hc2tMaWdodDsKICAgICAgICBlbHNlICAgICAgICAgICAgICAgICAgICBtYXNrLmIgPSBtYXNrTGlnaHQ7CiAgICB9CgogICAgcmV0dXJuIG1hc2s7Cn0KCnZvaWQgbWFpbigpCnsKICAgIHZlYzIgcG9zID0gV2FycChURVgwLnh5KihUZXh0dXJlU2l6ZS54eS9JbnB1dFNpemUueHkpKSooSW5wdXRTaXplLnh5L1RleHR1cmVTaXplLnh5KTsKICAgIHZlYzMgb3V0Q29sb3IgPSBUcmkocG9zKTsKCiNpZmRlZiBET19CTE9PTQogICAgLy9BZGQgQmxvb20KICAgIG91dENvbG9yLnJnYiArPSBCbG9vbShwb3MpKmJsb29tQW1vdW50OwojZW5kaWYKCiAgICBpZiAoc2hhZG93TWFzayA+IDAuMCkKICAgICAgICBvdXRDb2xvci5yZ2IgKj0gTWFzayhnbF9GcmFnQ29vcmQueHkgKiAxLjAwMDAwMSk7CiAgICAKI2lmZGVmIEdMX0VTICAgIC8qIFRPRE8vRklYTUUgLSBoYWNreSBjbGFtcCBmaXggKi8KICAgIHZlYzIgYm9yZGVydGVzdCA9IChwb3MpOwogICAgaWYgKCBib3JkZXJ0ZXN0LnggPiAwLjAwMDEgJiYgYm9yZGVydGVzdC54IDwgMC45OTk5ICYmIGJvcmRlcnRlc3QueSA+IDAuMDAwMSAmJiBib3JkZXJ0ZXN0LnkgPCAwLjk5OTkpCiAgICAgICAgb3V0Q29sb3IucmdiID0gb3V0Q29sb3IucmdiOwogICAgZWxzZQogICAgICAgIG91dENvbG9yLnJnYiA9IHZlYzMoMC4wKTsKI2VuZGlmCiAgICBGcmFnQ29sb3IgPSB2ZWM0KFRvU3JnYihvdXRDb2xvci5yZ2IpLCAxLjApOwp9IAojZW5kaWYK",
            },
        ],
    },

    //https://github.com/libretro/glsl-shaders/blob/master/crt/zfast-crt.glslp
    "crt-zfast": {
        "shader": {
            "type": "text",
            "value": "shaders = 1\n\nshader0 = zfast_crt.glsl\nfilter_linear0 = true",
        },
        "resources": [
            {
                "name": "zfast_crt.glsl",
                "type": "base64",
                "value": "Ly9Gb3IgdGVzdGluZyBjb21waWxhdGlvbg0KLy8jZGVmaW5lIEZSQUdNRU5UDQovLyNkZWZpbmUgVkVSVEVYDQoNCi8vVGhpcyBjYW4ndCBiZSBhbiBvcHRpb24gd2l0aG91dCBzbG93aW5nIHRoZSBzaGFkZXIgZG93bg0KLy9Db21tZW50IHRoaXMgb3V0IGZvciBhIGNvYXJzZXIgMyBwaXhlbCBtYXNrLi4ud2hpY2ggaXMgY3VycmVudGx5IGJyb2tlbg0KLy9vbiBTTkVTIENsYXNzaWMgRWRpdGlvbiBkdWUgdG8gTWFsaSA0MDAgZ3B1IHByZWNpc2lvbg0KI2RlZmluZSBGSU5FTUFTSw0KLy9Tb21lIGRyaXZlcnMgZG9uJ3QgcmV0dXJuIGJsYWNrIHdpdGggdGV4dHVyZSBjb29yZGluYXRlcyBvdXQgb2YgYm91bmRzDQovL1NORVMgQ2xhc3NpYyBpcyB0b28gc2xvdyB0byBibGFjayB0aGVzZSBhcmVhcyBvdXQgd2hlbiB1c2luZyBmdWxsc2NyZWVuDQovL292ZXJsYXlzLiAgQnV0IHlvdSBjYW4gdW5jb21tZW50IHRoZSBiZWxvdyB0byBibGFjayB0aGVtIG91dCBpZiBuZWNlc3NhcnkNCi8vI2RlZmluZSBCTEFDS19PVVRfQk9SREVSDQoNCi8vIFBhcmFtZXRlciBsaW5lcyBnbyBoZXJlOg0KI3ByYWdtYSBwYXJhbWV0ZXIgQkxVUlNDQUxFWCAiQmx1ciBBbW91bnQgWC1BeGlzIiAwLjMwIDAuMCAxLjAgMC4wNQ0KI3ByYWdtYSBwYXJhbWV0ZXIgTE9XTFVNU0NBTiAiU2NhbmxpbmUgRGFya25lc3MgLSBMb3ciIDYuMCAwLjAgMTAuMCAwLjUNCiNwcmFnbWEgcGFyYW1ldGVyIEhJTFVNU0NBTiAiU2NhbmxpbmUgRGFya25lc3MgLSBIaWdoIiA4LjAgMC4wIDUwLjAgMS4wDQojcHJhZ21hIHBhcmFtZXRlciBCUklHSFRCT09TVCAiRGFyayBQaXhlbCBCcmlnaHRuZXNzIEJvb3N0IiAxLjI1IDAuNSAxLjUgMC4wNQ0KI3ByYWdtYSBwYXJhbWV0ZXIgTUFTS19EQVJLICJNYXNrIEVmZmVjdCBBbW91bnQiIDAuMjUgMC4wIDEuMCAwLjA1DQojcHJhZ21hIHBhcmFtZXRlciBNQVNLX0ZBREUgIk1hc2svU2NhbmxpbmUgRmFkZSIgMC44IDAuMCAxLjAgMC4wNQ0KDQojaWYgZGVmaW5lZChWRVJURVgpDQoNCiNpZiBfX1ZFUlNJT05fXyA+PSAxMzANCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgb3V0DQojZGVmaW5lIENPTVBBVF9BVFRSSUJVVEUgaW4NCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZQ0KI2Vsc2UNCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgdmFyeWluZyANCiNkZWZpbmUgQ09NUEFUX0FUVFJJQlVURSBhdHRyaWJ1dGUgDQojZGVmaW5lIENPTVBBVF9URVhUVVJFIHRleHR1cmUyRA0KI2VuZGlmDQoNCiNpZmRlZiBHTF9FUw0KI2RlZmluZSBDT01QQVRfUFJFQ0lTSU9OIG1lZGl1bXANCiNlbHNlDQojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04NCiNlbmRpZg0KDQpDT01QQVRfQVRUUklCVVRFIHZlYzQgVmVydGV4Q29vcmQ7DQpDT01QQVRfQVRUUklCVVRFIHZlYzQgQ09MT1I7DQpDT01QQVRfQVRUUklCVVRFIHZlYzQgVGV4Q29vcmQ7DQpDT01QQVRfVkFSWUlORyB2ZWM0IENPTDA7DQpDT01QQVRfVkFSWUlORyB2ZWM0IFRFWDA7DQpDT01QQVRfVkFSWUlORyBmbG9hdCBtYXNrRmFkZTsNCkNPTVBBVF9WQVJZSU5HIHZlYzIgaW52RGltczsNCg0KdmVjNCBfb1Bvc2l0aW9uMTsgDQp1bmlmb3JtIG1hdDQgTVZQTWF0cml4Ow0KdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZURpcmVjdGlvbjsNCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVDb3VudDsNCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIE91dHB1dFNpemU7DQp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBUZXh0dXJlU2l6ZTsNCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIElucHV0U2l6ZTsNCg0KLy8gY29tcGF0aWJpbGl0eSAjZGVmaW5lcw0KI2RlZmluZSB2VGV4Q29vcmQgVEVYMC54eQ0KI2RlZmluZSBTb3VyY2VTaXplIHZlYzQoVGV4dHVyZVNpemUsIDEuMCAvIFRleHR1cmVTaXplKSAvL2VpdGhlciBUZXh0dXJlU2l6ZSBvciBJbnB1dFNpemUNCiNkZWZpbmUgT3V0U2l6ZSB2ZWM0KE91dHB1dFNpemUsIDEuMCAvIE91dHB1dFNpemUpDQoNCiNpZmRlZiBQQVJBTUVURVJfVU5JRk9STQ0KLy8gQWxsIHBhcmFtZXRlciBmbG9hdHMgbmVlZCB0byBoYXZlIENPTVBBVF9QUkVDSVNJT04gaW4gZnJvbnQgb2YgdGhlbQ0KdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IEJMVVJTQ0FMRVg7DQovL3VuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBCTFVSU0NBTEVZOw0KdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IExPV0xVTVNDQU47DQp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgSElMVU1TQ0FOOw0KdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IEJSSUdIVEJPT1NUOw0KdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IE1BU0tfREFSSzsNCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBNQVNLX0ZBREU7DQojZWxzZQ0KI2RlZmluZSBCTFVSU0NBTEVYIDAuNDUNCi8vI2RlZmluZSBCTFVSU0NBTEVZIDAuMjANCiNkZWZpbmUgTE9XTFVNU0NBTiA1LjANCiNkZWZpbmUgSElMVU1TQ0FOIDEwLjANCiNkZWZpbmUgQlJJR0hUQk9PU1QgMS4yNQ0KI2RlZmluZSBNQVNLX0RBUksgMC4yNQ0KI2RlZmluZSBNQVNLX0ZBREUgMC44DQojZW5kaWYNCg0Kdm9pZCBtYWluKCkNCnsNCiAgICBnbF9Qb3NpdGlvbiA9IE1WUE1hdHJpeCAqIFZlcnRleENvb3JkOw0KCQ0KCVRFWDAueHkgPSBUZXhDb29yZC54eSoxLjAwMDE7DQoJbWFza0ZhZGUgPSAwLjMzMzMqTUFTS19GQURFOw0KCWludkRpbXMgPSAxLjAvVGV4dHVyZVNpemUueHk7DQp9DQoNCiNlbGlmIGRlZmluZWQoRlJBR01FTlQpDQoNCiNpZmRlZiBHTF9FUw0KI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIDQpwcmVjaXNpb24gaGlnaHAgZmxvYXQ7DQojZWxzZQ0KcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7DQojZW5kaWYNCiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTiBtZWRpdW1wDQojZWxzZQ0KI2RlZmluZSBDT01QQVRfUFJFQ0lTSU9ODQojZW5kaWYNCg0KI2lmIF9fVkVSU0lPTl9fID49IDEzMA0KI2RlZmluZSBDT01QQVRfVkFSWUlORyBpbg0KI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlDQpvdXQgQ09NUEFUX1BSRUNJU0lPTiB2ZWM0IEZyYWdDb2xvcjsNCiNlbHNlDQojZGVmaW5lIENPTVBBVF9WQVJZSU5HIHZhcnlpbmcNCiNkZWZpbmUgRnJhZ0NvbG9yIGdsX0ZyYWdDb2xvcg0KI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlMkQNCiNlbmRpZg0KDQp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lRGlyZWN0aW9uOw0KdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZUNvdW50Ow0KdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgT3V0cHV0U2l6ZTsNCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIFRleHR1cmVTaXplOw0KdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgSW5wdXRTaXplOw0KdW5pZm9ybSBzYW1wbGVyMkQgVGV4dHVyZTsNCkNPTVBBVF9WQVJZSU5HIHZlYzQgVEVYMDsNCkNPTVBBVF9WQVJZSU5HIGZsb2F0IG1hc2tGYWRlOw0KQ09NUEFUX1ZBUllJTkcgdmVjMiBpbnZEaW1zOw0KDQovLyBjb21wYXRpYmlsaXR5ICNkZWZpbmVzDQojZGVmaW5lIFNvdXJjZSBUZXh0dXJlDQojZGVmaW5lIHZUZXhDb29yZCBURVgwLnh5DQojZGVmaW5lIHRleHR1cmUoYywgZCkgQ09NUEFUX1RFWFRVUkUoYywgZCkNCiNkZWZpbmUgU291cmNlU2l6ZSB2ZWM0KFRleHR1cmVTaXplLCAxLjAgLyBUZXh0dXJlU2l6ZSkgLy9laXRoZXIgVGV4dHVyZVNpemUgb3IgSW5wdXRTaXplDQojZGVmaW5lIE91dFNpemUgdmVjNChPdXRwdXRTaXplLCAxLjAgLyBPdXRwdXRTaXplKQ0KDQojaWZkZWYgUEFSQU1FVEVSX1VOSUZPUk0NCi8vIEFsbCBwYXJhbWV0ZXIgZmxvYXRzIG5lZWQgdG8gaGF2ZSBDT01QQVRfUFJFQ0lTSU9OIGluIGZyb250IG9mIHRoZW0NCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBCTFVSU0NBTEVYOw0KLy91bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgQkxVUlNDQUxFWTsNCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBMT1dMVU1TQ0FOOw0KdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGZsb2F0IEhJTFVNU0NBTjsNCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBCUklHSFRCT09TVDsNCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBNQVNLX0RBUks7DQp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgTUFTS19GQURFOw0KI2Vsc2UNCiNkZWZpbmUgQkxVUlNDQUxFWCAwLjQ1DQovLyNkZWZpbmUgQkxVUlNDQUxFWSAwLjIwDQojZGVmaW5lIExPV0xVTVNDQU4gNS4wDQojZGVmaW5lIEhJTFVNU0NBTiAxMC4wDQojZGVmaW5lIEJSSUdIVEJPT1NUIDEuMjUNCiNkZWZpbmUgTUFTS19EQVJLIDAuMjUNCiNkZWZpbmUgTUFTS19GQURFIDAuOA0KI2VuZGlmDQoNCnZvaWQgbWFpbigpDQp7DQoNCgkvL1RoaXMgaXMganVzdCBsaWtlICJRdWlsZXogU2NhbGluZyIgYnV0IHNoYXJwZXINCglDT01QQVRfUFJFQ0lTSU9OIHZlYzIgcCA9IHZUZXhDb29yZCAqIFRleHR1cmVTaXplOw0KCUNPTVBBVF9QUkVDSVNJT04gdmVjMiBpID0gZmxvb3IocCkgKyAwLjUwOw0KCUNPTVBBVF9QUkVDSVNJT04gdmVjMiBmID0gcCAtIGk7DQoJcCA9IChpICsgNC4wKmYqZipmKSppbnZEaW1zOw0KCXAueCA9IG1peCggcC54ICwgdlRleENvb3JkLngsIEJMVVJTQ0FMRVgpOw0KCUNPTVBBVF9QUkVDSVNJT04gZmxvYXQgWSA9IGYueSpmLnk7DQoJQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBZWSA9IFkqWTsNCiNkZWZpbmUgcmF0aW8gU291cmNlU2l6ZS54L0lucHV0U2l6ZS54CQ0KI2lmIGRlZmluZWQoRklORU1BU0spIA0KCUNPTVBBVF9QUkVDSVNJT04gZmxvYXQgd2hpY2htYXNrID0gZmxvb3IodlRleENvb3JkLngqT3V0cHV0U2l6ZS54KnJhdGlvKSotMC41Ow0KCUNPTVBBVF9QUkVDSVNJT04gZmxvYXQgbWFzayA9IDEuMCArIGZsb2F0KGZyYWN0KHdoaWNobWFzaykgPCAwLjUpICogLU1BU0tfREFSSzsNCiNlbHNlDQoJQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCB3aGljaG1hc2sgPSBmbG9vcih2VGV4Q29vcmQueCpPdXRwdXRTaXplLngqcmF0aW8pKi0wLjMzMzM7DQoJQ09NUEFUX1BSRUNJU0lPTiBmbG9hdCBtYXNrID0gMS4wICsgZmxvYXQoZnJhY3Qod2hpY2htYXNrKSA8IDAuMzMzMykgKiAtTUFTS19EQVJLOw0KI2VuZGlmDQoJQ09NUEFUX1BSRUNJU0lPTiB2ZWMzIGNvbG91ciA9IENPTVBBVF9URVhUVVJFKFNvdXJjZSwgcCkucmdiOw0KCQ0KCUNPTVBBVF9QUkVDSVNJT04gZmxvYXQgc2NhbkxpbmVXZWlnaHQgPSAoQlJJR0hUQk9PU1QgLSBMT1dMVU1TQ0FOKihZIC0gMi4wNSpZWSkpOw0KCUNPTVBBVF9QUkVDSVNJT04gZmxvYXQgc2NhbkxpbmVXZWlnaHRCID0gMS4wIC0gSElMVU1TQ0FOKihZWS0yLjgqWVkqWSk7CQ0KCQ0KI2lmIGRlZmluZWQoQkxBQ0tfT1VUX0JPUkRFUikNCgljb2xvdXIucmdiKj1mbG9hdCh0Yy54ID4gMC4wKSpmbG9hdCh0Yy55ID4gMC4wKTsgLy93aHkgZG9lc24ndCB0aGUgZHJpdmVyIGRvIHRoZSByaWdodCB0aGluZz8NCiNlbmRpZg0KDQoJRnJhZ0NvbG9yLnJnYmEgPSB2ZWM0KGNvbG91ci5yZ2IqbWl4KHNjYW5MaW5lV2VpZ2h0Km1hc2ssIHNjYW5MaW5lV2VpZ2h0QiwgZG90KGNvbG91ci5yZ2IsdmVjMyhtYXNrRmFkZSkpKSwxLjApOw0KCQ0KfSANCiNlbmRpZg0K",
            },
        ],
    },

    //https://github.com/libretro/glsl-shaders/blob/master/crt/yeetron.glslp
    "crt-yeetron": {
        "shader": {
            "type": "text",
            "value": "shaders = 1\n\nshader0 = yeetron.glsl\nfilter_linear0 = false\n",
        },
        "resources": [
            {
                "name": "yeetron.glsl",
                "type": "base64",
                "value": "Ly8gcG9ydGVkIGZyb20gUmVTaGFkZQoKI2lmIGRlZmluZWQoVkVSVEVYKQoKI2lmIF9fVkVSU0lPTl9fID49IDEzMAojZGVmaW5lIENPTVBBVF9WQVJZSU5HIG91dAojZGVmaW5lIENPTVBBVF9BVFRSSUJVVEUgaW4KI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlCiNlbHNlCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgdmFyeWluZyAKI2RlZmluZSBDT01QQVRfQVRUUklCVVRFIGF0dHJpYnV0ZSAKI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlMkQKI2VuZGlmCgojaWZkZWYgR0xfRVMKI2RlZmluZSBDT01QQVRfUFJFQ0lTSU9OIG1lZGl1bXAKI2Vsc2UKI2RlZmluZSBDT01QQVRfUFJFQ0lTSU9OCiNlbmRpZgoKQ09NUEFUX0FUVFJJQlVURSB2ZWM0IFZlcnRleENvb3JkOwpDT01QQVRfQVRUUklCVVRFIHZlYzQgQ09MT1I7CkNPTVBBVF9BVFRSSUJVVEUgdmVjNCBUZXhDb29yZDsKQ09NUEFUX1ZBUllJTkcgdmVjNCBDT0wwOwpDT01QQVRfVkFSWUlORyB2ZWM0IFRFWDA7Cgp2ZWM0IF9vUG9zaXRpb24xOyAKdW5pZm9ybSBtYXQ0IE1WUE1hdHJpeDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZURpcmVjdGlvbjsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZUNvdW50Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBPdXRwdXRTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBUZXh0dXJlU2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgSW5wdXRTaXplOwoKLy8gY29tcGF0aWJpbGl0eSAjZGVmaW5lcwojZGVmaW5lIHZUZXhDb29yZCBURVgwLnh5CiNkZWZpbmUgU291cmNlU2l6ZSB2ZWM0KFRleHR1cmVTaXplLCAxLjAgLyBUZXh0dXJlU2l6ZSkgLy9laXRoZXIgVGV4dHVyZVNpemUgb3IgSW5wdXRTaXplCiNkZWZpbmUgT3V0U2l6ZSB2ZWM0KE91dHB1dFNpemUsIDEuMCAvIE91dHB1dFNpemUpCgp2b2lkIG1haW4oKQp7CiAgICBnbF9Qb3NpdGlvbiA9IE1WUE1hdHJpeCAqIFZlcnRleENvb3JkOwogICAgVEVYMC54eSA9IFRleENvb3JkLnh5Owp9CgojZWxpZiBkZWZpbmVkKEZSQUdNRU5UKQoKI2lmZGVmIEdMX0VTCiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSApwcmVjaXNpb24gaGlnaHAgZmxvYXQ7CiNlbHNlCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwojZW5kaWYKI2RlZmluZSBDT01QQVRfUFJFQ0lTSU9OIG1lZGl1bXAKI2Vsc2UKI2RlZmluZSBDT01QQVRfUFJFQ0lTSU9OCiNlbmRpZgoKI2lmIF9fVkVSU0lPTl9fID49IDEzMAojZGVmaW5lIENPTVBBVF9WQVJZSU5HIGluCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZQpvdXQgQ09NUEFUX1BSRUNJU0lPTiB2ZWM0IEZyYWdDb2xvcjsKI2Vsc2UKI2RlZmluZSBDT01QQVRfVkFSWUlORyB2YXJ5aW5nCiNkZWZpbmUgRnJhZ0NvbG9yIGdsX0ZyYWdDb2xvcgojZGVmaW5lIENPTVBBVF9URVhUVVJFIHRleHR1cmUyRAojZW5kaWYKCnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVEaXJlY3Rpb247CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVDb3VudDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgT3V0cHV0U2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgVGV4dHVyZVNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIElucHV0U2l6ZTsKdW5pZm9ybSBzYW1wbGVyMkQgVGV4dHVyZTsKQ09NUEFUX1ZBUllJTkcgdmVjNCBURVgwOwoKLy8gY29tcGF0aWJpbGl0eSAjZGVmaW5lcwojZGVmaW5lIFNvdXJjZSBUZXh0dXJlCiNkZWZpbmUgdlRleENvb3JkIFRFWDAueHkKCiNkZWZpbmUgU291cmNlU2l6ZSB2ZWM0KFRleHR1cmVTaXplLCAxLjAgLyBUZXh0dXJlU2l6ZSkgLy9laXRoZXIgVGV4dHVyZVNpemUgb3IgSW5wdXRTaXplCiNkZWZpbmUgT3V0U2l6ZSB2ZWM0KE91dHB1dFNpemUsIDEuMCAvIE91dHB1dFNpemUpCgp2ZWM0IGNtcCh2ZWM0IHNyYzAsIHZlYzQgc3JjMSwgdmVjNCBzcmMyKSB7CglyZXR1cm4gdmVjNCgKCQlzcmMwLnggPj0gMC4wID8gc3JjMS54IDogc3JjMi54LAoJCXNyYzAueSA+PSAwLjAgPyBzcmMxLnkgOiBzcmMyLnksCgkJc3JjMC56ID49IDAuMCA/IHNyYzEueiA6IHNyYzIueiwKCQlzcmMwLncgPj0gMC4wID8gc3JjMS53IDogc3JjMi53CgkpOwp9CgojZGVmaW5lIHNhdHVyYXRlKGMpIGNsYW1wKGMsIDAuMCwgMS4wKQoKdm9pZCBtYWluKCkKewoJLy9EZWNsYXJlIHBhcmFtZXRlcnMKCS8vcGl4ZWxTaXplCgl2ZWM0IGMwID0gSW5wdXRTaXplLnh5eXk7CgkvL3RleHR1cmVTaXplCgl2ZWM0IGMxID0gU291cmNlU2l6ZTsKCS8vdmlld1NpemUKCXZlYzQgYzIgPSBPdXRTaXplOwogICAKCS8vRGVjbGFyZSBjb25zdGFudHMKCWNvbnN0IHZlYzQgYzMgPSB2ZWM0KDEuNSwgMC44MDAwMDAwMTIsIDEuMjUsIDAuNzUpOwoJY29uc3QgdmVjNCBjNCA9IHZlYzQoNi4yODMxODU0OCwgLTMuMTQxNTkyNzQsIDAuMjUsIC0wLjI1KTsKCWNvbnN0IHZlYzQgYzUgPSB2ZWM0KDEuLCAwLjUsIDcyMC4sIDMuKTsKCWNvbnN0IHZlYzQgYzYgPSB2ZWM0KDAuMTY2NjY2NjcyLCAtMC4zMzMwMDAwMDQsIC0wLjY2NjAwMDAwOSwgMC44OTk5OTk5NzYpOwoJY29uc3QgdmVjNCBjNyA9IHZlYzQoMC44OTk5OTk5NzYsIDEuMTAwMDAwMDIsIDAuLCAwLik7Cgljb25zdCB2ZWM0IGM4ID0gdmVjNCgtMC41LCAtMC4yNSwgMi4sIDAuNSk7CgoJLy9EZWNsYXJlIHJlZ2lzdGVycwoJdmVjNCByMCwgcjEsIHIyLCByMywgcjQsIHI1LCByNiwgcjcsIHI4LCByOTsKCgkvL0NvZGUgc3RhcnRzIGhlcmUKCXZlYzQgdjAgPSB2VGV4Q29vcmQueHl5eTsKCS8vZGNsXzJkIHMwCglyMC54ID0gMS4wIC8gYzAueDsKCXIwLnkgPSAxLjAgLyBjMC55OwoJcjAueHkgPSAocjAgKiBjMSkueHk7CglyMC54eSA9IChyMCAqIHYwKS54eTsKCXIwLnh5ID0gKHIwICogYzIpLnh5OwoJcjAuencgPSBmcmFjdChyMC54eXh5KS56dzsKCXIwLnh5ID0gKC1yMC56d3p3ICsgcjApLnh5OwoJcjAueHkgPSAocjAgKyBjOC53d3d3KS54eTsKCXIwLnggPSByMC55ICogYzUudyArIHIwLng7CglyMC54ID0gcjAueCAqIGM2Lng7CglyMC54ID0gZnJhY3QocjAueCk7CglyMC54eSA9IChyMC54eHh4ICsgYzYueXp6dykueHk7CglyMS55eiA9IChyMC55ID49IDAuMCA/IGM3Lnh4eXcgOiBjNy54eXh3KS55ejsKCXIxLnggPSBjNi53OwoJcjAueHl6ID0gKHIwLnggPj0gMC4wID8gcjEgOiBjNy55eHh3KS54eXo7CglyMS54eSA9IChjMSAqIHYwKS54eTsKCXIwLncgPSByMS55ICogYzgudyArIGM4Lnc7CglyMC53ID0gZnJhY3QocjAudyk7CglyMC53ID0gcjAudyAqIGM0LnggKyBjNC55OwoJcjIueSA9IHNpbihyMC53KTsKCXIxLnp3ID0gKGFicyhyMikueXl5eSArIGM0KS56dzsKCXIxLnogPSBjbGFtcChyMS56LCAwLjAsIDEuMCk7CglyMC53ID0gcjEudyA+PSAwLjAgPyByMS56IDogYzgudzsKCXIyID0gZnJhY3QocjEueHl4eSk7CglyMS54eSA9IChyMSArIC1yMi56d3p3KS54eTsKCXIyID0gcjIgKyBjOC54eHl5OwoJcjEuencgPSAocjEueHl4eSArIGM4Lnd3d3cpLnp3OwoJcjEuencgPSAodjAueHl4eSAqIC1jMS54eXh5ICsgcjEpLnp3OwoJcjEudyA9IHIxLncgKyByMS53OwoJcjEueiA9IHIxLnogKiBjOC53OwoJcjEueiA9IC1hYnMocjEpLnogKyBjMy54OwoJcjMueCA9IG1heChjMy55LCByMS56KTsKCXI0LnggPSBtaW4ocjMueCwgYzMueik7CglyMS56dyA9ICgtYWJzKHIxKS53d3d3ICsgYzMpLnp3OwoJcjEueiA9IGNsYW1wKHIxLnosIDAuMCwgMS4wKTsKCXIxLnogPSByMS53ID49IDAuMCA/IHIxLnogOiBjOC53OwoJcjQueSA9IHIwLncgKyByMS56OwoJcjAudyA9IHIwLncgKiByNC54OwoJcjEueiA9IHIxLnogKiByNC54OwoJcjMueHkgPSAocjQgKiBjNSkueHk7CglyMS53ID0gcjMueSAqIHIzLng7CglyMi56ID0gY21wKHIyLCByMi54eXh5LCBjOC55eXl5KS56OwoJcjMueHkgPSBtYXgoYzgueXl5eSwgLXIyLnp3encpLnh5OwoJcjIueHkgPSAocjIgKyByMykueHk7CglyMS54eSA9IChyMiAqIGM4Lnp6enogKyByMSkueHk7CglyMS54eSA9IChyMSArIGM4Lnd3d3cpLnh5OwoJcjIueCA9IDEuMCAvIGMxLng7CglyMi55ID0gMS4wIC8gYzEueTsKCXIxLnh5ID0gKHIxICogcjIpLnh5OwoJcjIgPSBDT01QQVRfVEVYVFVSRShTb3VyY2UsIHIxLnh5KTsKCXIzLnggPSByMC53ICogcjIueDsKCXIzLnl6ID0gKHIxLnh6d3cgKiByMikueXo7CglGcmFnQ29sb3IudyA9IHIyLnc7CglyMC54eXogPSAocjAgKiByMykueHl6OwoJcjEueiA9IGM1Lno7CglyMC53ID0gcjEueiArIC1jMi55OwoJRnJhZ0NvbG9yLnh5eiA9IChyMC53ID49IDAuMCA/IHIzIDogcjApLnh5ejsKfSAKI2VuZGlmCg==",
            },
        ],
    },

    //https://github.com/libretro/glsl-shaders/blob/master/cubic/bicubic.glslp
    "bicubic": {
        "shader": {
            "type": "text",
            "value": "shaders = 1\n\nshader0 = bicubic.glsl\nfilter_linear0 = false",
        },
        "resources": [
            {
                "name": "bicubic.glsl",
                "type": "base64",
                "value": "Ly8gRGVmYXVsdCB0byBNaXRjaGVsLU5ldHJhdmFsaSBjb2VmZmljaWVudHMgZm9yIGJlc3QgcHN5Y2hvdmlzdWFsIHJlc3VsdAovLyBiaWN1YmljLXNoYXJwIGlzIEIgPSAwLjEgYW5kIEMgPSAwLjUKLy8gYmljdWJpYy1zaGFycGVyIGlzIEIgPSAwLjAgYW5kIEMgPSAwLjc1CiNwcmFnbWEgcGFyYW1ldGVyIEIgIkJpY3ViaWMgQ29lZmYgQiIgMC4zMyAwLjAgMS4wIDAuMDEKI3ByYWdtYSBwYXJhbWV0ZXIgQyAiQmljdWJpYyBDb2VmZiBDIiAwLjMzIDAuMCAxLjAgMC4wMQoKI2lmIGRlZmluZWQoVkVSVEVYKQoKI2lmIF9fVkVSU0lPTl9fID49IDEzMAojZGVmaW5lIENPTVBBVF9WQVJZSU5HIG91dAojZGVmaW5lIENPTVBBVF9BVFRSSUJVVEUgaW4KI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlCiNlbHNlCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgdmFyeWluZyAKI2RlZmluZSBDT01QQVRfQVRUUklCVVRFIGF0dHJpYnV0ZSAKI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlMkQKI2VuZGlmCgojaWZkZWYgR0xfRVMKI2RlZmluZSBDT01QQVRfUFJFQ0lTSU9OIG1lZGl1bXAKI2Vsc2UKI2RlZmluZSBDT01QQVRfUFJFQ0lTSU9OCiNlbmRpZgoKQ09NUEFUX0FUVFJJQlVURSB2ZWM0IFZlcnRleENvb3JkOwpDT01QQVRfQVRUUklCVVRFIHZlYzQgVGV4Q29vcmQ7CkNPTVBBVF9WQVJZSU5HIHZlYzQgVEVYMDsKCnVuaWZvcm0gbWF0NCBNVlBNYXRyaXg7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVEaXJlY3Rpb247CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVDb3VudDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgT3V0cHV0U2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgVGV4dHVyZVNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIElucHV0U2l6ZTsKCi8vIGNvbXBhdGliaWxpdHkgI2RlZmluZXMKI2RlZmluZSB2VGV4Q29vcmQgVEVYMC54eQojZGVmaW5lIFNvdXJjZVNpemUgdmVjNChUZXh0dXJlU2l6ZSwgMS4wIC8gVGV4dHVyZVNpemUpIC8vZWl0aGVyIFRleHR1cmVTaXplIG9yIElucHV0U2l6ZQojZGVmaW5lIE91dFNpemUgdmVjNChPdXRwdXRTaXplLCAxLjAgLyBPdXRwdXRTaXplKQoKdm9pZCBtYWluKCkKewogICBnbF9Qb3NpdGlvbiA9IE1WUE1hdHJpeCAqIFZlcnRleENvb3JkOwogICBURVgwLnh5ID0gVGV4Q29vcmQueHk7Cn0KCiNlbGlmIGRlZmluZWQoRlJBR01FTlQpCgojaWZkZWYgR0xfRVMKI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdICnByZWNpc2lvbiBoaWdocCBmbG9hdDsKI2Vsc2UKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CiNlbmRpZgojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04gbWVkaXVtcAojZWxzZQojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04KI2VuZGlmCgojaWYgX19WRVJTSU9OX18gPj0gMTMwCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgaW4KI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlCm91dCBDT01QQVRfUFJFQ0lTSU9OIHZlYzQgRnJhZ0NvbG9yOwojZWxzZQojZGVmaW5lIENPTVBBVF9WQVJZSU5HIHZhcnlpbmcKI2RlZmluZSBGcmFnQ29sb3IgZ2xfRnJhZ0NvbG9yCiNkZWZpbmUgQ09NUEFUX1RFWFRVUkUgdGV4dHVyZTJECiNlbmRpZgoKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZURpcmVjdGlvbjsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIGludCBGcmFtZUNvdW50Owp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBPdXRwdXRTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBUZXh0dXJlU2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgSW5wdXRTaXplOwp1bmlmb3JtIHNhbXBsZXIyRCBUZXh0dXJlOwpDT01QQVRfVkFSWUlORyB2ZWM0IFRFWDA7CgovLyBjb21wYXRpYmlsaXR5ICNkZWZpbmVzCiNkZWZpbmUgU291cmNlIFRleHR1cmUKI2RlZmluZSB2VGV4Q29vcmQgVEVYMC54eQoKI2RlZmluZSBTb3VyY2VTaXplIHZlYzQoVGV4dHVyZVNpemUsIDEuMCAvIFRleHR1cmVTaXplKSAvL2VpdGhlciBUZXh0dXJlU2l6ZSBvciBJbnB1dFNpemUKI2RlZmluZSBPdXRTaXplIHZlYzQoT3V0cHV0U2l6ZSwgMS4wIC8gT3V0cHV0U2l6ZSkKCiNpZmRlZiBQQVJBTUVURVJfVU5JRk9STQp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gZmxvYXQgQiwgQzsKI2Vsc2UKI2RlZmluZSBCIDAuMzMzMwojZGVmaW5lIEMgMC4zMzMzCiNlbmRpZgoKZmxvYXQgd2VpZ2h0KGZsb2F0IHgpCnsKCWZsb2F0IGF4ID0gYWJzKHgpOwoKCWlmIChheCA8IDEuMCkKCXsKCQlyZXR1cm4KCQkJKAoJCQkgcG93KHgsIDIuMCkgKiAoKDEyLjAgLSA5LjAgKiBCIC0gNi4wICogQykgKiBheCArICgtMTguMCArIDEyLjAgKiBCICsgNi4wICogQykpICsKCQkJICg2LjAgLSAyLjAgKiBCKQoJCQkpIC8gNi4wOwoJfQoJZWxzZSBpZiAoKGF4ID49IDEuMCkgJiYgKGF4IDwgMi4wKSkKCXsKCQlyZXR1cm4KCQkJKAoJCQkgcG93KHgsIDIuMCkgKiAoKC1CIC0gNi4wICogQykgKiBheCArICg2LjAgKiBCICsgMzAuMCAqIEMpKSArCgkJCSAoLTEyLjAgKiBCIC0gNDguMCAqIEMpICogYXggKyAoOC4wICogQiArIDI0LjAgKiBDKQoJCQkpIC8gNi4wOwoJfQoJZWxzZQoJewoJCXJldHVybiAwLjA7Cgl9Cn0KCQp2ZWM0IHdlaWdodDQoZmxvYXQgeCkKewoJcmV0dXJuIHZlYzQoCgkJCXdlaWdodCh4IC0gMi4wKSwKCQkJd2VpZ2h0KHggLSAxLjApLAoJCQl3ZWlnaHQoeCksCgkJCXdlaWdodCh4ICsgMS4wKSk7Cn0KCnZlYzMgcGl4ZWwoZmxvYXQgeHBvcywgZmxvYXQgeXBvcywgc2FtcGxlcjJEIHRleCkKewoJcmV0dXJuIENPTVBBVF9URVhUVVJFKHRleCwgdmVjMih4cG9zLCB5cG9zKSkucmdiOwp9Cgp2ZWMzIGxpbmVfcnVuKGZsb2F0IHlwb3MsIHZlYzQgeHBvcywgdmVjNCBsaW5ldGFwcywgc2FtcGxlcjJEIHRleCkKewoJcmV0dXJuCgkJcGl4ZWwoeHBvcy5yLCB5cG9zLCB0ZXgpICogbGluZXRhcHMuciArCgkJcGl4ZWwoeHBvcy5nLCB5cG9zLCB0ZXgpICogbGluZXRhcHMuZyArCgkJcGl4ZWwoeHBvcy5iLCB5cG9zLCB0ZXgpICogbGluZXRhcHMuYiArCgkJcGl4ZWwoeHBvcy5hLCB5cG9zLCB0ZXgpICogbGluZXRhcHMuYTsKfQoKdm9pZCBtYWluKCkKewogICAgICAgIHZlYzIgc3RlcHh5ID0gdmVjMigxLjAvU291cmNlU2l6ZS54LCAxLjAvU291cmNlU2l6ZS55KTsKICAgICAgICB2ZWMyIHBvcyA9IHZUZXhDb29yZC54eSArIHN0ZXB4eSAqIDAuNTsKICAgICAgICB2ZWMyIGYgPSBmcmFjdChwb3MgLyBzdGVweHkpOwoJCQoJdmVjNCBsaW5ldGFwcyAgID0gd2VpZ2h0NCgxLjAgLSBmLngpOwoJdmVjNCBjb2x1bW50YXBzID0gd2VpZ2h0NCgxLjAgLSBmLnkpOwoKCS8vbWFrZSBzdXJlIGFsbCB0YXBzIGFkZGVkIHRvZ2V0aGVyIGlzIGV4YWN0bHkgMS4wLCBvdGhlcndpc2Ugc29tZSAodmVyeSBzbWFsbCkgZGlzdG9ydGlvbiBjYW4gb2NjdXIKCWxpbmV0YXBzIC89IGxpbmV0YXBzLnIgKyBsaW5ldGFwcy5nICsgbGluZXRhcHMuYiArIGxpbmV0YXBzLmE7Cgljb2x1bW50YXBzIC89IGNvbHVtbnRhcHMuciArIGNvbHVtbnRhcHMuZyArIGNvbHVtbnRhcHMuYiArIGNvbHVtbnRhcHMuYTsKCgl2ZWMyIHh5c3RhcnQgPSAoLTEuNSAtIGYpICogc3RlcHh5ICsgcG9zOwoJdmVjNCB4cG9zID0gdmVjNCh4eXN0YXJ0LngsIHh5c3RhcnQueCArIHN0ZXB4eS54LCB4eXN0YXJ0LnggKyBzdGVweHkueCAqIDIuMCwgeHlzdGFydC54ICsgc3RlcHh5LnggKiAzLjApOwoKCi8vIGZpbmFsIHN1bSBhbmQgd2VpZ2h0IG5vcm1hbGl6YXRpb24KICAgdmVjNCBmaW5hbCA9IHZlYzQobGluZV9ydW4oeHlzdGFydC55ICAgICAgICAgICAgICAgICAsIHhwb3MsIGxpbmV0YXBzLCBTb3VyY2UpICogY29sdW1udGFwcy5yICsKICAgICAgICAgICAgICAgICAgICAgIGxpbmVfcnVuKHh5c3RhcnQueSArIHN0ZXB4eS55ICAgICAgLCB4cG9zLCBsaW5ldGFwcywgU291cmNlKSAqIGNvbHVtbnRhcHMuZyArCiAgICAgICAgICAgICAgICAgICAgICBsaW5lX3J1bih4eXN0YXJ0LnkgKyBzdGVweHkueSAqIDIuMCwgeHBvcywgbGluZXRhcHMsIFNvdXJjZSkgKiBjb2x1bW50YXBzLmIgKwogICAgICAgICAgICAgICAgICAgICAgbGluZV9ydW4oeHlzdGFydC55ICsgc3RlcHh5LnkgKiAzLjAsIHhwb3MsIGxpbmV0YXBzLCBTb3VyY2UpICogY29sdW1udGFwcy5hLDEpOwoKICAgRnJhZ0NvbG9yID0gZmluYWw7Cn0gCiNlbmRpZgo=\n",
            },
        ],
    },

    //https://github.com/libretro/glsl-shaders/blob/master/motionblur/mix_frames.glslp
    "mix-frames": {
        "shader": {
            "type": "text",
            "value": "shaders = \"1\"\n\nshader0 = \"mix_frames.glsl\"\nfilter_linear0 = \"false\"\n",
        },
        "resources": [
            {
                "name": "mix_frames.glsl",
                "type": "base64",
                "value": "LyoKCW1peF9mcmFtZXMgLSBwZXJmb3JtcyA1MDo1MCBibGVuZGluZyBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCBwcmV2aW91cwoJZnJhbWVzLgoJCglBdXRob3I6IGpkZ2xlYXZlcgoJCglUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdAoJdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUKCVNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlciB2ZXJzaW9uIDIgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikKCWFueSBsYXRlciB2ZXJzaW9uLgoqLwoKI2lmIGRlZmluZWQoVkVSVEVYKQoKI2lmIF9fVkVSU0lPTl9fID49IDEzMAojZGVmaW5lIENPTVBBVF9WQVJZSU5HIG91dAojZGVmaW5lIENPTVBBVF9BVFRSSUJVVEUgaW4KI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlCiNlbHNlCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgdmFyeWluZyAKI2RlZmluZSBDT01QQVRfQVRUUklCVVRFIGF0dHJpYnV0ZSAKI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlMkQKI2VuZGlmCgojaWZkZWYgR0xfRVMKI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdICiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTiBoaWdocAojZWxzZQojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04gbWVkaXVtcAojZW5kaWYKI2Vsc2UKI2RlZmluZSBDT01QQVRfUFJFQ0lTSU9OCiNlbmRpZgoKLyogQ09NUEFUSUJJTElUWQogICAtIEdMU0wgY29tcGlsZXJzCiovCgpDT01QQVRfQVRUUklCVVRFIENPTVBBVF9QUkVDSVNJT04gdmVjNCBWZXJ0ZXhDb29yZDsKQ09NUEFUX0FUVFJJQlVURSBDT01QQVRfUFJFQ0lTSU9OIHZlYzQgQ09MT1I7CkNPTVBBVF9BVFRSSUJVVEUgQ09NUEFUX1BSRUNJU0lPTiB2ZWM0IFRleENvb3JkOwpDT01QQVRfVkFSWUlORyBDT01QQVRfUFJFQ0lTSU9OIHZlYzQgQ09MMDsKQ09NUEFUX1ZBUllJTkcgQ09NUEFUX1BSRUNJU0lPTiB2ZWM0IFRFWDA7CgpDT01QQVRfUFJFQ0lTSU9OIHZlYzQgX29Qb3NpdGlvbjE7IAp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gbWF0NCBNVlBNYXRyaXg7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVEaXJlY3Rpb247CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiBpbnQgRnJhbWVDb3VudDsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgT3V0cHV0U2l6ZTsKdW5pZm9ybSBDT01QQVRfUFJFQ0lTSU9OIHZlYzIgVGV4dHVyZVNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIElucHV0U2l6ZTsKCnZvaWQgbWFpbigpCnsKCVRFWDAgPSBUZXhDb29yZCAqIDEuMDAwMTsKCWdsX1Bvc2l0aW9uID0gTVZQTWF0cml4ICogVmVydGV4Q29vcmQ7Cn0KCiNlbGlmIGRlZmluZWQoRlJBR01FTlQpCgojaWYgX19WRVJTSU9OX18gPj0gMTMwCiNkZWZpbmUgQ09NUEFUX1ZBUllJTkcgaW4KI2RlZmluZSBDT01QQVRfVEVYVFVSRSB0ZXh0dXJlCm91dCB2ZWM0IEZyYWdDb2xvcjsKI2Vsc2UKI2RlZmluZSBDT01QQVRfVkFSWUlORyB2YXJ5aW5nCiNkZWZpbmUgRnJhZ0NvbG9yIGdsX0ZyYWdDb2xvcgojZGVmaW5lIENPTVBBVF9URVhUVVJFIHRleHR1cmUyRAojZW5kaWYKCiNpZmRlZiBHTF9FUwojaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gKcHJlY2lzaW9uIGhpZ2hwIGZsb2F0OwojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04gaGlnaHAKI2Vsc2UKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CiNkZWZpbmUgQ09NUEFUX1BSRUNJU0lPTiBtZWRpdW1wCiNlbmRpZgojZWxzZQojZGVmaW5lIENPTVBBVF9QUkVDSVNJT04KI2VuZGlmCgp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lRGlyZWN0aW9uOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gaW50IEZyYW1lQ291bnQ7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIE91dHB1dFNpemU7CnVuaWZvcm0gQ09NUEFUX1BSRUNJU0lPTiB2ZWMyIFRleHR1cmVTaXplOwp1bmlmb3JtIENPTVBBVF9QUkVDSVNJT04gdmVjMiBJbnB1dFNpemU7CnVuaWZvcm0gc2FtcGxlcjJEIFRleHR1cmU7CnVuaWZvcm0gc2FtcGxlcjJEIFByZXZUZXh0dXJlOwpDT01QQVRfVkFSWUlORyBDT01QQVRfUFJFQ0lTSU9OIHZlYzQgVEVYMDsKCnZvaWQgbWFpbigpCnsKCS8vIEdldCBjb2xvdXIgb2YgY3VycmVudCBwaXhlbAoJQ09NUEFUX1BSRUNJU0lPTiB2ZWMzIGNvbG91ciA9IENPTVBBVF9URVhUVVJFKFRleHR1cmUsIFRFWDAueHkpLnJnYjsKCQoJLy8gR2V0IGNvbG91ciBvZiBwcmV2aW91cyBwaXhlbAoJQ09NUEFUX1BSRUNJU0lPTiB2ZWMzIGNvbG91clByZXYgPSBDT01QQVRfVEVYVFVSRShQcmV2VGV4dHVyZSwgVEVYMC54eSkucmdiOwoJCgkvLyBNaXggY29sb3VycwoJY29sb3VyLnJnYiA9IG1peChjb2xvdXIucmdiLCBjb2xvdXJQcmV2LnJnYiwgMC41KTsKCQoJZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvdXIucmdiLCAxLjApOwp9CiNlbmRpZgo=",
            }
        ],
    },

};

/*!
 * Socket.IO v4.8.1
 * (c) 2014-2024 Guillermo Rauch
 * Released under the MIT License.
 */
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(t="undefined"!=typeof globalThis?globalThis:t||self).io=n()}(this,(function(){"use strict";function t(t,n){(null==n||n>t.length)&&(n=t.length);for(var i=0,r=Array(n);i<n;i++)r[i]=t[i];return r}function n(t,n){for(var i=0;i<n.length;i++){var r=n[i];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,f(r.key),r)}}function i(t,i,r){return i&&n(t.prototype,i),r&&n(t,r),Object.defineProperty(t,"prototype",{writable:!1}),t}function r(n,i){var r="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!r){if(Array.isArray(n)||(r=function(n,i){if(n){if("string"==typeof n)return t(n,i);var r={}.toString.call(n).slice(8,-1);return"Object"===r&&n.constructor&&(r=n.constructor.name),"Map"===r||"Set"===r?Array.from(n):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?t(n,i):void 0}}(n))||i&&n&&"number"==typeof n.length){r&&(n=r);var e=0,o=function(){};return{s:o,n:function(){return e>=n.length?{done:!0}:{done:!1,value:n[e++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,u=!0,h=!1;return{s:function(){r=r.call(n)},n:function(){var t=r.next();return u=t.done,t},e:function(t){h=!0,s=t},f:function(){try{u||null==r.return||r.return()}finally{if(h)throw s}}}}function e(){return e=Object.assign?Object.assign.bind():function(t){for(var n=1;n<arguments.length;n++){var i=arguments[n];for(var r in i)({}).hasOwnProperty.call(i,r)&&(t[r]=i[r])}return t},e.apply(null,arguments)}function o(t){return o=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},o(t)}function s(t,n){t.prototype=Object.create(n.prototype),t.prototype.constructor=t,h(t,n)}function u(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(u=function(){return!!t})()}function h(t,n){return h=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,n){return t.__proto__=n,t},h(t,n)}function f(t){var n=function(t,n){if("object"!=typeof t||!t)return t;var i=t[Symbol.toPrimitive];if(void 0!==i){var r=i.call(t,n||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===n?String:Number)(t)}(t,"string");return"symbol"==typeof n?n:n+""}function c(t){return c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},c(t)}function a(t){var n="function"==typeof Map?new Map:void 0;return a=function(t){if(null===t||!function(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}catch(n){return"function"==typeof t}}(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==n){if(n.has(t))return n.get(t);n.set(t,i)}function i(){return function(t,n,i){if(u())return Reflect.construct.apply(null,arguments);var r=[null];r.push.apply(r,n);var e=new(t.bind.apply(t,r));return i&&h(e,i.prototype),e}(t,arguments,o(this).constructor)}return i.prototype=Object.create(t.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),h(i,t)},a(t)}var v=Object.create(null);v.open="0",v.close="1",v.ping="2",v.pong="3",v.message="4",v.upgrade="5",v.noop="6";var l=Object.create(null);Object.keys(v).forEach((function(t){l[v[t]]=t}));var p,d={type:"error",data:"parser error"},y="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===Object.prototype.toString.call(Blob),b="function"==typeof ArrayBuffer,w=function(t){return"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(t):t&&t.buffer instanceof ArrayBuffer},g=function(t,n,i){var r=t.type,e=t.data;return y&&e instanceof Blob?n?i(e):m(e,i):b&&(e instanceof ArrayBuffer||w(e))?n?i(e):m(new Blob([e]),i):i(v[r]+(e||""))},m=function(t,n){var i=new FileReader;return i.onload=function(){var t=i.result.split(",")[1];n("b"+(t||""))},i.readAsDataURL(t)};function k(t){return t instanceof Uint8Array?t:t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}for(var A="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",j="undefined"==typeof Uint8Array?[]:new Uint8Array(256),E=0;E<64;E++)j[A.charCodeAt(E)]=E;var O,B="function"==typeof ArrayBuffer,S=function(t,n){if("string"!=typeof t)return{type:"message",data:C(t,n)};var i=t.charAt(0);return"b"===i?{type:"message",data:N(t.substring(1),n)}:l[i]?t.length>1?{type:l[i],data:t.substring(1)}:{type:l[i]}:d},N=function(t,n){if(B){var i=function(t){var n,i,r,e,o,s=.75*t.length,u=t.length,h=0;"="===t[t.length-1]&&(s--,"="===t[t.length-2]&&s--);var f=new ArrayBuffer(s),c=new Uint8Array(f);for(n=0;n<u;n+=4)i=j[t.charCodeAt(n)],r=j[t.charCodeAt(n+1)],e=j[t.charCodeAt(n+2)],o=j[t.charCodeAt(n+3)],c[h++]=i<<2|r>>4,c[h++]=(15&r)<<4|e>>2,c[h++]=(3&e)<<6|63&o;return f}(t);return C(i,n)}return{base64:!0,data:t}},C=function(t,n){return"blob"===n?t instanceof Blob?t:new Blob([t]):t instanceof ArrayBuffer?t:t.buffer},T=String.fromCharCode(30);function U(){return new TransformStream({transform:function(t,n){!function(t,n){y&&t.data instanceof Blob?t.data.arrayBuffer().then(k).then(n):b&&(t.data instanceof ArrayBuffer||w(t.data))?n(k(t.data)):g(t,!1,(function(t){p||(p=new TextEncoder),n(p.encode(t))}))}(t,(function(i){var r,e=i.length;if(e<126)r=new Uint8Array(1),new DataView(r.buffer).setUint8(0,e);else if(e<65536){r=new Uint8Array(3);var o=new DataView(r.buffer);o.setUint8(0,126),o.setUint16(1,e)}else{r=new Uint8Array(9);var s=new DataView(r.buffer);s.setUint8(0,127),s.setBigUint64(1,BigInt(e))}t.data&&"string"!=typeof t.data&&(r[0]|=128),n.enqueue(r),n.enqueue(i)}))}})}function M(t){return t.reduce((function(t,n){return t+n.length}),0)}function x(t,n){if(t[0].length===n)return t.shift();for(var i=new Uint8Array(n),r=0,e=0;e<n;e++)i[e]=t[0][r++],r===t[0].length&&(t.shift(),r=0);return t.length&&r<t[0].length&&(t[0]=t[0].slice(r)),i}function I(t){if(t)return function(t){for(var n in I.prototype)t[n]=I.prototype[n];return t}(t)}I.prototype.on=I.prototype.addEventListener=function(t,n){return this.t=this.t||{},(this.t["$"+t]=this.t["$"+t]||[]).push(n),this},I.prototype.once=function(t,n){function i(){this.off(t,i),n.apply(this,arguments)}return i.fn=n,this.on(t,i),this},I.prototype.off=I.prototype.removeListener=I.prototype.removeAllListeners=I.prototype.removeEventListener=function(t,n){if(this.t=this.t||{},0==arguments.length)return this.t={},this;var i,r=this.t["$"+t];if(!r)return this;if(1==arguments.length)return delete this.t["$"+t],this;for(var e=0;e<r.length;e++)if((i=r[e])===n||i.fn===n){r.splice(e,1);break}return 0===r.length&&delete this.t["$"+t],this},I.prototype.emit=function(t){this.t=this.t||{};for(var n=new Array(arguments.length-1),i=this.t["$"+t],r=1;r<arguments.length;r++)n[r-1]=arguments[r];if(i){r=0;for(var e=(i=i.slice(0)).length;r<e;++r)i[r].apply(this,n)}return this},I.prototype.emitReserved=I.prototype.emit,I.prototype.listeners=function(t){return this.t=this.t||{},this.t["$"+t]||[]},I.prototype.hasListeners=function(t){return!!this.listeners(t).length};var R="function"==typeof Promise&&"function"==typeof Promise.resolve?function(t){return Promise.resolve().then(t)}:function(t,n){return n(t,0)},L="undefined"!=typeof self?self:"undefined"!=typeof window?window:Function("return this")();function _(t){for(var n=arguments.length,i=new Array(n>1?n-1:0),r=1;r<n;r++)i[r-1]=arguments[r];return i.reduce((function(n,i){return t.hasOwnProperty(i)&&(n[i]=t[i]),n}),{})}var D=L.setTimeout,P=L.clearTimeout;function $(t,n){n.useNativeTimers?(t.setTimeoutFn=D.bind(L),t.clearTimeoutFn=P.bind(L)):(t.setTimeoutFn=L.setTimeout.bind(L),t.clearTimeoutFn=L.clearTimeout.bind(L))}function F(){return Date.now().toString(36).substring(3)+Math.random().toString(36).substring(2,5)}var V=function(t){function n(n,i,r){var e;return(e=t.call(this,n)||this).description=i,e.context=r,e.type="TransportError",e}return s(n,t),n}(a(Error)),q=function(t){function n(n){var i;return(i=t.call(this)||this).writable=!1,$(i,n),i.opts=n,i.query=n.query,i.socket=n.socket,i.supportsBinary=!n.forceBase64,i}s(n,t);var i=n.prototype;return i.onError=function(n,i,r){return t.prototype.emitReserved.call(this,"error",new V(n,i,r)),this},i.open=function(){return this.readyState="opening",this.doOpen(),this},i.close=function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this},i.send=function(t){"open"===this.readyState&&this.write(t)},i.onOpen=function(){this.readyState="open",this.writable=!0,t.prototype.emitReserved.call(this,"open")},i.onData=function(t){var n=S(t,this.socket.binaryType);this.onPacket(n)},i.onPacket=function(n){t.prototype.emitReserved.call(this,"packet",n)},i.onClose=function(n){this.readyState="closed",t.prototype.emitReserved.call(this,"close",n)},i.pause=function(t){},i.createUri=function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t+"://"+this.i()+this.o()+this.opts.path+this.u(n)},i.i=function(){var t=this.opts.hostname;return-1===t.indexOf(":")?t:"["+t+"]"},i.o=function(){return this.opts.port&&(this.opts.secure&&Number(443!==this.opts.port)||!this.opts.secure&&80!==Number(this.opts.port))?":"+this.opts.port:""},i.u=function(t){var n=function(t){var n="";for(var i in t)t.hasOwnProperty(i)&&(n.length&&(n+="&"),n+=encodeURIComponent(i)+"="+encodeURIComponent(t[i]));return n}(t);return n.length?"?"+n:""},n}(I),X=function(t){function n(){var n;return(n=t.apply(this,arguments)||this).h=!1,n}s(n,t);var r=n.prototype;return r.doOpen=function(){this.v()},r.pause=function(t){var n=this;this.readyState="pausing";var i=function(){n.readyState="paused",t()};if(this.h||!this.writable){var r=0;this.h&&(r++,this.once("pollComplete",(function(){--r||i()}))),this.writable||(r++,this.once("drain",(function(){--r||i()})))}else i()},r.v=function(){this.h=!0,this.doPoll(),this.emitReserved("poll")},r.onData=function(t){var n=this;(function(t,n){for(var i=t.split(T),r=[],e=0;e<i.length;e++){var o=S(i[e],n);if(r.push(o),"error"===o.type)break}return r})(t,this.socket.binaryType).forEach((function(t){if("opening"===n.readyState&&"open"===t.type&&n.onOpen(),"close"===t.type)return n.onClose({description:"transport closed by the server"}),!1;n.onPacket(t)})),"closed"!==this.readyState&&(this.h=!1,this.emitReserved("pollComplete"),"open"===this.readyState&&this.v())},r.doClose=function(){var t=this,n=function(){t.write([{type:"close"}])};"open"===this.readyState?n():this.once("open",n)},r.write=function(t){var n=this;this.writable=!1,function(t,n){var i=t.length,r=new Array(i),e=0;t.forEach((function(t,o){g(t,!1,(function(t){r[o]=t,++e===i&&n(r.join(T))}))}))}(t,(function(t){n.doWrite(t,(function(){n.writable=!0,n.emitReserved("drain")}))}))},r.uri=function(){var t=this.opts.secure?"https":"http",n=this.query||{};return!1!==this.opts.timestampRequests&&(n[this.opts.timestampParam]=F()),this.supportsBinary||n.sid||(n.b64=1),this.createUri(t,n)},i(n,[{key:"name",get:function(){return"polling"}}])}(q),H=!1;try{H="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(t){}var z=H;function J(){}var K=function(t){function n(n){var i;if(i=t.call(this,n)||this,"undefined"!=typeof location){var r="https:"===location.protocol,e=location.port;e||(e=r?"443":"80"),i.xd="undefined"!=typeof location&&n.hostname!==location.hostname||e!==n.port}return i}s(n,t);var i=n.prototype;return i.doWrite=function(t,n){var i=this,r=this.request({method:"POST",data:t});r.on("success",n),r.on("error",(function(t,n){i.onError("xhr post error",t,n)}))},i.doPoll=function(){var t=this,n=this.request();n.on("data",this.onData.bind(this)),n.on("error",(function(n,i){t.onError("xhr poll error",n,i)})),this.pollXhr=n},n}(X),Y=function(t){function n(n,i,r){var e;return(e=t.call(this)||this).createRequest=n,$(e,r),e.l=r,e.p=r.method||"GET",e.m=i,e.k=void 0!==r.data?r.data:null,e.A(),e}s(n,t);var i=n.prototype;return i.A=function(){var t,i=this,r=_(this.l,"agent","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","autoUnref");r.xdomain=!!this.l.xd;var e=this.j=this.createRequest(r);try{e.open(this.p,this.m,!0);try{if(this.l.extraHeaders)for(var o in e.setDisableHeaderCheck&&e.setDisableHeaderCheck(!0),this.l.extraHeaders)this.l.extraHeaders.hasOwnProperty(o)&&e.setRequestHeader(o,this.l.extraHeaders[o])}catch(t){}if("POST"===this.p)try{e.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(t){}try{e.setRequestHeader("Accept","*/*")}catch(t){}null===(t=this.l.cookieJar)||void 0===t||t.addCookies(e),"withCredentials"in e&&(e.withCredentials=this.l.withCredentials),this.l.requestTimeout&&(e.timeout=this.l.requestTimeout),e.onreadystatechange=function(){var t;3===e.readyState&&(null===(t=i.l.cookieJar)||void 0===t||t.parseCookies(e.getResponseHeader("set-cookie"))),4===e.readyState&&(200===e.status||1223===e.status?i.O():i.setTimeoutFn((function(){i.B("number"==typeof e.status?e.status:0)}),0))},e.send(this.k)}catch(t){return void this.setTimeoutFn((function(){i.B(t)}),0)}"undefined"!=typeof document&&(this.S=n.requestsCount++,n.requests[this.S]=this)},i.B=function(t){this.emitReserved("error",t,this.j),this.N(!0)},i.N=function(t){if(void 0!==this.j&&null!==this.j){if(this.j.onreadystatechange=J,t)try{this.j.abort()}catch(t){}"undefined"!=typeof document&&delete n.requests[this.S],this.j=null}},i.O=function(){var t=this.j.responseText;null!==t&&(this.emitReserved("data",t),this.emitReserved("success"),this.N())},i.abort=function(){this.N()},n}(I);if(Y.requestsCount=0,Y.requests={},"undefined"!=typeof document)if("function"==typeof attachEvent)attachEvent("onunload",G);else if("function"==typeof addEventListener){addEventListener("onpagehide"in L?"pagehide":"unload",G,!1)}function G(){for(var t in Y.requests)Y.requests.hasOwnProperty(t)&&Y.requests[t].abort()}var Q,W=(Q=tt({xdomain:!1}))&&null!==Q.responseType,Z=function(t){function n(n){var i;i=t.call(this,n)||this;var r=n&&n.forceBase64;return i.supportsBinary=W&&!r,i}return s(n,t),n.prototype.request=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e(t,{xd:this.xd},this.opts),new Y(tt,this.uri(),t)},n}(K);function tt(t){var n=t.xdomain;try{if("undefined"!=typeof XMLHttpRequest&&(!n||z))return new XMLHttpRequest}catch(t){}if(!n)try{return new(L[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(t){}}var nt="undefined"!=typeof navigator&&"string"==typeof navigator.product&&"reactnative"===navigator.product.toLowerCase(),it=function(t){function n(){return t.apply(this,arguments)||this}s(n,t);var r=n.prototype;return r.doOpen=function(){var t=this.uri(),n=this.opts.protocols,i=nt?{}:_(this.opts,"agent","perMessageDeflate","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","localAddress","protocolVersion","origin","maxPayload","family","checkServerIdentity");this.opts.extraHeaders&&(i.headers=this.opts.extraHeaders);try{this.ws=this.createSocket(t,n,i)}catch(t){return this.emitReserved("error",t)}this.ws.binaryType=this.socket.binaryType,this.addEventListeners()},r.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.opts.autoUnref&&t.ws.C.unref(),t.onOpen()},this.ws.onclose=function(n){return t.onClose({description:"websocket connection closed",context:n})},this.ws.onmessage=function(n){return t.onData(n.data)},this.ws.onerror=function(n){return t.onError("websocket error",n)}},r.write=function(t){var n=this;this.writable=!1;for(var i=function(){var i=t[r],e=r===t.length-1;g(i,n.supportsBinary,(function(t){try{n.doWrite(i,t)}catch(t){}e&&R((function(){n.writable=!0,n.emitReserved("drain")}),n.setTimeoutFn)}))},r=0;r<t.length;r++)i()},r.doClose=function(){void 0!==this.ws&&(this.ws.onerror=function(){},this.ws.close(),this.ws=null)},r.uri=function(){var t=this.opts.secure?"wss":"ws",n=this.query||{};return this.opts.timestampRequests&&(n[this.opts.timestampParam]=F()),this.supportsBinary||(n.b64=1),this.createUri(t,n)},i(n,[{key:"name",get:function(){return"websocket"}}])}(q),rt=L.WebSocket||L.MozWebSocket,et=function(t){function n(){return t.apply(this,arguments)||this}s(n,t);var i=n.prototype;return i.createSocket=function(t,n,i){return nt?new rt(t,n,i):n?new rt(t,n):new rt(t)},i.doWrite=function(t,n){this.ws.send(n)},n}(it),ot=function(t){function n(){return t.apply(this,arguments)||this}s(n,t);var r=n.prototype;return r.doOpen=function(){var t=this;try{this.T=new WebTransport(this.createUri("https"),this.opts.transportOptions[this.name])}catch(t){return this.emitReserved("error",t)}this.T.closed.then((function(){t.onClose()})).catch((function(n){t.onError("webtransport error",n)})),this.T.ready.then((function(){t.T.createBidirectionalStream().then((function(n){var i=function(t,n){O||(O=new TextDecoder);var i=[],r=0,e=-1,o=!1;return new TransformStream({transform:function(s,u){for(i.push(s);;){if(0===r){if(M(i)<1)break;var h=x(i,1);o=!(128&~h[0]),e=127&h[0],r=e<126?3:126===e?1:2}else if(1===r){if(M(i)<2)break;var f=x(i,2);e=new DataView(f.buffer,f.byteOffset,f.length).getUint16(0),r=3}else if(2===r){if(M(i)<8)break;var c=x(i,8),a=new DataView(c.buffer,c.byteOffset,c.length),v=a.getUint32(0);if(v>Math.pow(2,21)-1){u.enqueue(d);break}e=v*Math.pow(2,32)+a.getUint32(4),r=3}else{if(M(i)<e)break;var l=x(i,e);u.enqueue(S(o?l:O.decode(l),n)),r=0}if(0===e||e>t){u.enqueue(d);break}}}})}(Number.MAX_SAFE_INTEGER,t.socket.binaryType),r=n.readable.pipeThrough(i).getReader(),e=U();e.readable.pipeTo(n.writable),t.U=e.writable.getWriter();!function n(){r.read().then((function(i){var r=i.done,e=i.value;r||(t.onPacket(e),n())})).catch((function(t){}))}();var o={type:"open"};t.query.sid&&(o.data='{"sid":"'.concat(t.query.sid,'"}')),t.U.write(o).then((function(){return t.onOpen()}))}))}))},r.write=function(t){var n=this;this.writable=!1;for(var i=function(){var i=t[r],e=r===t.length-1;n.U.write(i).then((function(){e&&R((function(){n.writable=!0,n.emitReserved("drain")}),n.setTimeoutFn)}))},r=0;r<t.length;r++)i()},r.doClose=function(){var t;null===(t=this.T)||void 0===t||t.close()},i(n,[{key:"name",get:function(){return"webtransport"}}])}(q),st={websocket:et,webtransport:ot,polling:Z},ut=/^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,ht=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];function ft(t){if(t.length>8e3)throw"URI too long";var n=t,i=t.indexOf("["),r=t.indexOf("]");-1!=i&&-1!=r&&(t=t.substring(0,i)+t.substring(i,r).replace(/:/g,";")+t.substring(r,t.length));for(var e,o,s=ut.exec(t||""),u={},h=14;h--;)u[ht[h]]=s[h]||"";return-1!=i&&-1!=r&&(u.source=n,u.host=u.host.substring(1,u.host.length-1).replace(/;/g,":"),u.authority=u.authority.replace("[","").replace("]","").replace(/;/g,":"),u.ipv6uri=!0),u.pathNames=function(t,n){var i=/\/{2,9}/g,r=n.replace(i,"/").split("/");"/"!=n.slice(0,1)&&0!==n.length||r.splice(0,1);"/"==n.slice(-1)&&r.splice(r.length-1,1);return r}(0,u.path),u.queryKey=(e=u.query,o={},e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g,(function(t,n,i){n&&(o[n]=i)})),o),u}var ct="function"==typeof addEventListener&&"function"==typeof removeEventListener,at=[];ct&&addEventListener("offline",(function(){at.forEach((function(t){return t()}))}),!1);var vt=function(t){function n(n,i){var r;if((r=t.call(this)||this).binaryType="arraybuffer",r.writeBuffer=[],r.M=0,r.I=-1,r.R=-1,r.L=-1,r._=1/0,n&&"object"===c(n)&&(i=n,n=null),n){var o=ft(n);i.hostname=o.host,i.secure="https"===o.protocol||"wss"===o.protocol,i.port=o.port,o.query&&(i.query=o.query)}else i.host&&(i.hostname=ft(i.host).host);return $(r,i),r.secure=null!=i.secure?i.secure:"undefined"!=typeof location&&"https:"===location.protocol,i.hostname&&!i.port&&(i.port=r.secure?"443":"80"),r.hostname=i.hostname||("undefined"!=typeof location?location.hostname:"localhost"),r.port=i.port||("undefined"!=typeof location&&location.port?location.port:r.secure?"443":"80"),r.transports=[],r.D={},i.transports.forEach((function(t){var n=t.prototype.name;r.transports.push(n),r.D[n]=t})),r.opts=e({path:"/engine.io",agent:!1,withCredentials:!1,upgrade:!0,timestampParam:"t",rememberUpgrade:!1,addTrailingSlash:!0,rejectUnauthorized:!0,perMessageDeflate:{threshold:1024},transportOptions:{},closeOnBeforeunload:!1},i),r.opts.path=r.opts.path.replace(/\/$/,"")+(r.opts.addTrailingSlash?"/":""),"string"==typeof r.opts.query&&(r.opts.query=function(t){for(var n={},i=t.split("&"),r=0,e=i.length;r<e;r++){var o=i[r].split("=");n[decodeURIComponent(o[0])]=decodeURIComponent(o[1])}return n}(r.opts.query)),ct&&(r.opts.closeOnBeforeunload&&(r.P=function(){r.transport&&(r.transport.removeAllListeners(),r.transport.close())},addEventListener("beforeunload",r.P,!1)),"localhost"!==r.hostname&&(r.$=function(){r.F("transport close",{description:"network connection lost"})},at.push(r.$))),r.opts.withCredentials&&(r.V=void 0),r.q(),r}s(n,t);var i=n.prototype;return i.createTransport=function(t){var n=e({},this.opts.query);n.EIO=4,n.transport=t,this.id&&(n.sid=this.id);var i=e({},this.opts,{query:n,socket:this,hostname:this.hostname,secure:this.secure,port:this.port},this.opts.transportOptions[t]);return new this.D[t](i)},i.q=function(){var t=this;if(0!==this.transports.length){var i=this.opts.rememberUpgrade&&n.priorWebsocketSuccess&&-1!==this.transports.indexOf("websocket")?"websocket":this.transports[0];this.readyState="opening";var r=this.createTransport(i);r.open(),this.setTransport(r)}else this.setTimeoutFn((function(){t.emitReserved("error","No transports available")}),0)},i.setTransport=function(t){var n=this;this.transport&&this.transport.removeAllListeners(),this.transport=t,t.on("drain",this.X.bind(this)).on("packet",this.H.bind(this)).on("error",this.B.bind(this)).on("close",(function(t){return n.F("transport close",t)}))},i.onOpen=function(){this.readyState="open",n.priorWebsocketSuccess="websocket"===this.transport.name,this.emitReserved("open"),this.flush()},i.H=function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(this.emitReserved("packet",t),this.emitReserved("heartbeat"),t.type){case"open":this.onHandshake(JSON.parse(t.data));break;case"ping":this.J("pong"),this.emitReserved("ping"),this.emitReserved("pong"),this.K();break;case"error":var n=new Error("server error");n.code=t.data,this.B(n);break;case"message":this.emitReserved("data",t.data),this.emitReserved("message",t.data)}},i.onHandshake=function(t){this.emitReserved("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.I=t.pingInterval,this.R=t.pingTimeout,this.L=t.maxPayload,this.onOpen(),"closed"!==this.readyState&&this.K()},i.K=function(){var t=this;this.clearTimeoutFn(this.Y);var n=this.I+this.R;this._=Date.now()+n,this.Y=this.setTimeoutFn((function(){t.F("ping timeout")}),n),this.opts.autoUnref&&this.Y.unref()},i.X=function(){this.writeBuffer.splice(0,this.M),this.M=0,0===this.writeBuffer.length?this.emitReserved("drain"):this.flush()},i.flush=function(){if("closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length){var t=this.G();this.transport.send(t),this.M=t.length,this.emitReserved("flush")}},i.G=function(){if(!(this.L&&"polling"===this.transport.name&&this.writeBuffer.length>1))return this.writeBuffer;for(var t,n=1,i=0;i<this.writeBuffer.length;i++){var r=this.writeBuffer[i].data;if(r&&(n+="string"==typeof(t=r)?function(t){for(var n=0,i=0,r=0,e=t.length;r<e;r++)(n=t.charCodeAt(r))<128?i+=1:n<2048?i+=2:n<55296||n>=57344?i+=3:(r++,i+=4);return i}(t):Math.ceil(1.33*(t.byteLength||t.size))),i>0&&n>this.L)return this.writeBuffer.slice(0,i);n+=2}return this.writeBuffer},i.W=function(){var t=this;if(!this._)return!0;var n=Date.now()>this._;return n&&(this._=0,R((function(){t.F("ping timeout")}),this.setTimeoutFn)),n},i.write=function(t,n,i){return this.J("message",t,n,i),this},i.send=function(t,n,i){return this.J("message",t,n,i),this},i.J=function(t,n,i,r){if("function"==typeof n&&(r=n,n=void 0),"function"==typeof i&&(r=i,i=null),"closing"!==this.readyState&&"closed"!==this.readyState){(i=i||{}).compress=!1!==i.compress;var e={type:t,data:n,options:i};this.emitReserved("packetCreate",e),this.writeBuffer.push(e),r&&this.once("flush",r),this.flush()}},i.close=function(){var t=this,n=function(){t.F("forced close"),t.transport.close()},i=function i(){t.off("upgrade",i),t.off("upgradeError",i),n()},r=function(){t.once("upgrade",i),t.once("upgradeError",i)};return"opening"!==this.readyState&&"open"!==this.readyState||(this.readyState="closing",this.writeBuffer.length?this.once("drain",(function(){t.upgrading?r():n()})):this.upgrading?r():n()),this},i.B=function(t){if(n.priorWebsocketSuccess=!1,this.opts.tryAllTransports&&this.transports.length>1&&"opening"===this.readyState)return this.transports.shift(),this.q();this.emitReserved("error",t),this.F("transport error",t)},i.F=function(t,n){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){if(this.clearTimeoutFn(this.Y),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),ct&&(this.P&&removeEventListener("beforeunload",this.P,!1),this.$)){var i=at.indexOf(this.$);-1!==i&&at.splice(i,1)}this.readyState="closed",this.id=null,this.emitReserved("close",t,n),this.writeBuffer=[],this.M=0}},n}(I);vt.protocol=4;var lt=function(t){function n(){var n;return(n=t.apply(this,arguments)||this).Z=[],n}s(n,t);var i=n.prototype;return i.onOpen=function(){if(t.prototype.onOpen.call(this),"open"===this.readyState&&this.opts.upgrade)for(var n=0;n<this.Z.length;n++)this.tt(this.Z[n])},i.tt=function(t){var n=this,i=this.createTransport(t),r=!1;vt.priorWebsocketSuccess=!1;var e=function(){r||(i.send([{type:"ping",data:"probe"}]),i.once("packet",(function(t){if(!r)if("pong"===t.type&&"probe"===t.data){if(n.upgrading=!0,n.emitReserved("upgrading",i),!i)return;vt.priorWebsocketSuccess="websocket"===i.name,n.transport.pause((function(){r||"closed"!==n.readyState&&(c(),n.setTransport(i),i.send([{type:"upgrade"}]),n.emitReserved("upgrade",i),i=null,n.upgrading=!1,n.flush())}))}else{var e=new Error("probe error");e.transport=i.name,n.emitReserved("upgradeError",e)}})))};function o(){r||(r=!0,c(),i.close(),i=null)}var s=function(t){var r=new Error("probe error: "+t);r.transport=i.name,o(),n.emitReserved("upgradeError",r)};function u(){s("transport closed")}function h(){s("socket closed")}function f(t){i&&t.name!==i.name&&o()}var c=function(){i.removeListener("open",e),i.removeListener("error",s),i.removeListener("close",u),n.off("close",h),n.off("upgrading",f)};i.once("open",e),i.once("error",s),i.once("close",u),this.once("close",h),this.once("upgrading",f),-1!==this.Z.indexOf("webtransport")&&"webtransport"!==t?this.setTimeoutFn((function(){r||i.open()}),200):i.open()},i.onHandshake=function(n){this.Z=this.nt(n.upgrades),t.prototype.onHandshake.call(this,n)},i.nt=function(t){for(var n=[],i=0;i<t.length;i++)~this.transports.indexOf(t[i])&&n.push(t[i]);return n},n}(vt),pt=function(t){function n(n){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r="object"===c(n)?n:i;return(!r.transports||r.transports&&"string"==typeof r.transports[0])&&(r.transports=(r.transports||["polling","websocket","webtransport"]).map((function(t){return st[t]})).filter((function(t){return!!t}))),t.call(this,n,r)||this}return s(n,t),n}(lt);pt.protocol;var dt="function"==typeof ArrayBuffer,yt=function(t){return"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(t):t.buffer instanceof ArrayBuffer},bt=Object.prototype.toString,wt="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===bt.call(Blob),gt="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===bt.call(File);function mt(t){return dt&&(t instanceof ArrayBuffer||yt(t))||wt&&t instanceof Blob||gt&&t instanceof File}function kt(t,n){if(!t||"object"!==c(t))return!1;if(Array.isArray(t)){for(var i=0,r=t.length;i<r;i++)if(kt(t[i]))return!0;return!1}if(mt(t))return!0;if(t.toJSON&&"function"==typeof t.toJSON&&1===arguments.length)return kt(t.toJSON(),!0);for(var e in t)if(Object.prototype.hasOwnProperty.call(t,e)&&kt(t[e]))return!0;return!1}function At(t){var n=[],i=t.data,r=t;return r.data=jt(i,n),r.attachments=n.length,{packet:r,buffers:n}}function jt(t,n){if(!t)return t;if(mt(t)){var i={_placeholder:!0,num:n.length};return n.push(t),i}if(Array.isArray(t)){for(var r=new Array(t.length),e=0;e<t.length;e++)r[e]=jt(t[e],n);return r}if("object"===c(t)&&!(t instanceof Date)){var o={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(o[s]=jt(t[s],n));return o}return t}function Et(t,n){return t.data=Ot(t.data,n),delete t.attachments,t}function Ot(t,n){if(!t)return t;if(t&&!0===t._placeholder){if("number"==typeof t.num&&t.num>=0&&t.num<n.length)return n[t.num];throw new Error("illegal attachments")}if(Array.isArray(t))for(var i=0;i<t.length;i++)t[i]=Ot(t[i],n);else if("object"===c(t))for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(t[r]=Ot(t[r],n));return t}var Bt,St=["connect","connect_error","disconnect","disconnecting","newListener","removeListener"];!function(t){t[t.CONNECT=0]="CONNECT",t[t.DISCONNECT=1]="DISCONNECT",t[t.EVENT=2]="EVENT",t[t.ACK=3]="ACK",t[t.CONNECT_ERROR=4]="CONNECT_ERROR",t[t.BINARY_EVENT=5]="BINARY_EVENT",t[t.BINARY_ACK=6]="BINARY_ACK"}(Bt||(Bt={}));var Nt=function(){function t(t){this.replacer=t}var n=t.prototype;return n.encode=function(t){return t.type!==Bt.EVENT&&t.type!==Bt.ACK||!kt(t)?[this.encodeAsString(t)]:this.encodeAsBinary({type:t.type===Bt.EVENT?Bt.BINARY_EVENT:Bt.BINARY_ACK,nsp:t.nsp,data:t.data,id:t.id})},n.encodeAsString=function(t){var n=""+t.type;return t.type!==Bt.BINARY_EVENT&&t.type!==Bt.BINARY_ACK||(n+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(n+=t.nsp+","),null!=t.id&&(n+=t.id),null!=t.data&&(n+=JSON.stringify(t.data,this.replacer)),n},n.encodeAsBinary=function(t){var n=At(t),i=this.encodeAsString(n.packet),r=n.buffers;return r.unshift(i),r},t}(),Ct=function(t){function n(n){var i;return(i=t.call(this)||this).reviver=n,i}s(n,t);var i=n.prototype;return i.add=function(n){var i;if("string"==typeof n){if(this.reconstructor)throw new Error("got plaintext data when reconstructing a packet");var r=(i=this.decodeString(n)).type===Bt.BINARY_EVENT;r||i.type===Bt.BINARY_ACK?(i.type=r?Bt.EVENT:Bt.ACK,this.reconstructor=new Tt(i),0===i.attachments&&t.prototype.emitReserved.call(this,"decoded",i)):t.prototype.emitReserved.call(this,"decoded",i)}else{if(!mt(n)&&!n.base64)throw new Error("Unknown type: "+n);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");(i=this.reconstructor.takeBinaryData(n))&&(this.reconstructor=null,t.prototype.emitReserved.call(this,"decoded",i))}},i.decodeString=function(t){var i=0,r={type:Number(t.charAt(0))};if(void 0===Bt[r.type])throw new Error("unknown packet type "+r.type);if(r.type===Bt.BINARY_EVENT||r.type===Bt.BINARY_ACK){for(var e=i+1;"-"!==t.charAt(++i)&&i!=t.length;);var o=t.substring(e,i);if(o!=Number(o)||"-"!==t.charAt(i))throw new Error("Illegal attachments");r.attachments=Number(o)}if("/"===t.charAt(i+1)){for(var s=i+1;++i;){if(","===t.charAt(i))break;if(i===t.length)break}r.nsp=t.substring(s,i)}else r.nsp="/";var u=t.charAt(i+1);if(""!==u&&Number(u)==u){for(var h=i+1;++i;){var f=t.charAt(i);if(null==f||Number(f)!=f){--i;break}if(i===t.length)break}r.id=Number(t.substring(h,i+1))}if(t.charAt(++i)){var c=this.tryParse(t.substr(i));if(!n.isPayloadValid(r.type,c))throw new Error("invalid payload");r.data=c}return r},i.tryParse=function(t){try{return JSON.parse(t,this.reviver)}catch(t){return!1}},n.isPayloadValid=function(t,n){switch(t){case Bt.CONNECT:return Mt(n);case Bt.DISCONNECT:return void 0===n;case Bt.CONNECT_ERROR:return"string"==typeof n||Mt(n);case Bt.EVENT:case Bt.BINARY_EVENT:return Array.isArray(n)&&("number"==typeof n[0]||"string"==typeof n[0]&&-1===St.indexOf(n[0]));case Bt.ACK:case Bt.BINARY_ACK:return Array.isArray(n)}},i.destroy=function(){this.reconstructor&&(this.reconstructor.finishedReconstruction(),this.reconstructor=null)},n}(I),Tt=function(){function t(t){this.packet=t,this.buffers=[],this.reconPack=t}var n=t.prototype;return n.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var n=Et(this.reconPack,this.buffers);return this.finishedReconstruction(),n}return null},n.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]},t}();var Ut=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t};function Mt(t){return"[object Object]"===Object.prototype.toString.call(t)}var xt=Object.freeze({__proto__:null,protocol:5,get PacketType(){return Bt},Encoder:Nt,Decoder:Ct,isPacketValid:function(t){return"string"==typeof t.nsp&&(void 0===(n=t.id)||Ut(n))&&function(t,n){switch(t){case Bt.CONNECT:return void 0===n||Mt(n);case Bt.DISCONNECT:return void 0===n;case Bt.EVENT:return Array.isArray(n)&&("number"==typeof n[0]||"string"==typeof n[0]&&-1===St.indexOf(n[0]));case Bt.ACK:return Array.isArray(n);case Bt.CONNECT_ERROR:return"string"==typeof n||Mt(n);default:return!1}}(t.type,t.data);var n}});function It(t,n,i){return t.on(n,i),function(){t.off(n,i)}}var Rt=Object.freeze({connect:1,connect_error:1,disconnect:1,disconnecting:1,newListener:1,removeListener:1}),Lt=function(t){function n(n,i,r){var o;return(o=t.call(this)||this).connected=!1,o.recovered=!1,o.receiveBuffer=[],o.sendBuffer=[],o.it=[],o.rt=0,o.ids=0,o.acks={},o.flags={},o.io=n,o.nsp=i,r&&r.auth&&(o.auth=r.auth),o.l=e({},r),o.io.et&&o.open(),o}s(n,t);var o=n.prototype;return o.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[It(t,"open",this.onopen.bind(this)),It(t,"packet",this.onpacket.bind(this)),It(t,"error",this.onerror.bind(this)),It(t,"close",this.onclose.bind(this))]}},o.connect=function(){return this.connected||(this.subEvents(),this.io.ot||this.io.open(),"open"===this.io.st&&this.onopen()),this},o.open=function(){return this.connect()},o.send=function(){for(var t=arguments.length,n=new Array(t),i=0;i<t;i++)n[i]=arguments[i];return n.unshift("message"),this.emit.apply(this,n),this},o.emit=function(t){var n,i,r;if(Rt.hasOwnProperty(t))throw new Error('"'+t.toString()+'" is a reserved event name');for(var e=arguments.length,o=new Array(e>1?e-1:0),s=1;s<e;s++)o[s-1]=arguments[s];if(o.unshift(t),this.l.retries&&!this.flags.fromQueue&&!this.flags.volatile)return this.ut(o),this;var u={type:Bt.EVENT,data:o,options:{}};if(u.options.compress=!1!==this.flags.compress,"function"==typeof o[o.length-1]){var h=this.ids++,f=o.pop();this.ht(h,f),u.id=h}var c=null===(i=null===(n=this.io.engine)||void 0===n?void 0:n.transport)||void 0===i?void 0:i.writable,a=this.connected&&!(null===(r=this.io.engine)||void 0===r?void 0:r.W());return this.flags.volatile&&!c||(a?(this.notifyOutgoingListeners(u),this.packet(u)):this.sendBuffer.push(u)),this.flags={},this},o.ht=function(t,n){var i,r=this,e=null!==(i=this.flags.timeout)&&void 0!==i?i:this.l.ackTimeout;if(void 0!==e){var o=this.io.setTimeoutFn((function(){delete r.acks[t];for(var i=0;i<r.sendBuffer.length;i++)r.sendBuffer[i].id===t&&r.sendBuffer.splice(i,1);n.call(r,new Error("operation has timed out"))}),e),s=function(){r.io.clearTimeoutFn(o);for(var t=arguments.length,i=new Array(t),e=0;e<t;e++)i[e]=arguments[e];n.apply(r,i)};s.withError=!0,this.acks[t]=s}else this.acks[t]=n},o.emitWithAck=function(t){for(var n=this,i=arguments.length,r=new Array(i>1?i-1:0),e=1;e<i;e++)r[e-1]=arguments[e];return new Promise((function(i,e){var o=function(t,n){return t?e(t):i(n)};o.withError=!0,r.push(o),n.emit.apply(n,[t].concat(r))}))},o.ut=function(t){var n,i=this;"function"==typeof t[t.length-1]&&(n=t.pop());var r={id:this.rt++,tryCount:0,pending:!1,args:t,flags:e({fromQueue:!0},this.flags)};t.push((function(t){if(r===i.it[0]){if(null!==t)r.tryCount>i.l.retries&&(i.it.shift(),n&&n(t));else if(i.it.shift(),n){for(var e=arguments.length,o=new Array(e>1?e-1:0),s=1;s<e;s++)o[s-1]=arguments[s];n.apply(void 0,[null].concat(o))}return r.pending=!1,i.ft()}})),this.it.push(r),this.ft()},o.ft=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.connected&&0!==this.it.length){var n=this.it[0];n.pending&&!t||(n.pending=!0,n.tryCount++,this.flags=n.flags,this.emit.apply(this,n.args))}},o.packet=function(t){t.nsp=this.nsp,this.io.ct(t)},o.onopen=function(){var t=this;"function"==typeof this.auth?this.auth((function(n){t.vt(n)})):this.vt(this.auth)},o.vt=function(t){this.packet({type:Bt.CONNECT,data:this.lt?e({pid:this.lt,offset:this.dt},t):t})},o.onerror=function(t){this.connected||this.emitReserved("connect_error",t)},o.onclose=function(t,n){this.connected=!1,delete this.id,this.emitReserved("disconnect",t,n),this.yt()},o.yt=function(){var t=this;Object.keys(this.acks).forEach((function(n){if(!t.sendBuffer.some((function(t){return String(t.id)===n}))){var i=t.acks[n];delete t.acks[n],i.withError&&i.call(t,new Error("socket has been disconnected"))}}))},o.onpacket=function(t){if(t.nsp===this.nsp)switch(t.type){case Bt.CONNECT:t.data&&t.data.sid?this.onconnect(t.data.sid,t.data.pid):this.emitReserved("connect_error",new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));break;case Bt.EVENT:case Bt.BINARY_EVENT:this.onevent(t);break;case Bt.ACK:case Bt.BINARY_ACK:this.onack(t);break;case Bt.DISCONNECT:this.ondisconnect();break;case Bt.CONNECT_ERROR:this.destroy();var n=new Error(t.data.message);n.data=t.data.data,this.emitReserved("connect_error",n)}},o.onevent=function(t){var n=t.data||[];null!=t.id&&n.push(this.ack(t.id)),this.connected?this.emitEvent(n):this.receiveBuffer.push(Object.freeze(n))},o.emitEvent=function(n){if(this.bt&&this.bt.length){var i,e=r(this.bt.slice());try{for(e.s();!(i=e.n()).done;){i.value.apply(this,n)}}catch(t){e.e(t)}finally{e.f()}}t.prototype.emit.apply(this,n),this.lt&&n.length&&"string"==typeof n[n.length-1]&&(this.dt=n[n.length-1])},o.ack=function(t){var n=this,i=!1;return function(){if(!i){i=!0;for(var r=arguments.length,e=new Array(r),o=0;o<r;o++)e[o]=arguments[o];n.packet({type:Bt.ACK,id:t,data:e})}}},o.onack=function(t){var n=this.acks[t.id];"function"==typeof n&&(delete this.acks[t.id],n.withError&&t.data.unshift(null),n.apply(this,t.data))},o.onconnect=function(t,n){this.id=t,this.recovered=n&&this.lt===n,this.lt=n,this.connected=!0,this.emitBuffered(),this.emitReserved("connect"),this.ft(!0)},o.emitBuffered=function(){var t=this;this.receiveBuffer.forEach((function(n){return t.emitEvent(n)})),this.receiveBuffer=[],this.sendBuffer.forEach((function(n){t.notifyOutgoingListeners(n),t.packet(n)})),this.sendBuffer=[]},o.ondisconnect=function(){this.destroy(),this.onclose("io server disconnect")},o.destroy=function(){this.subs&&(this.subs.forEach((function(t){return t()})),this.subs=void 0),this.io.wt(this)},o.disconnect=function(){return this.connected&&this.packet({type:Bt.DISCONNECT}),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},o.close=function(){return this.disconnect()},o.compress=function(t){return this.flags.compress=t,this},o.timeout=function(t){return this.flags.timeout=t,this},o.onAny=function(t){return this.bt=this.bt||[],this.bt.push(t),this},o.prependAny=function(t){return this.bt=this.bt||[],this.bt.unshift(t),this},o.offAny=function(t){if(!this.bt)return this;if(t){for(var n=this.bt,i=0;i<n.length;i++)if(t===n[i])return n.splice(i,1),this}else this.bt=[];return this},o.listenersAny=function(){return this.bt||[]},o.onAnyOutgoing=function(t){return this.gt=this.gt||[],this.gt.push(t),this},o.prependAnyOutgoing=function(t){return this.gt=this.gt||[],this.gt.unshift(t),this},o.offAnyOutgoing=function(t){if(!this.gt)return this;if(t){for(var n=this.gt,i=0;i<n.length;i++)if(t===n[i])return n.splice(i,1),this}else this.gt=[];return this},o.listenersAnyOutgoing=function(){return this.gt||[]},o.notifyOutgoingListeners=function(t){if(this.gt&&this.gt.length){var n,i=r(this.gt.slice());try{for(i.s();!(n=i.n()).done;){n.value.apply(this,t.data)}}catch(t){i.e(t)}finally{i.f()}}},i(n,[{key:"disconnected",get:function(){return!this.connected}},{key:"active",get:function(){return!!this.subs}},{key:"volatile",get:function(){return this.flags.volatile=!0,this}}])}(I);function _t(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}_t.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var n=Math.random(),i=Math.floor(n*this.jitter*t);t=1&Math.floor(10*n)?t+i:t-i}return 0|Math.min(t,this.max)},_t.prototype.reset=function(){this.attempts=0},_t.prototype.setMin=function(t){this.ms=t},_t.prototype.setMax=function(t){this.max=t},_t.prototype.setJitter=function(t){this.jitter=t};var Dt=function(t){function n(n,i){var r,e;(r=t.call(this)||this).nsps={},r.subs=[],n&&"object"===c(n)&&(i=n,n=void 0),(i=i||{}).path=i.path||"/socket.io",r.opts=i,$(r,i),r.reconnection(!1!==i.reconnection),r.reconnectionAttempts(i.reconnectionAttempts||1/0),r.reconnectionDelay(i.reconnectionDelay||1e3),r.reconnectionDelayMax(i.reconnectionDelayMax||5e3),r.randomizationFactor(null!==(e=i.randomizationFactor)&&void 0!==e?e:.5),r.backoff=new _t({min:r.reconnectionDelay(),max:r.reconnectionDelayMax(),jitter:r.randomizationFactor()}),r.timeout(null==i.timeout?2e4:i.timeout),r.st="closed",r.uri=n;var o=i.parser||xt;return r.encoder=new o.Encoder,r.decoder=new o.Decoder,r.et=!1!==i.autoConnect,r.et&&r.open(),r}s(n,t);var i=n.prototype;return i.reconnection=function(t){return arguments.length?(this.kt=!!t,t||(this.skipReconnect=!0),this):this.kt},i.reconnectionAttempts=function(t){return void 0===t?this.At:(this.At=t,this)},i.reconnectionDelay=function(t){var n;return void 0===t?this.jt:(this.jt=t,null===(n=this.backoff)||void 0===n||n.setMin(t),this)},i.randomizationFactor=function(t){var n;return void 0===t?this.Et:(this.Et=t,null===(n=this.backoff)||void 0===n||n.setJitter(t),this)},i.reconnectionDelayMax=function(t){var n;return void 0===t?this.Ot:(this.Ot=t,null===(n=this.backoff)||void 0===n||n.setMax(t),this)},i.timeout=function(t){return arguments.length?(this.Bt=t,this):this.Bt},i.maybeReconnectOnOpen=function(){!this.ot&&this.kt&&0===this.backoff.attempts&&this.reconnect()},i.open=function(t){var n=this;if(~this.st.indexOf("open"))return this;this.engine=new pt(this.uri,this.opts);var i=this.engine,r=this;this.st="opening",this.skipReconnect=!1;var e=It(i,"open",(function(){r.onopen(),t&&t()})),o=function(i){n.cleanup(),n.st="closed",n.emitReserved("error",i),t?t(i):n.maybeReconnectOnOpen()},s=It(i,"error",o);if(!1!==this.Bt){var u=this.Bt,h=this.setTimeoutFn((function(){e(),o(new Error("timeout")),i.close()}),u);this.opts.autoUnref&&h.unref(),this.subs.push((function(){n.clearTimeoutFn(h)}))}return this.subs.push(e),this.subs.push(s),this},i.connect=function(t){return this.open(t)},i.onopen=function(){this.cleanup(),this.st="open",this.emitReserved("open");var t=this.engine;this.subs.push(It(t,"ping",this.onping.bind(this)),It(t,"data",this.ondata.bind(this)),It(t,"error",this.onerror.bind(this)),It(t,"close",this.onclose.bind(this)),It(this.decoder,"decoded",this.ondecoded.bind(this)))},i.onping=function(){this.emitReserved("ping")},i.ondata=function(t){try{this.decoder.add(t)}catch(t){this.onclose("parse error",t)}},i.ondecoded=function(t){var n=this;R((function(){n.emitReserved("packet",t)}),this.setTimeoutFn)},i.onerror=function(t){this.emitReserved("error",t)},i.socket=function(t,n){var i=this.nsps[t];return i?this.et&&!i.active&&i.connect():(i=new Lt(this,t,n),this.nsps[t]=i),i},i.wt=function(t){for(var n=0,i=Object.keys(this.nsps);n<i.length;n++){var r=i[n];if(this.nsps[r].active)return}this.St()},i.ct=function(t){for(var n=this.encoder.encode(t),i=0;i<n.length;i++)this.engine.write(n[i],t.options)},i.cleanup=function(){this.subs.forEach((function(t){return t()})),this.subs.length=0,this.decoder.destroy()},i.St=function(){this.skipReconnect=!0,this.ot=!1,this.onclose("forced close")},i.disconnect=function(){return this.St()},i.onclose=function(t,n){var i;this.cleanup(),null===(i=this.engine)||void 0===i||i.close(),this.backoff.reset(),this.st="closed",this.emitReserved("close",t,n),this.kt&&!this.skipReconnect&&this.reconnect()},i.reconnect=function(){var t=this;if(this.ot||this.skipReconnect)return this;var n=this;if(this.backoff.attempts>=this.At)this.backoff.reset(),this.emitReserved("reconnect_failed"),this.ot=!1;else{var i=this.backoff.duration();this.ot=!0;var r=this.setTimeoutFn((function(){n.skipReconnect||(t.emitReserved("reconnect_attempt",n.backoff.attempts),n.skipReconnect||n.open((function(i){i?(n.ot=!1,n.reconnect(),t.emitReserved("reconnect_error",i)):n.onreconnect()})))}),i);this.opts.autoUnref&&r.unref(),this.subs.push((function(){t.clearTimeoutFn(r)}))}},i.onreconnect=function(){var t=this.backoff.attempts;this.ot=!1,this.backoff.reset(),this.emitReserved("reconnect",t)},n}(I),Pt={};function $t(t,n){"object"===c(t)&&(n=t,t=void 0);var i,r=function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",i=arguments.length>2?arguments[2]:void 0,r=t;i=i||"undefined"!=typeof location&&location,null==t&&(t=i.protocol+"//"+i.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?i.protocol+t:i.host+t),/^(https?|wss?):\/\//.test(t)||(t=void 0!==i?i.protocol+"//"+t:"https://"+t),r=ft(t)),r.port||(/^(http|ws)$/.test(r.protocol)?r.port="80":/^(http|ws)s$/.test(r.protocol)&&(r.port="443")),r.path=r.path||"/";var e=-1!==r.host.indexOf(":")?"["+r.host+"]":r.host;return r.id=r.protocol+"://"+e+":"+r.port+n,r.href=r.protocol+"://"+e+(i&&i.port===r.port?"":":"+r.port),r}(t,(n=n||{}).path||"/socket.io"),e=r.source,o=r.id,s=r.path,u=Pt[o]&&s in Pt[o].nsps;return n.forceNew||n["force new connection"]||!1===n.multiplex||u?i=new Dt(e,n):(Pt[o]||(Pt[o]=new Dt(e,n)),i=Pt[o]),r.query&&!n.query&&(n.query=r.queryKey),i.socket(r.path,n)}return e($t,{Manager:Dt,Socket:Lt,io:$t,connect:$t}),$t}));
//# sourceMappingURL=socket.io.min.js.map

class EJS_STORAGE {
    constructor(dbName, storeName) {
        this.dbName = dbName;
        this.storeName = storeName;
    }
    addFileToDB(key, add) {
        (async () => {
            if (key === "?EJS_KEYS!") return;
            let keys = await this.get("?EJS_KEYS!");
            if (!keys) keys = [];
            if (add) {
                if (!keys.includes(key)) keys.push(key);
            } else {
                const index = keys.indexOf(key);
                if (index !== -1) keys.splice(index, 1);
            }
            this.put("?EJS_KEYS!", keys);
        })();
    }
    get(key) {
        return new Promise((resolve, reject) => {
            if (!window.indexedDB) return resolve();
            let openRequest = indexedDB.open(this.dbName, 1);
            openRequest.onerror = () => resolve();
            openRequest.onsuccess = () => {
                let db = openRequest.result;
                let transaction = db.transaction([this.storeName], "readwrite");
                let objectStore = transaction.objectStore(this.storeName);
                let request = objectStore.get(key);
                request.onsuccess = (e) => {
                    resolve(request.result);
                };
                request.onerror = () => resolve();
            };
            openRequest.onupgradeneeded = () => {
                let db = openRequest.result;
                if (!db.objectStoreNames.contains(this.storeName)) {
                    db.createObjectStore(this.storeName);
                };
            };
        });
    }
    put(key, data) {
        return new Promise((resolve, reject) => {
            if (!window.indexedDB) return resolve();
            let openRequest = indexedDB.open(this.dbName, 1);
            openRequest.onerror = () => {};
            openRequest.onsuccess = () => {
                let db = openRequest.result;
                let transaction = db.transaction([this.storeName], "readwrite");
                let objectStore = transaction.objectStore(this.storeName);
                let request = objectStore.put(data, key);
                request.onerror = () => resolve();
                request.onsuccess = () => {
                    this.addFileToDB(key, true);
                    resolve();
                }
            };
            openRequest.onupgradeneeded = () => {
                let db = openRequest.result;
                if (!db.objectStoreNames.contains(this.storeName)) {
                    db.createObjectStore(this.storeName);
                };
            };
        })
    }
    remove(key) {
        return new Promise((resolve, reject) => {
            if (!window.indexedDB) return resolve();
            let openRequest = indexedDB.open(this.dbName, 1);
            openRequest.onerror = () => {};
            openRequest.onsuccess = () => {
                let db = openRequest.result;
                let transaction = db.transaction([this.storeName], "readwrite");
                let objectStore = transaction.objectStore(this.storeName);
                let request2 = objectStore.delete(key);
                this.addFileToDB(key, false);
                request2.onsuccess = () => resolve();
                request2.onerror = () => {};
            };
            openRequest.onupgradeneeded = () => {
                let db = openRequest.result;
                if (!db.objectStoreNames.contains(this.storeName)) {
                    db.createObjectStore(this.storeName);
                };
            };
        });
    }
    getSizes() {
        return new Promise(async (resolve, reject) => {
            if (!window.indexedDB) resolve({});
            const keys = await this.get("?EJS_KEYS!");
            if (!keys) return resolve({});
            let rv = {};
            for (let i = 0; i < keys.length; i++) {
                const result = await this.get(keys[i]);
                if (!result || !result.data || typeof result.data.byteLength !== "number") continue;
                rv[keys[i]] = result.data.byteLength;
            }
            resolve(rv);
        })
    }
}

class EJS_DUMMYSTORAGE {
    constructor() {}
    addFileToDB() {
        return new Promise(resolve => resolve());
    }
    get() {
        return new Promise(resolve => resolve());
    }
    put() {
        return new Promise(resolve => resolve());
    }
    remove() {
        return new Promise(resolve => resolve());
    }
    getSizes() {
        return new Promise(resolve => resolve({}));
    }
}

window.EJS_STORAGE = EJS_STORAGE;
window.EJS_DUMMYSTORAGE = EJS_DUMMYSTORAGE;

